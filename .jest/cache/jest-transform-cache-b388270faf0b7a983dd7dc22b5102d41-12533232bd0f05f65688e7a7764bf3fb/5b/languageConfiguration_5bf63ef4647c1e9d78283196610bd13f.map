{"version":3,"names":["cov_280axl8pqx","actualCoverage","IndentAction","s","f","b","StandardAutoClosingPairConditional","open","close","_inString","_inComment","_inRegEx","_neutralCharacter","_neutralCharacterSearched","constructor","source","Array","isArray","notIn","i","len","length","isOK","standardToken","shouldAutoClose","context","column","getTokenCount","tokenIndex","findTokenIndexAtOffset","standardTokenType","getStandardTokenType","_findNeutralCharacterInRange","fromCharCode","toCharCode","charCode","character","String","includes","findNeutralCharacter","AutoClosingPairs","autoClosingPairsOpenByStart","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","autoClosingPairs","Map","pair","appendEntry","charAt","target","key","value","has","get","push","set"],"sources":["/home/user/Desktop/MintMind/src/vs/editor/common/languages/languageConfiguration.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { StandardTokenType } from '../encodedTokenAttributes.js';\nimport { ScopedLineTokens } from './supports.js';\n\n/**\n * Configuration for line comments.\n */\nexport interface LineCommentConfig {\n\t/**\n\t * The line comment token, like `//`\n\t */\n\tcomment: string;\n\t/**\n\t * Whether the comment token should not be indented and placed at the first column.\n\t * Defaults to false.\n\t */\n\tnoIndent?: boolean;\n}\n\n/**\n * Describes how comments for a language work.\n */\nexport interface CommentRule {\n\t/**\n\t * The line comment token, like `// this is a comment`.\n\t * Can be a string or an object with comment and optional noIndent properties.\n\t */\n\tlineComment?: string | LineCommentConfig | null;\n\t/**\n\t * The block comment character pair, like `/* block comment *&#47;`\n\t */\n\tblockComment?: CharacterPair | null;\n}\n\n/**\n * The language configuration interface defines the contract between extensions and\n * various editor features, like automatic bracket insertion, automatic indentation etc.\n */\nexport interface LanguageConfiguration {\n\t/**\n\t * The language's comment settings.\n\t */\n\tcomments?: CommentRule;\n\t/**\n\t * The language's brackets.\n\t * This configuration implicitly affects pressing Enter around these brackets.\n\t */\n\tbrackets?: CharacterPair[];\n\t/**\n\t * The language's word definition.\n\t * If the language supports Unicode identifiers (e.g. JavaScript), it is preferable\n\t * to provide a word definition that uses exclusion of known separators.\n\t * e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):\n\t *   /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n\t */\n\twordPattern?: RegExp;\n\t/**\n\t * The language's indentation settings.\n\t */\n\tindentationRules?: IndentationRule;\n\t/**\n\t * The language's rules to be evaluated when pressing Enter.\n\t */\n\tonEnterRules?: OnEnterRule[];\n\t/**\n\t * The language's auto closing pairs. The 'close' character is automatically inserted with the\n\t * 'open' character is typed. If not set, the configured brackets will be used.\n\t */\n\tautoClosingPairs?: IAutoClosingPairConditional[];\n\t/**\n\t * The language's surrounding pairs. When the 'open' character is typed on a selection, the\n\t * selected string is surrounded by the open and close characters. If not set, the autoclosing pairs\n\t * settings will be used.\n\t */\n\tsurroundingPairs?: IAutoClosingPair[];\n\t/**\n\t * Defines a list of bracket pairs that are colorized depending on their nesting level.\n\t * If not set, the configured brackets will be used.\n\t*/\n\tcolorizedBracketPairs?: CharacterPair[];\n\t/**\n\t * Defines what characters must be after the cursor for bracket or quote autoclosing to occur when using the \\'languageDefined\\' autoclosing setting.\n\t *\n\t * This is typically the set of characters which can not start an expression, such as whitespace, closing brackets, non-unary operators, etc.\n\t */\n\tautoCloseBefore?: string;\n\n\t/**\n\t * The language's folding rules.\n\t */\n\tfolding?: FoldingRules;\n\n\t/**\n\t * **Deprecated** Do not use.\n\t *\n\t * @deprecated Will be replaced by a better API soon.\n\t */\n\t__electricCharacterSupport?: {\n\t\tdocComment?: IDocComment;\n\t};\n}\n\n/**\n * @internal\n */\ntype OrUndefined<T> = { [P in keyof T]: T[P] | undefined };\n\n/**\n * @internal\n */\nexport type ExplicitLanguageConfiguration = OrUndefined<Required<LanguageConfiguration>>;\n\n/**\n * Describes indentation rules for a language.\n */\nexport interface IndentationRule {\n\t/**\n\t * If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).\n\t */\n\tdecreaseIndentPattern: RegExp;\n\t/**\n\t * If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).\n\t */\n\tincreaseIndentPattern: RegExp;\n\t/**\n\t * If a line matches this pattern, then **only the next line** after it should be indented once.\n\t */\n\tindentNextLinePattern?: RegExp | null;\n\t/**\n\t * If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.\n\t */\n\tunIndentedLinePattern?: RegExp | null;\n\n}\n\n/**\n * Describes language specific folding markers such as '#region' and '#endregion'.\n * The start and end regexes will be tested against the contents of all lines and must be designed efficiently:\n * - the regex should start with '^'\n * - regexp flags (i, g) are ignored\n */\nexport interface FoldingMarkers {\n\tstart: RegExp;\n\tend: RegExp;\n}\n\n/**\n * Describes folding rules for a language.\n */\nexport interface FoldingRules {\n\t/**\n\t * Used by the indentation based strategy to decide whether empty lines belong to the previous or the next block.\n\t * A language adheres to the off-side rule if blocks in that language are expressed by their indentation.\n\t * See [wikipedia](https://en.wikipedia.org/wiki/Off-side_rule) for more information.\n\t * If not set, `false` is used and empty lines belong to the previous block.\n\t */\n\toffSide?: boolean;\n\n\t/**\n\t * Region markers used by the language.\n\t */\n\tmarkers?: FoldingMarkers;\n}\n\n/**\n * Describes a rule to be evaluated when pressing Enter.\n */\nexport interface OnEnterRule {\n\t/**\n\t * This rule will only execute if the text before the cursor matches this regular expression.\n\t */\n\tbeforeText: RegExp;\n\t/**\n\t * This rule will only execute if the text after the cursor matches this regular expression.\n\t */\n\tafterText?: RegExp;\n\t/**\n\t * This rule will only execute if the text above the this line matches this regular expression.\n\t */\n\tpreviousLineText?: RegExp;\n\t/**\n\t * The action to execute.\n\t */\n\taction: EnterAction;\n}\n\n/**\n * Definition of documentation comments (e.g. Javadoc/JSdoc)\n */\nexport interface IDocComment {\n\t/**\n\t * The string that starts a doc comment (e.g. '/**')\n\t */\n\topen: string;\n\t/**\n\t * The string that appears on the last line and closes the doc comment (e.g. ' * /').\n\t */\n\tclose?: string;\n}\n\n/**\n * A tuple of two characters, like a pair of\n * opening and closing brackets.\n */\nexport type CharacterPair = [string, string];\n\nexport interface IAutoClosingPair {\n\topen: string;\n\tclose: string;\n}\n\nexport interface IAutoClosingPairConditional extends IAutoClosingPair {\n\tnotIn?: string[];\n}\n\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport enum IndentAction {\n\t/**\n\t * Insert new line and copy the previous line's indentation.\n\t */\n\tNone = 0,\n\t/**\n\t * Insert new line and indent once (relative to the previous line's indentation).\n\t */\n\tIndent = 1,\n\t/**\n\t * Insert two new lines:\n\t *  - the first one indented which will hold the cursor\n\t *  - the second one at the same indentation level\n\t */\n\tIndentOutdent = 2,\n\t/**\n\t * Insert new line and outdent once (relative to the previous line's indentation).\n\t */\n\tOutdent = 3\n}\n\n/**\n * Describes what to do when pressing Enter.\n */\nexport interface EnterAction {\n\t/**\n\t * Describe what to do with the indentation.\n\t */\n\tindentAction: IndentAction;\n\t/**\n\t * Describes text to be appended after the new line and after the indentation.\n\t */\n\tappendText?: string;\n\t/**\n\t * Describes the number of characters to remove from the new line's indentation.\n\t */\n\tremoveText?: number;\n}\n\n/**\n * @internal\n */\nexport interface CompleteEnterAction {\n\t/**\n\t * Describe what to do with the indentation.\n\t */\n\tindentAction: IndentAction;\n\t/**\n\t * Describes text to be appended after the new line and after the indentation.\n\t */\n\tappendText: string;\n\t/**\n\t * Describes the number of characters to remove from the new line's indentation.\n\t */\n\tremoveText: number;\n\t/**\n\t * The line's indentation minus removeText\n\t */\n\tindentation: string;\n}\n\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n\n\treadonly open: string;\n\treadonly close: string;\n\tprivate readonly _inString: boolean;\n\tprivate readonly _inComment: boolean;\n\tprivate readonly _inRegEx: boolean;\n\tprivate _neutralCharacter: string | null = null;\n\tprivate _neutralCharacterSearched: boolean = false;\n\n\tconstructor(source: IAutoClosingPairConditional) {\n\t\tthis.open = source.open;\n\t\tthis.close = source.close;\n\n\t\t// initially allowed in all tokens\n\t\tthis._inString = true;\n\t\tthis._inComment = true;\n\t\tthis._inRegEx = true;\n\n\t\tif (Array.isArray(source.notIn)) {\n\t\t\tfor (let i = 0, len = source.notIn.length; i < len; i++) {\n\t\t\t\tconst notIn: string = source.notIn[i];\n\t\t\t\tswitch (notIn) {\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tthis._inString = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'comment':\n\t\t\t\t\t\tthis._inComment = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'regex':\n\t\t\t\t\t\tthis._inRegEx = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic isOK(standardToken: StandardTokenType): boolean {\n\t\tswitch (standardToken) {\n\t\t\tcase StandardTokenType.Other:\n\t\t\t\treturn true;\n\t\t\tcase StandardTokenType.Comment:\n\t\t\t\treturn this._inComment;\n\t\t\tcase StandardTokenType.String:\n\t\t\t\treturn this._inString;\n\t\t\tcase StandardTokenType.RegEx:\n\t\t\t\treturn this._inRegEx;\n\t\t}\n\t}\n\n\tpublic shouldAutoClose(context: ScopedLineTokens, column: number): boolean {\n\t\t// Always complete on empty line\n\t\tif (context.getTokenCount() === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst tokenIndex = context.findTokenIndexAtOffset(column - 2);\n\t\tconst standardTokenType = context.getStandardTokenType(tokenIndex);\n\t\treturn this.isOK(standardTokenType);\n\t}\n\n\tprivate _findNeutralCharacterInRange(fromCharCode: number, toCharCode: number): string | null {\n\t\tfor (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n\t\t\tconst character = String.fromCharCode(charCode);\n\t\t\tif (!this.open.includes(character) && !this.close.includes(character)) {\n\t\t\t\treturn character;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n\t */\n\tpublic findNeutralCharacter(): string | null {\n\t\tif (!this._neutralCharacterSearched) {\n\t\t\tthis._neutralCharacterSearched = true;\n\t\t\tif (!this._neutralCharacter) {\n\t\t\t\tthis._neutralCharacter = this._findNeutralCharacterInRange(CharCode.Digit0, CharCode.Digit9);\n\t\t\t}\n\t\t\tif (!this._neutralCharacter) {\n\t\t\t\tthis._neutralCharacter = this._findNeutralCharacterInRange(CharCode.a, CharCode.z);\n\t\t\t}\n\t\t\tif (!this._neutralCharacter) {\n\t\t\t\tthis._neutralCharacter = this._findNeutralCharacterInRange(CharCode.A, CharCode.Z);\n\t\t\t}\n\t\t}\n\t\treturn this._neutralCharacter;\n\t}\n}\n\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n\t// it is useful to be able to get pairs using either end of open and close\n\n\t/** Key is first character of open */\n\tpublic readonly autoClosingPairsOpenByStart: Map<string, StandardAutoClosingPairConditional[]>;\n\t/** Key is last character of open */\n\tpublic readonly autoClosingPairsOpenByEnd: Map<string, StandardAutoClosingPairConditional[]>;\n\t/** Key is first character of close */\n\tpublic readonly autoClosingPairsCloseByStart: Map<string, StandardAutoClosingPairConditional[]>;\n\t/** Key is last character of close */\n\tpublic readonly autoClosingPairsCloseByEnd: Map<string, StandardAutoClosingPairConditional[]>;\n\t/** Key is close. Only has pairs that are a single character */\n\tpublic readonly autoClosingPairsCloseSingleChar: Map<string, StandardAutoClosingPairConditional[]>;\n\n\tconstructor(autoClosingPairs: StandardAutoClosingPairConditional[]) {\n\t\tthis.autoClosingPairsOpenByStart = new Map<string, StandardAutoClosingPairConditional[]>();\n\t\tthis.autoClosingPairsOpenByEnd = new Map<string, StandardAutoClosingPairConditional[]>();\n\t\tthis.autoClosingPairsCloseByStart = new Map<string, StandardAutoClosingPairConditional[]>();\n\t\tthis.autoClosingPairsCloseByEnd = new Map<string, StandardAutoClosingPairConditional[]>();\n\t\tthis.autoClosingPairsCloseSingleChar = new Map<string, StandardAutoClosingPairConditional[]>();\n\t\tfor (const pair of autoClosingPairs) {\n\t\t\tappendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n\t\t\tappendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n\t\t\tappendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n\t\t\tappendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n\t\t\tif (pair.close.length === 1 && pair.open.length === 1) {\n\t\t\t\tappendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction appendEntry<K, V>(target: Map<K, V[]>, key: K, value: V): void {\n\tif (target.has(key)) {\n\t\ttarget.get(key)!.push(value);\n\t} else {\n\t\ttarget.set(key, [value]);\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","ignoreList":[]}
{"version":3,"names":["cov_u9l1y5vd7","actualCoverage","escapeRegExpCharacters","isFuzzyActionArr","what","f","s","Array","isArray","isFuzzyAction","isString","isIAction","empty","b","fixCase","lexer","str","ignoreCase","toLowerCase","sanitize","replace","log","msg","console","languageId","createError","Error","substituteMatches","id","matches","state","re","stateMatches","full","sub","dollar","hash","n","attr","ofs","total","length","split","unshift","substituteMatchesRe","findRules","inState","rules","tokenizer","idx","lastIndexOf","substr","stateExists","exist","stateNames"],"sources":["/home/user/Desktop/MintMind/src/vs/editor/standalone/common/monarch/monarchCommon.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { escapeRegExpCharacters } from '../../../../base/common/strings.js';\n\n/*\n * This module exports common types and functionality shared between\n * the Monarch compiler that compiles JSON to ILexer, and the Monarch\n * Tokenizer (that highlights at runtime)\n */\n\n/*\n * Type definitions to be used internally to Monarch.\n * Inside monarch we use fully typed definitions and compiled versions of the more abstract JSON descriptions.\n */\n\nexport const enum MonarchBracket {\n\tNone = 0,\n\tOpen = 1,\n\tClose = -1\n}\n\nexport interface ILexerMin {\n\tlanguageId: string;\n\tincludeLF: boolean;\n\tnoThrow: boolean;\n\tignoreCase: boolean;\n\tunicode: boolean;\n\tusesEmbedded: boolean;\n\tdefaultToken: string;\n\tstateNames: { [stateName: string]: any };\n\t[attr: string]: any;\n}\n\nexport interface ILexer extends ILexerMin {\n\tmaxStack: number;\n\tstart: string | null;\n\tignoreCase: boolean;\n\tunicode: boolean;\n\ttokenPostfix: string;\n\n\ttokenizer: { [stateName: string]: IRule[] };\n\tbrackets: IBracket[];\n}\n\nexport interface IBracket {\n\ttoken: string;\n\topen: string;\n\tclose: string;\n}\n\nexport type FuzzyAction = IAction | string;\n\nexport function isFuzzyActionArr(what: FuzzyAction | FuzzyAction[]): what is FuzzyAction[] {\n\treturn (Array.isArray(what));\n}\n\nexport function isFuzzyAction(what: FuzzyAction | FuzzyAction[]): what is FuzzyAction {\n\treturn !isFuzzyActionArr(what);\n}\n\nexport function isString(what: FuzzyAction): what is string {\n\treturn (typeof what === 'string');\n}\n\nexport function isIAction(what: FuzzyAction): what is IAction {\n\treturn !isString(what);\n}\n\nexport interface IRule {\n\taction: FuzzyAction;\n\tmatchOnlyAtLineStart: boolean;\n\tname: string;\n\tresolveRegex(state: string): RegExp;\n}\n\nexport interface IAction {\n\t// an action is either a group of actions\n\tgroup?: FuzzyAction[];\n\n\thasEmbeddedEndInCases?: boolean;\n\t// or a function that returns a fresh action\n\ttest?: (id: string, matches: string[], state: string, eos: boolean) => FuzzyAction;\n\n\t// or it is a declarative action with a token value and various other attributes\n\ttoken?: string;\n\ttokenSubst?: boolean;\n\tnext?: string;\n\tnextEmbedded?: string;\n\tbracket?: MonarchBracket;\n\tlog?: string;\n\tswitchTo?: string;\n\tgoBack?: number;\n\ttransform?: (states: string[]) => string[];\n}\n\nexport interface IBranch {\n\tname: string;\n\tvalue: FuzzyAction;\n\ttest?: (id: string, matches: string[], state: string, eos: boolean) => boolean;\n}\n\n// Small helper functions\n\n/**\n * Is a string null, undefined, or empty?\n */\nexport function empty(s: string): boolean {\n\treturn (s ? false : true);\n}\n\n/**\n * Puts a string to lower case if 'ignoreCase' is set.\n */\nexport function fixCase(lexer: ILexerMin, str: string): string {\n\treturn (lexer.ignoreCase && str ? str.toLowerCase() : str);\n}\n\n/**\n * Ensures there are no bad characters in a CSS token class.\n */\nexport function sanitize(s: string) {\n\treturn s.replace(/[&<>'\"_]/g, '-'); // used on all output token CSS classes\n}\n\n// Logging\n\n/**\n * Logs a message.\n */\nexport function log(lexer: ILexerMin, msg: string) {\n\tconsole.log(`${lexer.languageId}: ${msg}`);\n}\n\n// Throwing errors\n\nexport function createError(lexer: ILexerMin, msg: string): Error {\n\treturn new Error(`${lexer.languageId}: ${msg}`);\n}\n\n// Helper functions for rule finding and substitution\n\n/**\n * substituteMatches is used on lexer strings and can substitutes predefined patterns:\n * \t\t$$  => $\n * \t\t$#  => id\n * \t\t$n  => matched entry n\n * \t\t@attr => contents of lexer[attr]\n *\n * See documentation for more info\n */\nexport function substituteMatches(lexer: ILexerMin, str: string, id: string, matches: string[], state: string): string {\n\tconst re = /\\$((\\$)|(#)|(\\d\\d?)|[sS](\\d\\d?)|@(\\w+))/g;\n\tlet stateMatches: string[] | null = null;\n\treturn str.replace(re, function (full, sub?, dollar?, hash?, n?, s?, attr?, ofs?, total?) {\n\t\tif (!empty(dollar)) {\n\t\t\treturn '$'; // $$\n\t\t}\n\t\tif (!empty(hash)) {\n\t\t\treturn fixCase(lexer, id);   // default $#\n\t\t}\n\t\tif (!empty(n) && n < matches.length) {\n\t\t\treturn fixCase(lexer, matches[n]); // $n\n\t\t}\n\t\tif (!empty(attr) && lexer && typeof (lexer[attr]) === 'string') {\n\t\t\treturn lexer[attr]; //@attribute\n\t\t}\n\t\tif (stateMatches === null) { // split state on demand\n\t\t\tstateMatches = state.split('.');\n\t\t\tstateMatches.unshift(state);\n\t\t}\n\t\tif (!empty(s) && s < stateMatches.length) {\n\t\t\treturn fixCase(lexer, stateMatches[s]); //$Sn\n\t\t}\n\t\treturn '';\n\t});\n}\n\n/**\n * substituteMatchesRe is used on lexer regex rules and can substitutes predefined patterns:\n * \t\t$Sn => n'th part of state\n *\n */\nexport function substituteMatchesRe(lexer: ILexerMin, str: string, state: string): string {\n\tconst re = /\\$[sS](\\d\\d?)/g;\n\tlet stateMatches: string[] | null = null;\n\treturn str.replace(re, function (full, s) {\n\t\tif (stateMatches === null) { // split state on demand\n\t\t\tstateMatches = state.split('.');\n\t\t\tstateMatches.unshift(state);\n\t\t}\n\t\tif (!empty(s) && s < stateMatches.length) {\n\t\t\treturn escapeRegExpCharacters(fixCase(lexer, stateMatches[s])); //$Sn\n\t\t}\n\t\treturn '';\n\t});\n}\n\n/**\n * Find the tokenizer rules for a specific state (i.e. next action)\n */\nexport function findRules(lexer: ILexer, inState: string): IRule[] | null {\n\tlet state: string | null = inState;\n\twhile (state && state.length > 0) {\n\t\tconst rules = lexer.tokenizer[state];\n\t\tif (rules) {\n\t\t\treturn rules;\n\t\t}\n\n\t\tconst idx = state.lastIndexOf('.');\n\t\tif (idx < 0) {\n\t\t\tstate = null; // no further parent\n\t\t} else {\n\t\t\tstate = state.substr(0, idx);\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Is a certain state defined? In contrast to 'findRules' this works on a ILexerMin.\n * This is used during compilation where we may know the defined states\n * but not yet whether the corresponding rules are correct.\n */\nexport function stateExists(lexer: ILexerMin, inState: string): boolean {\n\tlet state: string | null = inState;\n\twhile (state && state.length > 0) {\n\t\tconst exist = lexer.stateNames[state];\n\t\tif (exist) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst idx = state.lastIndexOf('.');\n\t\tif (idx < 0) {\n\t\t\tstate = null; // no further parent\n\t\t} else {\n\t\t\tstate = state.substr(0, idx);\n\t\t}\n\t}\n\treturn false;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","ignoreList":[]}
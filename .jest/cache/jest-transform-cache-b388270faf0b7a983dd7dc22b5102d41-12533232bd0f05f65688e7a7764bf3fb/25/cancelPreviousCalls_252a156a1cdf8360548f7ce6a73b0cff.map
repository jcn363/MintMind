{"version":3,"names":["assertDefined","DisposableMap","CancellationTokenSource","CancellationToken","cancelPreviousCalls","_proto","methodName","descriptor","cov_z213pr1pk","f","originalMethod","s","value","objectRecords","WeakMap","args","record","get","b","set","_register","dispose","delete","lastArgument","length","undefined","token","isCancellationToken","cancellationSource","push","call"],"sources":["/home/user/Desktop/MintMind/src/vs/base/common/decorators/cancelPreviousCalls.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertDefined } from '../types.js';\nimport { Disposable, DisposableMap } from '../lifecycle.js';\nimport { CancellationTokenSource, CancellationToken } from '../cancellation.js';\n\n/**\n * Helper type that represents a function that has an optional {@linkcode CancellationToken}\n * argument argument at the end of the arguments list.\n *\n * @typeparam `TFunction` - Type of the function arguments list of which will be extended\n * \t\t\t\t\t\t\twith an optional {@linkcode CancellationToken} argument.\n */\ntype TWithOptionalCancellationToken<TFunction extends Function> = TFunction extends (...args: infer TArgs) => infer TReturn\n\t? (...args: [...TArgs, cancellatioNToken?: CancellationToken]) => TReturn\n\t: never;\n\n/**\n * Decorator that provides a mechanism to cancel previous calls of the decorated method\n * by providing a `cancellation token` as the last argument of the method, which gets\n * cancelled immediately on subsequent call of the decorated method.\n *\n * Therefore to use this decorator, the two conditions must be met:\n *\n * - the decorated method must have an *optional* {@linkcode CancellationToken} argument at\n * \t the end of the arguments list\n * - the object that the decorated method belongs to must implement the {@linkcode Disposable};\n *   this requirement comes from the internal implementation of the decorator that\n *   creates new resources that need to be eventually disposed by someone\n *\n * @typeparam `TObject` - Object type that the decorated method belongs to.\n * @typeparam `TArgs` - Argument list of the decorated method.\n * @typeparam `TReturn` - Return value type of the decorated method.\n *\n * ### Examples\n *\n * ```typescript\n * // let's say we have a class that implements the `Disposable` interface that we want\n * // to use the decorator on\n * class Example extends Disposable {\n * \t\tasync doSomethingAsync(arg1: number, arg2: string): Promise<void> {\n * \t\t\t// do something async..\n * \t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n * \t\t}\n * }\n * ```\n *\n * ```typescript\n * // to do that we need to add the `CancellationToken` argument to the end of args list\n * class Example extends Disposable {\n * \t\t@cancelPreviousCalls\n * \t\tasync doSomethingAsync(arg1: number, arg2: string, cancellationToken?: CancellationToken): Promise<void> {\n * \t\t\tconsole.log(`call with args ${arg1} and ${arg2} initiated`);\n *\n * \t\t\t// the decorator will create the cancellation token automatically\n * \t\t\tassertDefined(\n * \t\t\t\tcancellationToken,\n * \t\t\t\t`The method must now have the `CancellationToken` passed to it.`,\n * \t\t\t);\n *\n * \t\t\tcancellationToken.onCancellationRequested(() => {\n * \t\t\t\tconsole.log(`call with args ${arg1} and ${arg2} was cancelled`);\n * \t\t\t});\n *\n * \t\t\t// do something async..\n * \t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n *\n * \t\t\t// check cancellation token state after the async operations\n * \t\t\tconsole.log(\n * \t\t\t\t`call with args ${arg1} and ${arg2} completed, canceled?: ${cancellationToken.isCancellationRequested}`,\n * \t\t\t);\n * \t\t}\n * }\n *\n * const example = new Example();\n * // call the decorate method first time\n * example.doSomethingAsync(1, 'foo');\n * // wait for 500ms which is less than 1000ms of the async operation in the first call\n * await new Promise(resolve => setTimeout(resolve, 500));\n * // calling the decorate method second time cancels the token passed to the first call\n * example.doSomethingAsync(2, 'bar');\n * ```\n */\nexport function cancelPreviousCalls<\n\tTObject extends Disposable,\n\tTArgs extends unknown[],\n\tTReturn,\n>(\n\t_proto: TObject,\n\tmethodName: string,\n\tdescriptor: TypedPropertyDescriptor<TWithOptionalCancellationToken<(...args: TArgs) => TReturn>>,\n) {\n\tconst originalMethod = descriptor.value;\n\n\tassertDefined(\n\t\toriginalMethod,\n\t\t`Method '${methodName}' is not defined.`,\n\t);\n\n\t// we create the global map that contains `TObjectRecord` for each object instance that\n\t// uses this decorator, which itself contains a `{method name} -> TMethodRecord` mapping\n\t// for each decorated method on the object; the `TMethodRecord` record stores current\n\t// `cancellationTokenSource`, token of which was passed to the previous call of the method\n\tconst objectRecords = new WeakMap<TObject, DisposableMap<string, CancellationTokenSource>>();\n\n\t// decorate the original method with the following logic that upon a new invocation\n\t// of the method cancels the cancellation token that was passed to a previous call\n\tdescriptor.value = function (\n\t\tthis: TObject,\n\t\t...args: Parameters<typeof originalMethod>\n\t): TReturn {\n\t\t// get or create a record for the current object instance\n\t\t// the creation is done once per each object instance\n\t\tlet record = objectRecords.get(this);\n\t\tif (!record) {\n\t\t\trecord = new DisposableMap();\n\t\t\tobjectRecords.set(this, record);\n\n\t\t\tthis._register({\n\t\t\t\tdispose: () => {\n\t\t\t\t\tobjectRecords.get(this)?.dispose();\n\t\t\t\t\tobjectRecords.delete(this);\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// when the decorated method is called again and there is a cancellation token\n\t\t// source exists from a previous call, cancel and dispose it, then remove it\n\t\trecord.get(methodName)?.dispose(true);\n\n\t\t// now we need to provide a cancellation token to the original method\n\t\t// as the last argument, there are two cases to consider:\n\t\t// \t- (common case) the arguments list does not have a cancellation token\n\t\t// \t   as the last argument, - in this case we need to add a new one\n\t\t//  - (possible case) - the arguments list already has a cancellation token\n\t\t//    as the last argument, - in this case we need to reuse the token when\n\t\t//    we create ours, and replace the old token with the new one\n\t\t// therefore,\n\n\t\t// get the last argument of the arguments list and if it is present,\n\t\t// reuse it as the token for the new cancellation token source\n\t\tconst lastArgument = (args.length > 0)\n\t\t\t? args[args.length - 1]\n\t\t\t: undefined;\n\t\tconst token = CancellationToken.isCancellationToken(lastArgument)\n\t\t\t? lastArgument\n\t\t\t: undefined;\n\n\t\tconst cancellationSource = new CancellationTokenSource(token);\n\t\trecord.set(methodName, cancellationSource);\n\n\t\t// then update or add cancellation token at the end of the arguments list\n\t\tif (CancellationToken.isCancellationToken(lastArgument)) {\n\t\t\targs[args.length - 1] = cancellationSource.token;\n\t\t} else {\n\t\t\targs.push(cancellationSource.token);\n\t\t}\n\n\t\t// finally invoke the original method passing original arguments and\n\t\t// the new cancellation token at the end of the arguments list\n\t\treturn originalMethod.call(this, ...args);\n\t};\n\n\treturn descriptor;\n}\n"],"mappings":"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","ignoreList":[]}
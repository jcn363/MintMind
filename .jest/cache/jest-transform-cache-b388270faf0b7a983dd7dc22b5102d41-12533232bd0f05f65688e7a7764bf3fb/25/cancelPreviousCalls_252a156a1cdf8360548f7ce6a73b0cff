0b08003130e7fbce4ba696aa4fd9905f
/* istanbul ignore next */
function cov_z213pr1pk() {
  var path = "/home/user/Desktop/MintMind/src/vs/base/common/decorators/cancelPreviousCalls.ts";
  var hash = "aed7912fa3eb9a79edff36ad25cfdbb552966ee3";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/user/Desktop/MintMind/src/vs/base/common/decorators/cancelPreviousCalls.ts",
    statementMap: {
      "0": {
        start: {
          line: 75,
          column: 27
        },
        end: {
          line: 75,
          column: 43
        }
      },
      "1": {
        start: {
          line: 76,
          column: 4
        },
        end: {
          line: 76,
          column: 76
        }
      },
      "2": {
        start: {
          line: 81,
          column: 26
        },
        end: {
          line: 81,
          column: 39
        }
      },
      "3": {
        start: {
          line: 84,
          column: 4
        },
        end: {
          line: 129,
          column: 6
        }
      },
      "4": {
        start: {
          line: 87,
          column: 21
        },
        end: {
          line: 87,
          column: 44
        }
      },
      "5": {
        start: {
          line: 88,
          column: 8
        },
        end: {
          line: 97,
          column: 9
        }
      },
      "6": {
        start: {
          line: 89,
          column: 12
        },
        end: {
          line: 89,
          column: 41
        }
      },
      "7": {
        start: {
          line: 90,
          column: 12
        },
        end: {
          line: 90,
          column: 44
        }
      },
      "8": {
        start: {
          line: 91,
          column: 12
        },
        end: {
          line: 96,
          column: 15
        }
      },
      "9": {
        start: {
          line: 93,
          column: 20
        },
        end: {
          line: 93,
          column: 55
        }
      },
      "10": {
        start: {
          line: 94,
          column: 20
        },
        end: {
          line: 94,
          column: 47
        }
      },
      "11": {
        start: {
          line: 100,
          column: 8
        },
        end: {
          line: 100,
          column: 46
        }
      },
      "12": {
        start: {
          line: 111,
          column: 29
        },
        end: {
          line: 113,
          column: 23
        }
      },
      "13": {
        start: {
          line: 114,
          column: 22
        },
        end: {
          line: 116,
          column: 23
        }
      },
      "14": {
        start: {
          line: 117,
          column: 35
        },
        end: {
          line: 117,
          column: 69
        }
      },
      "15": {
        start: {
          line: 118,
          column: 8
        },
        end: {
          line: 118,
          column: 51
        }
      },
      "16": {
        start: {
          line: 120,
          column: 8
        },
        end: {
          line: 125,
          column: 9
        }
      },
      "17": {
        start: {
          line: 121,
          column: 12
        },
        end: {
          line: 121,
          column: 61
        }
      },
      "18": {
        start: {
          line: 124,
          column: 12
        },
        end: {
          line: 124,
          column: 48
        }
      },
      "19": {
        start: {
          line: 128,
          column: 8
        },
        end: {
          line: 128,
          column: 50
        }
      },
      "20": {
        start: {
          line: 130,
          column: 4
        },
        end: {
          line: 130,
          column: 22
        }
      }
    },
    fnMap: {
      "0": {
        name: "cancelPreviousCalls",
        decl: {
          start: {
            line: 74,
            column: 16
          },
          end: {
            line: 74,
            column: 35
          }
        },
        loc: {
          start: {
            line: 74,
            column: 68
          },
          end: {
            line: 131,
            column: 1
          }
        },
        line: 74
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 84,
            column: 23
          },
          end: {
            line: 84,
            column: 24
          }
        },
        loc: {
          start: {
            line: 84,
            column: 42
          },
          end: {
            line: 129,
            column: 5
          }
        },
        line: 84
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 92,
            column: 25
          },
          end: {
            line: 92,
            column: 26
          }
        },
        loc: {
          start: {
            line: 92,
            column: 31
          },
          end: {
            line: 95,
            column: 17
          }
        },
        line: 92
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 88,
            column: 8
          },
          end: {
            line: 97,
            column: 9
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 88,
            column: 8
          },
          end: {
            line: 97,
            column: 9
          }
        }, {
          start: {
            line: undefined,
            column: undefined
          },
          end: {
            line: undefined,
            column: undefined
          }
        }],
        line: 88
      },
      "1": {
        loc: {
          start: {
            line: 111,
            column: 29
          },
          end: {
            line: 113,
            column: 23
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 112,
            column: 14
          },
          end: {
            line: 112,
            column: 35
          }
        }, {
          start: {
            line: 113,
            column: 14
          },
          end: {
            line: 113,
            column: 23
          }
        }],
        line: 111
      },
      "2": {
        loc: {
          start: {
            line: 114,
            column: 22
          },
          end: {
            line: 116,
            column: 23
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 115,
            column: 14
          },
          end: {
            line: 115,
            column: 26
          }
        }, {
          start: {
            line: 116,
            column: 14
          },
          end: {
            line: 116,
            column: 23
          }
        }],
        line: 114
      },
      "3": {
        loc: {
          start: {
            line: 120,
            column: 8
          },
          end: {
            line: 125,
            column: 9
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 120,
            column: 8
          },
          end: {
            line: 125,
            column: 9
          }
        }, {
          start: {
            line: 123,
            column: 13
          },
          end: {
            line: 125,
            column: 9
          }
        }],
        line: 120
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0]
    },
    inputSourceMap: {
      file: "/home/user/Desktop/MintMind/src/vs/base/common/decorators/cancelPreviousCalls.ts",
      mappings: "AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAC5C,OAAO,EAAc,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAC5D,OAAO,EAAE,uBAAuB,EAAE,iBAAiB,EAAE,MAAM,oBAAoB,CAAC;AAahF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiEG;AACH,MAAM,UAAU,mBAAmB,CAKlC,MAAe,EACf,UAAkB,EAClB,UAAgG;IAEhG,MAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC;IAExC,aAAa,CACZ,cAAc,EACd,WAAW,UAAU,mBAAmB,CACxC,CAAC;IAEF,uFAAuF;IACvF,wFAAwF;IACxF,qFAAqF;IACrF,0FAA0F;IAC1F,MAAM,aAAa,GAAG,IAAI,OAAO,EAA2D,CAAC;IAE7F,mFAAmF;IACnF,kFAAkF;IAClF,UAAU,CAAC,KAAK,GAAG,UAElB,GAAG,IAAuC;QAE1C,yDAAyD;QACzD,qDAAqD;QACrD,IAAI,MAAM,GAAG,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACrC,IAAI,CAAC,MAAM,EAAE,CAAC;YACb,MAAM,GAAG,IAAI,aAAa,EAAE,CAAC;YAC7B,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YAEhC,IAAI,CAAC,SAAS,CAAC;gBACd,OAAO,EAAE,GAAG,EAAE;oBACb,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,CAAC;oBACnC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBAC5B,CAAC;aACD,CAAC,CAAC;QACJ,CAAC;QAED,8EAA8E;QAC9E,4EAA4E;QAC5E,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;QAEtC,qEAAqE;QACrE,yDAAyD;QACzD,yEAAyE;QACzE,oEAAoE;QACpE,2EAA2E;QAC3E,0EAA0E;QAC1E,gEAAgE;QAChE,aAAa;QAEb,oEAAoE;QACpE,8DAA8D;QAC9D,MAAM,YAAY,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YACrC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YACvB,CAAC,CAAC,SAAS,CAAC;QACb,MAAM,KAAK,GAAG,iBAAiB,CAAC,mBAAmB,CAAC,YAAY,CAAC;YAChE,CAAC,CAAC,YAAY;YACd,CAAC,CAAC,SAAS,CAAC;QAEb,MAAM,kBAAkB,GAAG,IAAI,uBAAuB,CAAC,KAAK,CAAC,CAAC;QAC9D,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC;QAE3C,yEAAyE;QACzE,IAAI,iBAAiB,CAAC,mBAAmB,CAAC,YAAY,CAAC,EAAE,CAAC;YACzD,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,kBAAkB,CAAC,KAAK,CAAC;QAClD,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;QACrC,CAAC;QAED,oEAAoE;QACpE,8DAA8D;QAC9D,OAAO,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC;IAC3C,CAAC,CAAC;IAEF,OAAO,UAAU,CAAC;AACnB,CAAC",
      names: [],
      sources: ["/home/user/Desktop/MintMind/src/vs/base/common/decorators/cancelPreviousCalls.ts"],
      sourcesContent: ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertDefined } from '../types.js';\nimport { Disposable, DisposableMap } from '../lifecycle.js';\nimport { CancellationTokenSource, CancellationToken } from '../cancellation.js';\n\n/**\n * Helper type that represents a function that has an optional {@linkcode CancellationToken}\n * argument argument at the end of the arguments list.\n *\n * @typeparam `TFunction` - Type of the function arguments list of which will be extended\n * \t\t\t\t\t\t\twith an optional {@linkcode CancellationToken} argument.\n */\ntype TWithOptionalCancellationToken<TFunction extends Function> = TFunction extends (...args: infer TArgs) => infer TReturn\n\t? (...args: [...TArgs, cancellatioNToken?: CancellationToken]) => TReturn\n\t: never;\n\n/**\n * Decorator that provides a mechanism to cancel previous calls of the decorated method\n * by providing a `cancellation token` as the last argument of the method, which gets\n * cancelled immediately on subsequent call of the decorated method.\n *\n * Therefore to use this decorator, the two conditions must be met:\n *\n * - the decorated method must have an *optional* {@linkcode CancellationToken} argument at\n * \t the end of the arguments list\n * - the object that the decorated method belongs to must implement the {@linkcode Disposable};\n *   this requirement comes from the internal implementation of the decorator that\n *   creates new resources that need to be eventually disposed by someone\n *\n * @typeparam `TObject` - Object type that the decorated method belongs to.\n * @typeparam `TArgs` - Argument list of the decorated method.\n * @typeparam `TReturn` - Return value type of the decorated method.\n *\n * ### Examples\n *\n * ```typescript\n * // let's say we have a class that implements the `Disposable` interface that we want\n * // to use the decorator on\n * class Example extends Disposable {\n * \t\tasync doSomethingAsync(arg1: number, arg2: string): Promise<void> {\n * \t\t\t// do something async..\n * \t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n * \t\t}\n * }\n * ```\n *\n * ```typescript\n * // to do that we need to add the `CancellationToken` argument to the end of args list\n * class Example extends Disposable {\n * \t\t@cancelPreviousCalls\n * \t\tasync doSomethingAsync(arg1: number, arg2: string, cancellationToken?: CancellationToken): Promise<void> {\n * \t\t\tconsole.log(`call with args ${arg1} and ${arg2} initiated`);\n *\n * \t\t\t// the decorator will create the cancellation token automatically\n * \t\t\tassertDefined(\n * \t\t\t\tcancellationToken,\n * \t\t\t\t`The method must now have the `CancellationToken` passed to it.`,\n * \t\t\t);\n *\n * \t\t\tcancellationToken.onCancellationRequested(() => {\n * \t\t\t\tconsole.log(`call with args ${arg1} and ${arg2} was cancelled`);\n * \t\t\t});\n *\n * \t\t\t// do something async..\n * \t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n *\n * \t\t\t// check cancellation token state after the async operations\n * \t\t\tconsole.log(\n * \t\t\t\t`call with args ${arg1} and ${arg2} completed, canceled?: ${cancellationToken.isCancellationRequested}`,\n * \t\t\t);\n * \t\t}\n * }\n *\n * const example = new Example();\n * // call the decorate method first time\n * example.doSomethingAsync(1, 'foo');\n * // wait for 500ms which is less than 1000ms of the async operation in the first call\n * await new Promise(resolve => setTimeout(resolve, 500));\n * // calling the decorate method second time cancels the token passed to the first call\n * example.doSomethingAsync(2, 'bar');\n * ```\n */\nexport function cancelPreviousCalls<\n\tTObject extends Disposable,\n\tTArgs extends unknown[],\n\tTReturn,\n>(\n\t_proto: TObject,\n\tmethodName: string,\n\tdescriptor: TypedPropertyDescriptor<TWithOptionalCancellationToken<(...args: TArgs) => TReturn>>,\n) {\n\tconst originalMethod = descriptor.value;\n\n\tassertDefined(\n\t\toriginalMethod,\n\t\t`Method '${methodName}' is not defined.`,\n\t);\n\n\t// we create the global map that contains `TObjectRecord` for each object instance that\n\t// uses this decorator, which itself contains a `{method name} -> TMethodRecord` mapping\n\t// for each decorated method on the object; the `TMethodRecord` record stores current\n\t// `cancellationTokenSource`, token of which was passed to the previous call of the method\n\tconst objectRecords = new WeakMap<TObject, DisposableMap<string, CancellationTokenSource>>();\n\n\t// decorate the original method with the following logic that upon a new invocation\n\t// of the method cancels the cancellation token that was passed to a previous call\n\tdescriptor.value = function (\n\t\tthis: TObject,\n\t\t...args: Parameters<typeof originalMethod>\n\t): TReturn {\n\t\t// get or create a record for the current object instance\n\t\t// the creation is done once per each object instance\n\t\tlet record = objectRecords.get(this);\n\t\tif (!record) {\n\t\t\trecord = new DisposableMap();\n\t\t\tobjectRecords.set(this, record);\n\n\t\t\tthis._register({\n\t\t\t\tdispose: () => {\n\t\t\t\t\tobjectRecords.get(this)?.dispose();\n\t\t\t\t\tobjectRecords.delete(this);\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// when the decorated method is called again and there is a cancellation token\n\t\t// source exists from a previous call, cancel and dispose it, then remove it\n\t\trecord.get(methodName)?.dispose(true);\n\n\t\t// now we need to provide a cancellation token to the original method\n\t\t// as the last argument, there are two cases to consider:\n\t\t// \t- (common case) the arguments list does not have a cancellation token\n\t\t// \t   as the last argument, - in this case we need to add a new one\n\t\t//  - (possible case) - the arguments list already has a cancellation token\n\t\t//    as the last argument, - in this case we need to reuse the token when\n\t\t//    we create ours, and replace the old token with the new one\n\t\t// therefore,\n\n\t\t// get the last argument of the arguments list and if it is present,\n\t\t// reuse it as the token for the new cancellation token source\n\t\tconst lastArgument = (args.length > 0)\n\t\t\t? args[args.length - 1]\n\t\t\t: undefined;\n\t\tconst token = CancellationToken.isCancellationToken(lastArgument)\n\t\t\t? lastArgument\n\t\t\t: undefined;\n\n\t\tconst cancellationSource = new CancellationTokenSource(token);\n\t\trecord.set(methodName, cancellationSource);\n\n\t\t// then update or add cancellation token at the end of the arguments list\n\t\tif (CancellationToken.isCancellationToken(lastArgument)) {\n\t\t\targs[args.length - 1] = cancellationSource.token;\n\t\t} else {\n\t\t\targs.push(cancellationSource.token);\n\t\t}\n\n\t\t// finally invoke the original method passing original arguments and\n\t\t// the new cancellation token at the end of the arguments list\n\t\treturn originalMethod.call(this, ...args);\n\t};\n\n\treturn descriptor;\n}\n"],
      version: 3
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "aed7912fa3eb9a79edff36ad25cfdbb552966ee3"
  };
  var coverage = global[gcv] || (global[gcv] = {});
  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }
  var actualCoverage = coverage[path];
  {
    // @ts-ignore
    cov_z213pr1pk = function () {
      return actualCoverage;
    };
  }
  return actualCoverage;
}
cov_z213pr1pk();
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { assertDefined } from '../types.js';
import { DisposableMap } from '../lifecycle.js';
import { CancellationTokenSource, CancellationToken } from '../cancellation.js';
/**
 * Decorator that provides a mechanism to cancel previous calls of the decorated method
 * by providing a `cancellation token` as the last argument of the method, which gets
 * cancelled immediately on subsequent call of the decorated method.
 *
 * Therefore to use this decorator, the two conditions must be met:
 *
 * - the decorated method must have an *optional* {@linkcode CancellationToken} argument at
 * 	 the end of the arguments list
 * - the object that the decorated method belongs to must implement the {@linkcode Disposable};
 *   this requirement comes from the internal implementation of the decorator that
 *   creates new resources that need to be eventually disposed by someone
 *
 * @typeparam `TObject` - Object type that the decorated method belongs to.
 * @typeparam `TArgs` - Argument list of the decorated method.
 * @typeparam `TReturn` - Return value type of the decorated method.
 *
 * ### Examples
 *
 * ```typescript
 * // let's say we have a class that implements the `Disposable` interface that we want
 * // to use the decorator on
 * class Example extends Disposable {
 * 		async doSomethingAsync(arg1: number, arg2: string): Promise<void> {
 * 			// do something async..
 * 			await new Promise(resolve => setTimeout(resolve, 1000));
 * 		}
 * }
 * ```
 *
 * ```typescript
 * // to do that we need to add the `CancellationToken` argument to the end of args list
 * class Example extends Disposable {
 * 		@cancelPreviousCalls
 * 		async doSomethingAsync(arg1: number, arg2: string, cancellationToken?: CancellationToken): Promise<void> {
 * 			console.log(`call with args ${arg1} and ${arg2} initiated`);
 *
 * 			// the decorator will create the cancellation token automatically
 * 			assertDefined(
 * 				cancellationToken,
 * 				`The method must now have the `CancellationToken` passed to it.`,
 * 			);
 *
 * 			cancellationToken.onCancellationRequested(() => {
 * 				console.log(`call with args ${arg1} and ${arg2} was cancelled`);
 * 			});
 *
 * 			// do something async..
 * 			await new Promise(resolve => setTimeout(resolve, 1000));
 *
 * 			// check cancellation token state after the async operations
 * 			console.log(
 * 				`call with args ${arg1} and ${arg2} completed, canceled?: ${cancellationToken.isCancellationRequested}`,
 * 			);
 * 		}
 * }
 *
 * const example = new Example();
 * // call the decorate method first time
 * example.doSomethingAsync(1, 'foo');
 * // wait for 500ms which is less than 1000ms of the async operation in the first call
 * await new Promise(resolve => setTimeout(resolve, 500));
 * // calling the decorate method second time cancels the token passed to the first call
 * example.doSomethingAsync(2, 'bar');
 * ```
 */
export function cancelPreviousCalls(_proto, methodName, descriptor) {
  /* istanbul ignore next */
  cov_z213pr1pk().f[0]++;
  const originalMethod =
  /* istanbul ignore next */
  (cov_z213pr1pk().s[0]++, descriptor.value);
  /* istanbul ignore next */
  cov_z213pr1pk().s[1]++;
  assertDefined(originalMethod, `Method '${methodName}' is not defined.`);
  // we create the global map that contains `TObjectRecord` for each object instance that
  // uses this decorator, which itself contains a `{method name} -> TMethodRecord` mapping
  // for each decorated method on the object; the `TMethodRecord` record stores current
  // `cancellationTokenSource`, token of which was passed to the previous call of the method
  const objectRecords =
  /* istanbul ignore next */
  (cov_z213pr1pk().s[2]++, new WeakMap());
  // decorate the original method with the following logic that upon a new invocation
  // of the method cancels the cancellation token that was passed to a previous call
  /* istanbul ignore next */
  cov_z213pr1pk().s[3]++;
  descriptor.value = function (...args) {
    /* istanbul ignore next */
    cov_z213pr1pk().f[1]++;
    // get or create a record for the current object instance
    // the creation is done once per each object instance
    let record =
    /* istanbul ignore next */
    (cov_z213pr1pk().s[4]++, objectRecords.get(this));
    /* istanbul ignore next */
    cov_z213pr1pk().s[5]++;
    if (!record) {
      /* istanbul ignore next */
      cov_z213pr1pk().b[0][0]++;
      cov_z213pr1pk().s[6]++;
      record = new DisposableMap();
      /* istanbul ignore next */
      cov_z213pr1pk().s[7]++;
      objectRecords.set(this, record);
      /* istanbul ignore next */
      cov_z213pr1pk().s[8]++;
      this._register({
        dispose: () => {
          /* istanbul ignore next */
          cov_z213pr1pk().f[2]++;
          cov_z213pr1pk().s[9]++;
          objectRecords.get(this)?.dispose();
          /* istanbul ignore next */
          cov_z213pr1pk().s[10]++;
          objectRecords.delete(this);
        }
      });
    } else
    /* istanbul ignore next */
    {
      cov_z213pr1pk().b[0][1]++;
    }
    // when the decorated method is called again and there is a cancellation token
    // source exists from a previous call, cancel and dispose it, then remove it
    cov_z213pr1pk().s[11]++;
    record.get(methodName)?.dispose(true);
    // now we need to provide a cancellation token to the original method
    // as the last argument, there are two cases to consider:
    // 	- (common case) the arguments list does not have a cancellation token
    // 	   as the last argument, - in this case we need to add a new one
    //  - (possible case) - the arguments list already has a cancellation token
    //    as the last argument, - in this case we need to reuse the token when
    //    we create ours, and replace the old token with the new one
    // therefore,
    // get the last argument of the arguments list and if it is present,
    // reuse it as the token for the new cancellation token source
    const lastArgument =
    /* istanbul ignore next */
    (cov_z213pr1pk().s[12]++, args.length > 0 ?
    /* istanbul ignore next */
    (cov_z213pr1pk().b[1][0]++, args[args.length - 1]) :
    /* istanbul ignore next */
    (cov_z213pr1pk().b[1][1]++, undefined));
    const token =
    /* istanbul ignore next */
    (cov_z213pr1pk().s[13]++, CancellationToken.isCancellationToken(lastArgument) ?
    /* istanbul ignore next */
    (cov_z213pr1pk().b[2][0]++, lastArgument) :
    /* istanbul ignore next */
    (cov_z213pr1pk().b[2][1]++, undefined));
    const cancellationSource =
    /* istanbul ignore next */
    (cov_z213pr1pk().s[14]++, new CancellationTokenSource(token));
    /* istanbul ignore next */
    cov_z213pr1pk().s[15]++;
    record.set(methodName, cancellationSource);
    // then update or add cancellation token at the end of the arguments list
    /* istanbul ignore next */
    cov_z213pr1pk().s[16]++;
    if (CancellationToken.isCancellationToken(lastArgument)) {
      /* istanbul ignore next */
      cov_z213pr1pk().b[3][0]++;
      cov_z213pr1pk().s[17]++;
      args[args.length - 1] = cancellationSource.token;
    } else {
      /* istanbul ignore next */
      cov_z213pr1pk().b[3][1]++;
      cov_z213pr1pk().s[18]++;
      args.push(cancellationSource.token);
    }
    // finally invoke the original method passing original arguments and
    // the new cancellation token at the end of the arguments list
    /* istanbul ignore next */
    cov_z213pr1pk().s[19]++;
    return originalMethod.call(this, ...args);
  };
  /* istanbul ignore next */
  cov_z213pr1pk().s[20]++;
  return descriptor;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhc3NlcnREZWZpbmVkIiwiRGlzcG9zYWJsZU1hcCIsIkNhbmNlbGxhdGlvblRva2VuU291cmNlIiwiQ2FuY2VsbGF0aW9uVG9rZW4iLCJjYW5jZWxQcmV2aW91c0NhbGxzIiwiX3Byb3RvIiwibWV0aG9kTmFtZSIsImRlc2NyaXB0b3IiLCJjb3ZfejIxM3ByMXBrIiwiZiIsIm9yaWdpbmFsTWV0aG9kIiwicyIsInZhbHVlIiwib2JqZWN0UmVjb3JkcyIsIldlYWtNYXAiLCJhcmdzIiwicmVjb3JkIiwiZ2V0IiwiYiIsInNldCIsIl9yZWdpc3RlciIsImRpc3Bvc2UiLCJkZWxldGUiLCJsYXN0QXJndW1lbnQiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJ0b2tlbiIsImlzQ2FuY2VsbGF0aW9uVG9rZW4iLCJjYW5jZWxsYXRpb25Tb3VyY2UiLCJwdXNoIiwiY2FsbCJdLCJzb3VyY2VzIjpbIi9ob21lL3VzZXIvRGVza3RvcC9NaW50TWluZC9zcmMvdnMvYmFzZS9jb21tb24vZGVjb3JhdG9ycy9jYW5jZWxQcmV2aW91c0NhbGxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5pbXBvcnQgeyBhc3NlcnREZWZpbmVkIH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSwgRGlzcG9zYWJsZU1hcCB9IGZyb20gJy4uL2xpZmVjeWNsZS5qcyc7XG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSwgQ2FuY2VsbGF0aW9uVG9rZW4gfSBmcm9tICcuLi9jYW5jZWxsYXRpb24uanMnO1xuXG4vKipcbiAqIEhlbHBlciB0eXBlIHRoYXQgcmVwcmVzZW50cyBhIGZ1bmN0aW9uIHRoYXQgaGFzIGFuIG9wdGlvbmFsIHtAbGlua2NvZGUgQ2FuY2VsbGF0aW9uVG9rZW59XG4gKiBhcmd1bWVudCBhcmd1bWVudCBhdCB0aGUgZW5kIG9mIHRoZSBhcmd1bWVudHMgbGlzdC5cbiAqXG4gKiBAdHlwZXBhcmFtIGBURnVuY3Rpb25gIC0gVHlwZSBvZiB0aGUgZnVuY3Rpb24gYXJndW1lbnRzIGxpc3Qgb2Ygd2hpY2ggd2lsbCBiZSBleHRlbmRlZFxuICogXHRcdFx0XHRcdFx0XHR3aXRoIGFuIG9wdGlvbmFsIHtAbGlua2NvZGUgQ2FuY2VsbGF0aW9uVG9rZW59IGFyZ3VtZW50LlxuICovXG50eXBlIFRXaXRoT3B0aW9uYWxDYW5jZWxsYXRpb25Ub2tlbjxURnVuY3Rpb24gZXh0ZW5kcyBGdW5jdGlvbj4gPSBURnVuY3Rpb24gZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgVEFyZ3MpID0+IGluZmVyIFRSZXR1cm5cblx0PyAoLi4uYXJnczogWy4uLlRBcmdzLCBjYW5jZWxsYXRpb05Ub2tlbj86IENhbmNlbGxhdGlvblRva2VuXSkgPT4gVFJldHVyblxuXHQ6IG5ldmVyO1xuXG4vKipcbiAqIERlY29yYXRvciB0aGF0IHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIGNhbmNlbCBwcmV2aW91cyBjYWxscyBvZiB0aGUgZGVjb3JhdGVkIG1ldGhvZFxuICogYnkgcHJvdmlkaW5nIGEgYGNhbmNlbGxhdGlvbiB0b2tlbmAgYXMgdGhlIGxhc3QgYXJndW1lbnQgb2YgdGhlIG1ldGhvZCwgd2hpY2ggZ2V0c1xuICogY2FuY2VsbGVkIGltbWVkaWF0ZWx5IG9uIHN1YnNlcXVlbnQgY2FsbCBvZiB0aGUgZGVjb3JhdGVkIG1ldGhvZC5cbiAqXG4gKiBUaGVyZWZvcmUgdG8gdXNlIHRoaXMgZGVjb3JhdG9yLCB0aGUgdHdvIGNvbmRpdGlvbnMgbXVzdCBiZSBtZXQ6XG4gKlxuICogLSB0aGUgZGVjb3JhdGVkIG1ldGhvZCBtdXN0IGhhdmUgYW4gKm9wdGlvbmFsKiB7QGxpbmtjb2RlIENhbmNlbGxhdGlvblRva2VufSBhcmd1bWVudCBhdFxuICogXHQgdGhlIGVuZCBvZiB0aGUgYXJndW1lbnRzIGxpc3RcbiAqIC0gdGhlIG9iamVjdCB0aGF0IHRoZSBkZWNvcmF0ZWQgbWV0aG9kIGJlbG9uZ3MgdG8gbXVzdCBpbXBsZW1lbnQgdGhlIHtAbGlua2NvZGUgRGlzcG9zYWJsZX07XG4gKiAgIHRoaXMgcmVxdWlyZW1lbnQgY29tZXMgZnJvbSB0aGUgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIGRlY29yYXRvciB0aGF0XG4gKiAgIGNyZWF0ZXMgbmV3IHJlc291cmNlcyB0aGF0IG5lZWQgdG8gYmUgZXZlbnR1YWxseSBkaXNwb3NlZCBieSBzb21lb25lXG4gKlxuICogQHR5cGVwYXJhbSBgVE9iamVjdGAgLSBPYmplY3QgdHlwZSB0aGF0IHRoZSBkZWNvcmF0ZWQgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gKiBAdHlwZXBhcmFtIGBUQXJnc2AgLSBBcmd1bWVudCBsaXN0IG9mIHRoZSBkZWNvcmF0ZWQgbWV0aG9kLlxuICogQHR5cGVwYXJhbSBgVFJldHVybmAgLSBSZXR1cm4gdmFsdWUgdHlwZSBvZiB0aGUgZGVjb3JhdGVkIG1ldGhvZC5cbiAqXG4gKiAjIyMgRXhhbXBsZXNcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBsZXQncyBzYXkgd2UgaGF2ZSBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB0aGUgYERpc3Bvc2FibGVgIGludGVyZmFjZSB0aGF0IHdlIHdhbnRcbiAqIC8vIHRvIHVzZSB0aGUgZGVjb3JhdG9yIG9uXG4gKiBjbGFzcyBFeGFtcGxlIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gKiBcdFx0YXN5bmMgZG9Tb21ldGhpbmdBc3luYyhhcmcxOiBudW1iZXIsIGFyZzI6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICogXHRcdFx0Ly8gZG8gc29tZXRoaW5nIGFzeW5jLi5cbiAqIFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gKiBcdFx0fVxuICogfVxuICogYGBgXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gdG8gZG8gdGhhdCB3ZSBuZWVkIHRvIGFkZCB0aGUgYENhbmNlbGxhdGlvblRva2VuYCBhcmd1bWVudCB0byB0aGUgZW5kIG9mIGFyZ3MgbGlzdFxuICogY2xhc3MgRXhhbXBsZSBleHRlbmRzIERpc3Bvc2FibGUge1xuICogXHRcdEBjYW5jZWxQcmV2aW91c0NhbGxzXG4gKiBcdFx0YXN5bmMgZG9Tb21ldGhpbmdBc3luYyhhcmcxOiBudW1iZXIsIGFyZzI6IHN0cmluZywgY2FuY2VsbGF0aW9uVG9rZW4/OiBDYW5jZWxsYXRpb25Ub2tlbik6IFByb21pc2U8dm9pZD4ge1xuICogXHRcdFx0Y29uc29sZS5sb2coYGNhbGwgd2l0aCBhcmdzICR7YXJnMX0gYW5kICR7YXJnMn0gaW5pdGlhdGVkYCk7XG4gKlxuICogXHRcdFx0Ly8gdGhlIGRlY29yYXRvciB3aWxsIGNyZWF0ZSB0aGUgY2FuY2VsbGF0aW9uIHRva2VuIGF1dG9tYXRpY2FsbHlcbiAqIFx0XHRcdGFzc2VydERlZmluZWQoXG4gKiBcdFx0XHRcdGNhbmNlbGxhdGlvblRva2VuLFxuICogXHRcdFx0XHRgVGhlIG1ldGhvZCBtdXN0IG5vdyBoYXZlIHRoZSBgQ2FuY2VsbGF0aW9uVG9rZW5gIHBhc3NlZCB0byBpdC5gLFxuICogXHRcdFx0KTtcbiAqXG4gKiBcdFx0XHRjYW5jZWxsYXRpb25Ub2tlbi5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgoKSA9PiB7XG4gKiBcdFx0XHRcdGNvbnNvbGUubG9nKGBjYWxsIHdpdGggYXJncyAke2FyZzF9IGFuZCAke2FyZzJ9IHdhcyBjYW5jZWxsZWRgKTtcbiAqIFx0XHRcdH0pO1xuICpcbiAqIFx0XHRcdC8vIGRvIHNvbWV0aGluZyBhc3luYy4uXG4gKiBcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICpcbiAqIFx0XHRcdC8vIGNoZWNrIGNhbmNlbGxhdGlvbiB0b2tlbiBzdGF0ZSBhZnRlciB0aGUgYXN5bmMgb3BlcmF0aW9uc1xuICogXHRcdFx0Y29uc29sZS5sb2coXG4gKiBcdFx0XHRcdGBjYWxsIHdpdGggYXJncyAke2FyZzF9IGFuZCAke2FyZzJ9IGNvbXBsZXRlZCwgY2FuY2VsZWQ/OiAke2NhbmNlbGxhdGlvblRva2VuLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkfWAsXG4gKiBcdFx0XHQpO1xuICogXHRcdH1cbiAqIH1cbiAqXG4gKiBjb25zdCBleGFtcGxlID0gbmV3IEV4YW1wbGUoKTtcbiAqIC8vIGNhbGwgdGhlIGRlY29yYXRlIG1ldGhvZCBmaXJzdCB0aW1lXG4gKiBleGFtcGxlLmRvU29tZXRoaW5nQXN5bmMoMSwgJ2ZvbycpO1xuICogLy8gd2FpdCBmb3IgNTAwbXMgd2hpY2ggaXMgbGVzcyB0aGFuIDEwMDBtcyBvZiB0aGUgYXN5bmMgb3BlcmF0aW9uIGluIHRoZSBmaXJzdCBjYWxsXG4gKiBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gKiAvLyBjYWxsaW5nIHRoZSBkZWNvcmF0ZSBtZXRob2Qgc2Vjb25kIHRpbWUgY2FuY2VscyB0aGUgdG9rZW4gcGFzc2VkIHRvIHRoZSBmaXJzdCBjYWxsXG4gKiBleGFtcGxlLmRvU29tZXRoaW5nQXN5bmMoMiwgJ2JhcicpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxQcmV2aW91c0NhbGxzPFxuXHRUT2JqZWN0IGV4dGVuZHMgRGlzcG9zYWJsZSxcblx0VEFyZ3MgZXh0ZW5kcyB1bmtub3duW10sXG5cdFRSZXR1cm4sXG4+KFxuXHRfcHJvdG86IFRPYmplY3QsXG5cdG1ldGhvZE5hbWU6IHN0cmluZyxcblx0ZGVzY3JpcHRvcjogVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8VFdpdGhPcHRpb25hbENhbmNlbGxhdGlvblRva2VuPCguLi5hcmdzOiBUQXJncykgPT4gVFJldHVybj4+LFxuKSB7XG5cdGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcblxuXHRhc3NlcnREZWZpbmVkKFxuXHRcdG9yaWdpbmFsTWV0aG9kLFxuXHRcdGBNZXRob2QgJyR7bWV0aG9kTmFtZX0nIGlzIG5vdCBkZWZpbmVkLmAsXG5cdCk7XG5cblx0Ly8gd2UgY3JlYXRlIHRoZSBnbG9iYWwgbWFwIHRoYXQgY29udGFpbnMgYFRPYmplY3RSZWNvcmRgIGZvciBlYWNoIG9iamVjdCBpbnN0YW5jZSB0aGF0XG5cdC8vIHVzZXMgdGhpcyBkZWNvcmF0b3IsIHdoaWNoIGl0c2VsZiBjb250YWlucyBhIGB7bWV0aG9kIG5hbWV9IC0+IFRNZXRob2RSZWNvcmRgIG1hcHBpbmdcblx0Ly8gZm9yIGVhY2ggZGVjb3JhdGVkIG1ldGhvZCBvbiB0aGUgb2JqZWN0OyB0aGUgYFRNZXRob2RSZWNvcmRgIHJlY29yZCBzdG9yZXMgY3VycmVudFxuXHQvLyBgY2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2VgLCB0b2tlbiBvZiB3aGljaCB3YXMgcGFzc2VkIHRvIHRoZSBwcmV2aW91cyBjYWxsIG9mIHRoZSBtZXRob2Rcblx0Y29uc3Qgb2JqZWN0UmVjb3JkcyA9IG5ldyBXZWFrTWFwPFRPYmplY3QsIERpc3Bvc2FibGVNYXA8c3RyaW5nLCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZT4+KCk7XG5cblx0Ly8gZGVjb3JhdGUgdGhlIG9yaWdpbmFsIG1ldGhvZCB3aXRoIHRoZSBmb2xsb3dpbmcgbG9naWMgdGhhdCB1cG9uIGEgbmV3IGludm9jYXRpb25cblx0Ly8gb2YgdGhlIG1ldGhvZCBjYW5jZWxzIHRoZSBjYW5jZWxsYXRpb24gdG9rZW4gdGhhdCB3YXMgcGFzc2VkIHRvIGEgcHJldmlvdXMgY2FsbFxuXHRkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKFxuXHRcdHRoaXM6IFRPYmplY3QsXG5cdFx0Li4uYXJnczogUGFyYW1ldGVyczx0eXBlb2Ygb3JpZ2luYWxNZXRob2Q+XG5cdCk6IFRSZXR1cm4ge1xuXHRcdC8vIGdldCBvciBjcmVhdGUgYSByZWNvcmQgZm9yIHRoZSBjdXJyZW50IG9iamVjdCBpbnN0YW5jZVxuXHRcdC8vIHRoZSBjcmVhdGlvbiBpcyBkb25lIG9uY2UgcGVyIGVhY2ggb2JqZWN0IGluc3RhbmNlXG5cdFx0bGV0IHJlY29yZCA9IG9iamVjdFJlY29yZHMuZ2V0KHRoaXMpO1xuXHRcdGlmICghcmVjb3JkKSB7XG5cdFx0XHRyZWNvcmQgPSBuZXcgRGlzcG9zYWJsZU1hcCgpO1xuXHRcdFx0b2JqZWN0UmVjb3Jkcy5zZXQodGhpcywgcmVjb3JkKTtcblxuXHRcdFx0dGhpcy5fcmVnaXN0ZXIoe1xuXHRcdFx0XHRkaXNwb3NlOiAoKSA9PiB7XG5cdFx0XHRcdFx0b2JqZWN0UmVjb3Jkcy5nZXQodGhpcyk/LmRpc3Bvc2UoKTtcblx0XHRcdFx0XHRvYmplY3RSZWNvcmRzLmRlbGV0ZSh0aGlzKTtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIHdoZW4gdGhlIGRlY29yYXRlZCBtZXRob2QgaXMgY2FsbGVkIGFnYWluIGFuZCB0aGVyZSBpcyBhIGNhbmNlbGxhdGlvbiB0b2tlblxuXHRcdC8vIHNvdXJjZSBleGlzdHMgZnJvbSBhIHByZXZpb3VzIGNhbGwsIGNhbmNlbCBhbmQgZGlzcG9zZSBpdCwgdGhlbiByZW1vdmUgaXRcblx0XHRyZWNvcmQuZ2V0KG1ldGhvZE5hbWUpPy5kaXNwb3NlKHRydWUpO1xuXG5cdFx0Ly8gbm93IHdlIG5lZWQgdG8gcHJvdmlkZSBhIGNhbmNlbGxhdGlvbiB0b2tlbiB0byB0aGUgb3JpZ2luYWwgbWV0aG9kXG5cdFx0Ly8gYXMgdGhlIGxhc3QgYXJndW1lbnQsIHRoZXJlIGFyZSB0d28gY2FzZXMgdG8gY29uc2lkZXI6XG5cdFx0Ly8gXHQtIChjb21tb24gY2FzZSkgdGhlIGFyZ3VtZW50cyBsaXN0IGRvZXMgbm90IGhhdmUgYSBjYW5jZWxsYXRpb24gdG9rZW5cblx0XHQvLyBcdCAgIGFzIHRoZSBsYXN0IGFyZ3VtZW50LCAtIGluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGFkZCBhIG5ldyBvbmVcblx0XHQvLyAgLSAocG9zc2libGUgY2FzZSkgLSB0aGUgYXJndW1lbnRzIGxpc3QgYWxyZWFkeSBoYXMgYSBjYW5jZWxsYXRpb24gdG9rZW5cblx0XHQvLyAgICBhcyB0aGUgbGFzdCBhcmd1bWVudCwgLSBpbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byByZXVzZSB0aGUgdG9rZW4gd2hlblxuXHRcdC8vICAgIHdlIGNyZWF0ZSBvdXJzLCBhbmQgcmVwbGFjZSB0aGUgb2xkIHRva2VuIHdpdGggdGhlIG5ldyBvbmVcblx0XHQvLyB0aGVyZWZvcmUsXG5cblx0XHQvLyBnZXQgdGhlIGxhc3QgYXJndW1lbnQgb2YgdGhlIGFyZ3VtZW50cyBsaXN0IGFuZCBpZiBpdCBpcyBwcmVzZW50LFxuXHRcdC8vIHJldXNlIGl0IGFzIHRoZSB0b2tlbiBmb3IgdGhlIG5ldyBjYW5jZWxsYXRpb24gdG9rZW4gc291cmNlXG5cdFx0Y29uc3QgbGFzdEFyZ3VtZW50ID0gKGFyZ3MubGVuZ3RoID4gMClcblx0XHRcdD8gYXJnc1thcmdzLmxlbmd0aCAtIDFdXG5cdFx0XHQ6IHVuZGVmaW5lZDtcblx0XHRjb25zdCB0b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLmlzQ2FuY2VsbGF0aW9uVG9rZW4obGFzdEFyZ3VtZW50KVxuXHRcdFx0PyBsYXN0QXJndW1lbnRcblx0XHRcdDogdW5kZWZpbmVkO1xuXG5cdFx0Y29uc3QgY2FuY2VsbGF0aW9uU291cmNlID0gbmV3IENhbmNlbGxhdGlvblRva2VuU291cmNlKHRva2VuKTtcblx0XHRyZWNvcmQuc2V0KG1ldGhvZE5hbWUsIGNhbmNlbGxhdGlvblNvdXJjZSk7XG5cblx0XHQvLyB0aGVuIHVwZGF0ZSBvciBhZGQgY2FuY2VsbGF0aW9uIHRva2VuIGF0IHRoZSBlbmQgb2YgdGhlIGFyZ3VtZW50cyBsaXN0XG5cdFx0aWYgKENhbmNlbGxhdGlvblRva2VuLmlzQ2FuY2VsbGF0aW9uVG9rZW4obGFzdEFyZ3VtZW50KSkge1xuXHRcdFx0YXJnc1thcmdzLmxlbmd0aCAtIDFdID0gY2FuY2VsbGF0aW9uU291cmNlLnRva2VuO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmdzLnB1c2goY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcblx0XHR9XG5cblx0XHQvLyBmaW5hbGx5IGludm9rZSB0aGUgb3JpZ2luYWwgbWV0aG9kIHBhc3Npbmcgb3JpZ2luYWwgYXJndW1lbnRzIGFuZFxuXHRcdC8vIHRoZSBuZXcgY2FuY2VsbGF0aW9uIHRva2VuIGF0IHRoZSBlbmQgb2YgdGhlIGFyZ3VtZW50cyBsaXN0XG5cdFx0cmV0dXJuIG9yaWdpbmFsTWV0aG9kLmNhbGwodGhpcywgLi4uYXJncyk7XG5cdH07XG5cblx0cmV0dXJuIGRlc2NyaXB0b3I7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
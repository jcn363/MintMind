bc71419e947822f0d92c910e2ec0b92f
/* istanbul ignore next */
function cov_2dfrexkush() {
  var path = "/home/user/Desktop/MintMind/src/vs/platform/utilityProcess/common/utilityProcessWorkerService.ts";
  var hash = "d846e5fa5272c25d530b495fe844ca2323a96a7c";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/user/Desktop/MintMind/src/vs/platform/utilityProcess/common/utilityProcessWorkerService.ts",
    statementMap: {
      "0": {
        start: {
          line: 5,
          column: 50
        },
        end: {
          line: 5,
          column: 72
        }
      }
    },
    fnMap: {},
    branchMap: {},
    s: {
      "0": 0
    },
    f: {},
    b: {},
    inputSourceMap: {
      file: "/home/user/Desktop/MintMind/src/vs/platform/utilityProcess/common/utilityProcessWorkerService.ts",
      mappings: "AAAA;;;gGAGgG;AAyEhG,MAAM,CAAC,MAAM,kCAAkC,GAAG,sBAAsB,CAAC",
      names: [],
      sources: ["/home/user/Desktop/MintMind/src/vs/platform/utilityProcess/common/utilityProcessWorkerService.ts"],
      sourcesContent: ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IUtilityProcessWorkerProcess {\n\n\t/**\n\t * The module to load as child process into the worker.\n\t */\n\treadonly moduleId: string;\n\n\t/**\n\t * The type of the process appears in the arguments of the\n\t * forked process to identify it easier.\n\t */\n\treadonly type: string;\n\n\t/**\n\t * A human-readable name for the utility process.\n\t */\n\treadonly name: string;\n}\n\nexport interface IOnDidTerminateUtilityrocessWorkerProcess {\n\n\t/**\n\t * More information around how the utility process worker\n\t * process terminated. Will be `undefined` in case the\n\t * worker process was terminated normally via APIs\n\t * and will be defined in case the worker process\n\t * terminated on its own, either unexpectedly or\n\t * because it finished.\n\t */\n\treadonly reason: IUtilityProcessWorkerProcessExit;\n}\n\nexport interface IUtilityProcessWorkerProcessExit {\n\n\t/**\n\t * The utility process worker process exit code if known.\n\t */\n\treadonly code?: number;\n\n\t/**\n\t * The utility process worker process exit signal if known.\n\t */\n\treadonly signal?: string;\n}\n\nexport interface IUtilityProcessWorkerConfiguration {\n\n\t/**\n\t * Configuration specific to the process to fork.\n\t */\n\treadonly process: IUtilityProcessWorkerProcess;\n\n\t/**\n\t * Configuration specific for how to respond with the\n\t * communication message port to the receiver window.\n\t */\n\treadonly reply: {\n\t\treadonly windowId: number;\n\t\treadonly channel?: string;\n\t\treadonly nonce?: string;\n\t};\n}\n\nexport interface IUtilityProcessWorkerCreateConfiguration extends IUtilityProcessWorkerConfiguration {\n\treadonly reply: {\n\t\treadonly windowId: number;\n\t\treadonly channel: string;\n\t\treadonly nonce: string;\n\t};\n}\n\nexport const ipcUtilityProcessWorkerChannelName = 'utilityProcessWorker';\n\nexport interface IUtilityProcessWorkerService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Will fork a new process with the provided module identifier in a utility\n\t * process and establishes a message port connection to that process. The other\n\t * end of the message port connection will be sent back to the calling window\n\t * as identified by the `reply` configuration.\n\t *\n\t * Requires the forked process to be ES module that uses our IPC channel framework\n\t * to respond to the provided `channelName` as a server.\n\t *\n\t * The process will be automatically terminated when the receiver window closes,\n\t * crashes or loads/reloads. It can also explicitly be terminated by calling\n\t * `disposeWorker`.\n\t *\n\t * Note on affinity: repeated calls to `createWorker` with the same `moduleId` from\n\t * the same window will result in any previous forked process to get terminated.\n\t * In other words, it is not possible, nor intended to create multiple workers of\n\t * the same process from one window. The intent of these workers is to be reused per\n\t * window and the communication channel allows to dynamically update the processes\n\t * after the fact.\n\t *\n\t * @returns a promise that resolves then the worker terminated. Provides more details\n\t * about the termination that can be used to figure out if the termination was unexpected\n\t * or not and whether the worker needs to be restarted.\n\t */\n\tcreateWorker(configuration: IUtilityProcessWorkerCreateConfiguration): Promise<IOnDidTerminateUtilityrocessWorkerProcess>;\n\n\t/**\n\t * Terminates the process for the provided configuration if any.\n\t */\n\tdisposeWorker(configuration: IUtilityProcessWorkerConfiguration): Promise<void>;\n}\n"],
      version: 3
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "d846e5fa5272c25d530b495fe844ca2323a96a7c"
  };
  var coverage = global[gcv] || (global[gcv] = {});
  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }
  var actualCoverage = coverage[path];
  {
    // @ts-ignore
    cov_2dfrexkush = function () {
      return actualCoverage;
    };
  }
  return actualCoverage;
}
cov_2dfrexkush();
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
export const ipcUtilityProcessWorkerChannelName =
/* istanbul ignore next */
(cov_2dfrexkush().s[0]++, 'utilityProcessWorker');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpcGNVdGlsaXR5UHJvY2Vzc1dvcmtlckNoYW5uZWxOYW1lIiwiY292XzJkZnJleGt1c2giLCJzIl0sInNvdXJjZXMiOlsiL2hvbWUvdXNlci9EZXNrdG9wL01pbnRNaW5kL3NyYy92cy9wbGF0Zm9ybS91dGlsaXR5UHJvY2Vzcy9jb21tb24vdXRpbGl0eVByb2Nlc3NXb3JrZXJTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgaW50ZXJmYWNlIElVdGlsaXR5UHJvY2Vzc1dvcmtlclByb2Nlc3Mge1xuXG5cdC8qKlxuXHQgKiBUaGUgbW9kdWxlIHRvIGxvYWQgYXMgY2hpbGQgcHJvY2VzcyBpbnRvIHRoZSB3b3JrZXIuXG5cdCAqL1xuXHRyZWFkb25seSBtb2R1bGVJZDogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBUaGUgdHlwZSBvZiB0aGUgcHJvY2VzcyBhcHBlYXJzIGluIHRoZSBhcmd1bWVudHMgb2YgdGhlXG5cdCAqIGZvcmtlZCBwcm9jZXNzIHRvIGlkZW50aWZ5IGl0IGVhc2llci5cblx0ICovXG5cdHJlYWRvbmx5IHR5cGU6IHN0cmluZztcblxuXHQvKipcblx0ICogQSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGUgdXRpbGl0eSBwcm9jZXNzLlxuXHQgKi9cblx0cmVhZG9ubHkgbmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElPbkRpZFRlcm1pbmF0ZVV0aWxpdHlyb2Nlc3NXb3JrZXJQcm9jZXNzIHtcblxuXHQvKipcblx0ICogTW9yZSBpbmZvcm1hdGlvbiBhcm91bmQgaG93IHRoZSB1dGlsaXR5IHByb2Nlc3Mgd29ya2VyXG5cdCAqIHByb2Nlc3MgdGVybWluYXRlZC4gV2lsbCBiZSBgdW5kZWZpbmVkYCBpbiBjYXNlIHRoZVxuXHQgKiB3b3JrZXIgcHJvY2VzcyB3YXMgdGVybWluYXRlZCBub3JtYWxseSB2aWEgQVBJc1xuXHQgKiBhbmQgd2lsbCBiZSBkZWZpbmVkIGluIGNhc2UgdGhlIHdvcmtlciBwcm9jZXNzXG5cdCAqIHRlcm1pbmF0ZWQgb24gaXRzIG93biwgZWl0aGVyIHVuZXhwZWN0ZWRseSBvclxuXHQgKiBiZWNhdXNlIGl0IGZpbmlzaGVkLlxuXHQgKi9cblx0cmVhZG9ubHkgcmVhc29uOiBJVXRpbGl0eVByb2Nlc3NXb3JrZXJQcm9jZXNzRXhpdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVXRpbGl0eVByb2Nlc3NXb3JrZXJQcm9jZXNzRXhpdCB7XG5cblx0LyoqXG5cdCAqIFRoZSB1dGlsaXR5IHByb2Nlc3Mgd29ya2VyIHByb2Nlc3MgZXhpdCBjb2RlIGlmIGtub3duLlxuXHQgKi9cblx0cmVhZG9ubHkgY29kZT86IG51bWJlcjtcblxuXHQvKipcblx0ICogVGhlIHV0aWxpdHkgcHJvY2VzcyB3b3JrZXIgcHJvY2VzcyBleGl0IHNpZ25hbCBpZiBrbm93bi5cblx0ICovXG5cdHJlYWRvbmx5IHNpZ25hbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVXRpbGl0eVByb2Nlc3NXb3JrZXJDb25maWd1cmF0aW9uIHtcblxuXHQvKipcblx0ICogQ29uZmlndXJhdGlvbiBzcGVjaWZpYyB0byB0aGUgcHJvY2VzcyB0byBmb3JrLlxuXHQgKi9cblx0cmVhZG9ubHkgcHJvY2VzczogSVV0aWxpdHlQcm9jZXNzV29ya2VyUHJvY2VzcztcblxuXHQvKipcblx0ICogQ29uZmlndXJhdGlvbiBzcGVjaWZpYyBmb3IgaG93IHRvIHJlc3BvbmQgd2l0aCB0aGVcblx0ICogY29tbXVuaWNhdGlvbiBtZXNzYWdlIHBvcnQgdG8gdGhlIHJlY2VpdmVyIHdpbmRvdy5cblx0ICovXG5cdHJlYWRvbmx5IHJlcGx5OiB7XG5cdFx0cmVhZG9ubHkgd2luZG93SWQ6IG51bWJlcjtcblx0XHRyZWFkb25seSBjaGFubmVsPzogc3RyaW5nO1xuXHRcdHJlYWRvbmx5IG5vbmNlPzogc3RyaW5nO1xuXHR9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElVdGlsaXR5UHJvY2Vzc1dvcmtlckNyZWF0ZUNvbmZpZ3VyYXRpb24gZXh0ZW5kcyBJVXRpbGl0eVByb2Nlc3NXb3JrZXJDb25maWd1cmF0aW9uIHtcblx0cmVhZG9ubHkgcmVwbHk6IHtcblx0XHRyZWFkb25seSB3aW5kb3dJZDogbnVtYmVyO1xuXHRcdHJlYWRvbmx5IGNoYW5uZWw6IHN0cmluZztcblx0XHRyZWFkb25seSBub25jZTogc3RyaW5nO1xuXHR9O1xufVxuXG5leHBvcnQgY29uc3QgaXBjVXRpbGl0eVByb2Nlc3NXb3JrZXJDaGFubmVsTmFtZSA9ICd1dGlsaXR5UHJvY2Vzc1dvcmtlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVV0aWxpdHlQcm9jZXNzV29ya2VyU2VydmljZSB7XG5cblx0cmVhZG9ubHkgX3NlcnZpY2VCcmFuZDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBXaWxsIGZvcmsgYSBuZXcgcHJvY2VzcyB3aXRoIHRoZSBwcm92aWRlZCBtb2R1bGUgaWRlbnRpZmllciBpbiBhIHV0aWxpdHlcblx0ICogcHJvY2VzcyBhbmQgZXN0YWJsaXNoZXMgYSBtZXNzYWdlIHBvcnQgY29ubmVjdGlvbiB0byB0aGF0IHByb2Nlc3MuIFRoZSBvdGhlclxuXHQgKiBlbmQgb2YgdGhlIG1lc3NhZ2UgcG9ydCBjb25uZWN0aW9uIHdpbGwgYmUgc2VudCBiYWNrIHRvIHRoZSBjYWxsaW5nIHdpbmRvd1xuXHQgKiBhcyBpZGVudGlmaWVkIGJ5IHRoZSBgcmVwbHlgIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIFJlcXVpcmVzIHRoZSBmb3JrZWQgcHJvY2VzcyB0byBiZSBFUyBtb2R1bGUgdGhhdCB1c2VzIG91ciBJUEMgY2hhbm5lbCBmcmFtZXdvcmtcblx0ICogdG8gcmVzcG9uZCB0byB0aGUgcHJvdmlkZWQgYGNoYW5uZWxOYW1lYCBhcyBhIHNlcnZlci5cblx0ICpcblx0ICogVGhlIHByb2Nlc3Mgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHRlcm1pbmF0ZWQgd2hlbiB0aGUgcmVjZWl2ZXIgd2luZG93IGNsb3Nlcyxcblx0ICogY3Jhc2hlcyBvciBsb2Fkcy9yZWxvYWRzLiBJdCBjYW4gYWxzbyBleHBsaWNpdGx5IGJlIHRlcm1pbmF0ZWQgYnkgY2FsbGluZ1xuXHQgKiBgZGlzcG9zZVdvcmtlcmAuXG5cdCAqXG5cdCAqIE5vdGUgb24gYWZmaW5pdHk6IHJlcGVhdGVkIGNhbGxzIHRvIGBjcmVhdGVXb3JrZXJgIHdpdGggdGhlIHNhbWUgYG1vZHVsZUlkYCBmcm9tXG5cdCAqIHRoZSBzYW1lIHdpbmRvdyB3aWxsIHJlc3VsdCBpbiBhbnkgcHJldmlvdXMgZm9ya2VkIHByb2Nlc3MgdG8gZ2V0IHRlcm1pbmF0ZWQuXG5cdCAqIEluIG90aGVyIHdvcmRzLCBpdCBpcyBub3QgcG9zc2libGUsIG5vciBpbnRlbmRlZCB0byBjcmVhdGUgbXVsdGlwbGUgd29ya2VycyBvZlxuXHQgKiB0aGUgc2FtZSBwcm9jZXNzIGZyb20gb25lIHdpbmRvdy4gVGhlIGludGVudCBvZiB0aGVzZSB3b3JrZXJzIGlzIHRvIGJlIHJldXNlZCBwZXJcblx0ICogd2luZG93IGFuZCB0aGUgY29tbXVuaWNhdGlvbiBjaGFubmVsIGFsbG93cyB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhlIHByb2Nlc3Nlc1xuXHQgKiBhZnRlciB0aGUgZmFjdC5cblx0ICpcblx0ICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlbiB0aGUgd29ya2VyIHRlcm1pbmF0ZWQuIFByb3ZpZGVzIG1vcmUgZGV0YWlsc1xuXHQgKiBhYm91dCB0aGUgdGVybWluYXRpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBmaWd1cmUgb3V0IGlmIHRoZSB0ZXJtaW5hdGlvbiB3YXMgdW5leHBlY3RlZFxuXHQgKiBvciBub3QgYW5kIHdoZXRoZXIgdGhlIHdvcmtlciBuZWVkcyB0byBiZSByZXN0YXJ0ZWQuXG5cdCAqL1xuXHRjcmVhdGVXb3JrZXIoY29uZmlndXJhdGlvbjogSVV0aWxpdHlQcm9jZXNzV29ya2VyQ3JlYXRlQ29uZmlndXJhdGlvbik6IFByb21pc2U8SU9uRGlkVGVybWluYXRlVXRpbGl0eXJvY2Vzc1dvcmtlclByb2Nlc3M+O1xuXG5cdC8qKlxuXHQgKiBUZXJtaW5hdGVzIHRoZSBwcm9jZXNzIGZvciB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbiBpZiBhbnkuXG5cdCAqL1xuXHRkaXNwb3NlV29ya2VyKGNvbmZpZ3VyYXRpb246IElVdGlsaXR5UHJvY2Vzc1dvcmtlckNvbmZpZ3VyYXRpb24pOiBQcm9taXNlPHZvaWQ+O1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUE0RUEsT0FBTyxNQUFNQSxrQ0FBa0M7QUFBQTtBQUFBLENBQUFDLGNBQUEsR0FBQUMsQ0FBQSxPQUFHLHNCQUFzQiIsImlnbm9yZUxpc3QiOltdfQ==
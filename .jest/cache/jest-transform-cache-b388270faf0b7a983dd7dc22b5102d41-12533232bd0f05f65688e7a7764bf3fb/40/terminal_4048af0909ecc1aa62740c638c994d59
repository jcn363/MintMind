5985ce0eceda77b47dad6cf258accbcf
/* istanbul ignore next */
function cov_2gh0w04gn0() {
  var path = "/home/user/Desktop/MintMind/src/vs/workbench/contrib/terminal/browser/terminal.ts";
  var hash = "807673b7a62ed529e510f5ee1714494acafa37e1";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/user/Desktop/MintMind/src/vs/workbench/contrib/terminal/browser/terminal.ts",
    statementMap: {
      "0": {
        start: {
          line: 6,
          column: 32
        },
        end: {
          line: 6,
          column: 66
        }
      },
      "1": {
        start: {
          line: 7,
          column: 45
        },
        end: {
          line: 7,
          column: 92
        }
      },
      "2": {
        start: {
          line: 8,
          column: 38
        },
        end: {
          line: 8,
          column: 78
        }
      },
      "3": {
        start: {
          line: 9,
          column: 39
        },
        end: {
          line: 9,
          column: 80
        }
      },
      "4": {
        start: {
          line: 10,
          column: 37
        },
        end: {
          line: 10,
          column: 76
        }
      },
      "5": {
        start: {
          line: 11,
          column: 40
        },
        end: {
          line: 11,
          column: 82
        }
      },
      "6": {
        start: {
          line: 12,
          column: 36
        },
        end: {
          line: 12,
          column: 74
        }
      },
      "7": {
        start: {
          line: 13,
          column: 42
        },
        end: {
          line: 13,
          column: 81
        }
      },
      "8": {
        start: {
          line: 13,
          column: 49
        },
        end: {
          line: 13,
          column: 81
        }
      },
      "9": {
        start: {
          line: 16,
          column: 32
        },
        end: {
          line: 16,
          column: 48
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 13,
            column: 42
          },
          end: {
            line: 13,
            column: 43
          }
        },
        loc: {
          start: {
            line: 13,
            column: 49
          },
          end: {
            line: 13,
            column: 81
          }
        },
        line: 13
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0
    },
    f: {
      "0": 0
    },
    b: {},
    inputSourceMap: {
      file: "/home/user/Desktop/MintMind/src/vs/workbench/contrib/terminal/browser/terminal.ts",
      mappings: "AAAA;;;gGAGgG;AAShG,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AA0B7F,MAAM,CAAC,MAAM,gBAAgB,GAAG,eAAe,CAAmB,iBAAiB,CAAC,CAAC;AACrF,MAAM,CAAC,MAAM,6BAA6B,GAAG,eAAe,CAAgC,8BAA8B,CAAC,CAAC;AAC5H,MAAM,CAAC,MAAM,sBAAsB,GAAG,eAAe,CAAyB,uBAAuB,CAAC,CAAC;AACvG,MAAM,CAAC,MAAM,uBAAuB,GAAG,eAAe,CAA0B,wBAAwB,CAAC,CAAC;AAC1G,MAAM,CAAC,MAAM,qBAAqB,GAAG,eAAe,CAAwB,sBAAsB,CAAC,CAAC;AACpG,MAAM,CAAC,MAAM,wBAAwB,GAAG,eAAe,CAA2B,yBAAyB,CAAC,CAAC;AAC7G,MAAM,CAAC,MAAM,oBAAoB,GAAG,eAAe,CAAuB,qBAAqB,CAAC,CAAC;AAgTjG,MAAM,CAAC,MAAM,0BAA0B,GAAG,CAAC,CAAgD,EAAkC,EAAE,CAAC,OAAQ,CAAuB,CAAC,UAAU,KAAK,QAAQ,CAAC;AA6JxL,MAAM,OAAO,0BAA2B,SAAQ,UAAU;CAEzD;AAwBD,MAAM,CAAC,MAAM,gBAAgB,GAAG,gBAAgB,CAAC",
      names: [],
      sources: ["/home/user/Desktop/MintMind/src/vs/workbench/contrib/terminal/browser/terminal.ts"],
      sourcesContent: ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDimension } from '../../../../base/browser/dom.js';\nimport { Orientation } from '../../../../base/browser/ui/splitview/splitview.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { Event, IDynamicListEventMultiplexer, type DynamicListEventMultiplexer } from '../../../../base/common/event.js';\nimport { DisposableStore, IDisposable, type IReference } from '../../../../base/common/lifecycle.js';\nimport { OperatingSystem } from '../../../../base/common/platform.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IKeyMods } from '../../../../platform/quickinput/common/quickInput.js';\nimport { IMarkProperties, ITerminalCapabilityImplMap, ITerminalCapabilityStore, ITerminalCommand, TerminalCapability } from '../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { IMergedEnvironmentVariableCollection } from '../../../../platform/terminal/common/environmentVariable.js';\nimport { IExtensionTerminalProfile, IReconnectionProperties, IShellIntegration, IShellLaunchConfig, ITerminalBackend, ITerminalDimensions, ITerminalLaunchError, ITerminalProfile, ITerminalTabLayoutInfoById, TerminalExitReason, TerminalIcon, TerminalLocation, TerminalShellType, TerminalType, TitleEventSource, WaitOnExitValue, type IDecorationAddon, type ShellIntegrationInjectionFailureReason } from '../../../../platform/terminal/common/terminal.js';\nimport { IColorTheme } from '../../../../platform/theme/common/themeService.js';\nimport { IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditableData } from '../../../common/views.js';\nimport { ITerminalStatusList } from './terminalStatusList.js';\nimport { XtermTerminal } from './xterm/xtermTerminal.js';\nimport { IRegisterContributedProfileArgs, IRemoteTerminalAttachTarget, IStartExtensionTerminalRequest, ITerminalConfiguration, ITerminalFont, ITerminalProcessExtHostProxy, ITerminalProcessInfo } from '../common/terminal.js';\nimport type { IMarker, ITheme, Terminal as RawXtermTerminal, IBufferRange, IMarker as IXtermMarker } from '@xterm/xterm';\nimport { ScrollPosition } from './xterm/markNavigationAddon.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { GroupIdentifier } from '../../../common/editor.js';\nimport { ACTIVE_GROUP_TYPE, AUX_WINDOW_GROUP_TYPE, SIDE_GROUP_TYPE } from '../../../services/editor/common/editorService.js';\nimport type { ICurrentPartialCommand } from '../../../../platform/terminal/common/capabilities/commandDetection/terminalCommand.js';\nimport type { IXtermCore } from './xterm-private.js';\nimport type { IMenu } from '../../../../platform/actions/common/actions.js';\nimport type { IProgressState } from '@xterm/addon-progress';\nimport type { IEditorOptions } from '../../../../platform/editor/common/editor.js';\nimport type { TerminalEditorInput } from './terminalEditorInput.js';\nimport type { MaybePromise } from '../../../../base/common/async.js';\nimport type { SingleOrMany } from '../../../../base/common/types.js';\n\nexport const ITerminalService = createDecorator<ITerminalService>('terminalService');\nexport const ITerminalConfigurationService = createDecorator<ITerminalConfigurationService>('terminalConfigurationService');\nexport const ITerminalEditorService = createDecorator<ITerminalEditorService>('terminalEditorService');\nexport const ITerminalEditingService = createDecorator<ITerminalEditingService>('terminalEditingService');\nexport const ITerminalGroupService = createDecorator<ITerminalGroupService>('terminalGroupService');\nexport const ITerminalInstanceService = createDecorator<ITerminalInstanceService>('terminalInstanceService');\nexport const ITerminalChatService = createDecorator<ITerminalChatService>('terminalChatService');\n\n/**\n * A terminal contribution that gets created whenever a terminal is created. A contribution has\n * access to the process manager through the constructor and provides a method for when xterm.js has\n * been initialized.\n */\nexport interface ITerminalContribution extends IDisposable {\n\tlayout?(xterm: IXtermTerminal & { raw: RawXtermTerminal }, dimension: IDimension): void;\n\txtermOpen?(xterm: IXtermTerminal & { raw: RawXtermTerminal }): void;\n\txtermReady?(xterm: IXtermTerminal & { raw: RawXtermTerminal }): void;\n\n\thandleMouseEvent?(event: MouseEvent): MaybePromise<{ handled: boolean } | void>;\n}\n\n/**\n * A service used to create instances or fetch backends, this services allows services that\n * ITerminalService depends on to also create instances.\n *\n * **This service is intended to only be used within the terminal contrib.**\n */\nexport interface ITerminalInstanceService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event that's fired when a terminal instance is created.\n\t */\n\treadonly onDidCreateInstance: Event<ITerminalInstance>;\n\n\t/**\n\t * An event that's fired when a new backend is registered.\n\t */\n\treadonly onDidRegisterBackend: Event<ITerminalBackend>;\n\n\t/**\n\t * Helper function to convert a shell launch config, a profile or undefined into its equivalent\n\t * shell launch config.\n\t * @param shellLaunchConfigOrProfile A shell launch config, a profile or undefined\n\t * @param cwd A cwd to override.\n\t */\n\tconvertProfileToShellLaunchConfig(shellLaunchConfigOrProfile?: IShellLaunchConfig | ITerminalProfile, cwd?: string | URI): IShellLaunchConfig;\n\n\t/**\n\t * Create a new terminal instance.\n\t * @param launchConfig The shell launch config.\n\t * @param target The target of the terminal.\n\t */\n\tcreateInstance(launchConfig: IShellLaunchConfig, target: TerminalLocation, editorOptions?: TerminalEditorLocation): ITerminalInstance;\n\n\t/**\n\t * Gets the registered backend for a remote authority (undefined = local). This is a convenience\n\t * method to avoid using the more verbose fetching from the registry.\n\t * @param remoteAuthority The remote authority of the backend.\n\t */\n\tgetBackend(remoteAuthority?: string): Promise<ITerminalBackend | undefined>;\n\n\tgetRegisteredBackends(): IterableIterator<ITerminalBackend>;\n\tdidRegisterBackend(backend: ITerminalBackend): void;\n}\n\n/**\n * Service enabling communication between the chat tool implementation in terminal contrib and workbench contribs.\n * Acts as a communication mechanism for chat-related terminal features.\n */\nexport interface ITerminalChatService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fired when a terminal instance is registered for a tool session id. This can happen after\n\t * the chat UI first renders, enabling late binding of the focus action.\n\t */\n\treadonly onDidRegisterTerminalInstanceWithToolSession: Event<ITerminalInstance>;\n\n\t/**\n\t * Associate a tool session id with a terminal instance. The association is automatically\n\t * cleared when the instance is disposed.\n\t */\n\tregisterTerminalInstanceWithToolSession(terminalToolSessionId: string | undefined, instance: ITerminalInstance): void;\n\n\t/**\n\t * Resolve a terminal instance by its tool session id.\n\t * @param terminalToolSessionId The tool session id provided in toolSpecificData.\n\t * If no tool session ID is provided, we do nothing.\n\t */\n\tgetTerminalInstanceByToolSessionId(terminalToolSessionId: string): Promise<ITerminalInstance | undefined>;\n\n\t/**\n\t * Returns the list of terminal instances that have been registered with a tool session id.\n\t * This is used for surfacing tool-driven/background terminals in UI (eg. quick picks).\n\t */\n\tgetToolSessionTerminalInstances(hiddenOnly?: boolean): readonly ITerminalInstance[];\n\n\t/**\n\t * Returns the tool session ID for a given terminal instance, if it has been registered.\n\t * @param instance The terminal instance to look up\n\t * @returns The tool session ID if found, undefined otherwise\n\t */\n\tgetToolSessionIdForInstance(instance: ITerminalInstance): string | undefined;\n\n\t/**\n\t * Associate a chat session ID with a terminal instance. This is used to retrieve the chat\n\t * session title for display purposes.\n\t * @param chatSessionId The chat session ID\n\t * @param instance The terminal instance\n\t */\n\tregisterTerminalInstanceWithChatSession(chatSessionId: string, instance: ITerminalInstance): void;\n\n\t/**\n\t * Returns the chat session ID for a given terminal instance, if it has been registered.\n\t * @param instance The terminal instance to look up\n\t * @returns The chat session ID if found, undefined otherwise\n\t */\n\tgetChatSessionIdForInstance(instance: ITerminalInstance): string | undefined;\n\n\tisBackgroundTerminal(terminalToolSessionId?: string): boolean;\n}\n\n/**\n * A service responsible for managing terminal editing state and functionality. This includes\n * tracking which terminal is currently being edited and managing editable data associated with\n * terminal instances.\n */\nexport interface ITerminalEditingService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Get the editable data for a terminal instance.\n\t * @param instance The terminal instance.\n\t * @returns The editable data if the instance is editable, undefined otherwise.\n\t */\n\tgetEditableData(instance: ITerminalInstance): IEditableData | undefined;\n\n\t/**\n\t * Set the editable data for a terminal instance.\n\t * @param instance The terminal instance.\n\t * @param data The editable data to set, or null to clear.\n\t */\n\tsetEditable(instance: ITerminalInstance, data: IEditableData | null): void;\n\n\t/**\n\t * Check if a terminal instance is currently editable.\n\t * @param instance The terminal instance to check.\n\t * @returns True if the instance is editable, false otherwise.\n\t */\n\tisEditable(instance: ITerminalInstance | undefined): boolean;\n\n\t/**\n\t * Get the terminal instance that is currently being edited.\n\t * @returns The terminal instance being edited, or undefined if none.\n\t */\n\tgetEditingTerminal(): ITerminalInstance | undefined;\n\n\t/**\n\t * Set the terminal instance that is currently being edited.\n\t * @param instance The terminal instance to set as editing, or undefined to clear.\n\t */\n\tsetEditingTerminal(instance: ITerminalInstance | undefined): void;\n}\n\nexport const enum Direction {\n\tLeft = 0,\n\tRight = 1,\n\tUp = 2,\n\tDown = 3\n}\n\nexport interface IQuickPickTerminalObject {\n\tconfig: IRegisterContributedProfileArgs | ITerminalProfile | { profile: IExtensionTerminalProfile; options: { icon?: string; color?: string } } | undefined;\n\tkeyMods: IKeyMods | undefined;\n}\n\nexport interface IMarkTracker {\n\tscrollToPreviousMark(scrollPosition?: ScrollPosition, retainSelection?: boolean, skipEmptyCommands?: boolean): void;\n\tscrollToNextMark(): void;\n\tselectToPreviousMark(): void;\n\tselectToNextMark(): void;\n\tselectToPreviousLine(): void;\n\tselectToNextLine(): void;\n\tclear(): void;\n\tscrollToClosestMarker(startMarkerId: string, endMarkerId?: string, highlight?: boolean | undefined): void;\n\n\tscrollToLine(line: number, position: ScrollPosition): void;\n\trevealCommand(command: ITerminalCommand | ICurrentPartialCommand | URI, position?: ScrollPosition): void;\n\trevealRange(range: IBufferRange): void;\n\tregisterTemporaryDecoration(marker: IMarker, endMarker: IMarker | undefined, showOutline: boolean): void;\n\tshowCommandGuide(command: ITerminalCommand | undefined): void;\n\n\tsaveScrollState(): void;\n\trestoreScrollState(): void;\n}\n\nexport interface ITerminalGroup {\n\tactiveInstance: ITerminalInstance | undefined;\n\tterminalInstances: ITerminalInstance[];\n\ttitle: string;\n\treadonly hadFocusOnExit: boolean;\n\n\treadonly onDidDisposeInstance: Event<ITerminalInstance>;\n\treadonly onDisposed: Event<ITerminalGroup>;\n\treadonly onInstancesChanged: Event<void>;\n\treadonly onPanelOrientationChanged: Event<Orientation>;\n\n\tfocusPreviousPane(): void;\n\tfocusNextPane(): void;\n\tresizePane(direction: Direction): void;\n\tresizePanes(relativeSizes: number[]): void;\n\tsetActiveInstanceByIndex(index: number, force?: boolean): void;\n\tattachToElement(element: HTMLElement): void;\n\taddInstance(instance: ITerminalInstance): void;\n\tremoveInstance(instance: ITerminalInstance): void;\n\tmoveInstance(instances: SingleOrMany<ITerminalInstance>, index: number, position: 'before' | 'after'): void;\n\tsetVisible(visible: boolean): void;\n\tlayout(width: number, height: number): void;\n\taddDisposable(disposable: IDisposable): void;\n\tsplit(shellLaunchConfig: IShellLaunchConfig): ITerminalInstance;\n\tgetLayoutInfo(isActive: boolean): ITerminalTabLayoutInfoById;\n}\n\nexport const enum TerminalConnectionState {\n\tConnecting,\n\tConnected\n}\n\nexport interface IDetachedXTermOptions {\n\tcols: number;\n\trows: number;\n\tcolorProvider: IXtermColorProvider;\n\tcapabilities?: ITerminalCapabilityStore;\n\treadonly?: boolean;\n\tprocessInfo: ITerminalProcessInfo;\n}\n\n/**\n * A generic interface implemented in both the {@link ITerminalInstance} (an\n * interface used for terminals attached to the terminal panel or editor) and\n * {@link IDetachedTerminalInstance} (a terminal used elsewhere in VS Code UI).\n */\nexport interface IBaseTerminalInstance {\n\treadonly capabilities: ITerminalCapabilityStore;\n\n\t/**\n\t * DOM element the terminal is mounted in.\n\t */\n\treadonly domElement?: HTMLElement;\n\n\t/**\n\t * Current selection in the terminal.\n\t */\n\treadonly selection: string | undefined;\n\n\t/**\n\t * Check if anything is selected in terminal.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Clear current selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Focuses the terminal instance if it's able to (the xterm.js instance must exist).\n\t *\n\t * @param force Force focus even if there is a selection.\n\t */\n\tfocus(force?: boolean): void;\n\n\t/**\n\t * Force the scroll bar to be visible until {@link resetScrollbarVisibility} is called.\n\t */\n\tforceScrollbarVisibility(): void;\n\n\t/**\n\t * Resets the scroll bar to only be visible when needed, this does nothing unless\n\t * {@link forceScrollbarVisibility} was called.\n\t */\n\tresetScrollbarVisibility(): void;\n\n\t/**\n\t * Gets a terminal contribution by its ID.\n\t */\n\tgetContribution<T extends ITerminalContribution>(id: string): T | null;\n}\n\n/**\n * A {@link ITerminalInstance}-like object that emulates a subset of\n * capabilities. This instance is returned from {@link ITerminalService.createDetachedTerminal}\n * to represent terminals that appear in other parts of the VS Code UI outside\n * of the \"Terminal\" view or editors.\n */\nexport interface IDetachedTerminalInstance extends IDisposable, IBaseTerminalInstance {\n\treadonly xterm: IDetachedXtermTerminal;\n\n\t/**\n\t * Attached the terminal to the given element. This should be preferred over\n\t * calling {@link IXtermTerminal.attachToElement} so that extra DOM elements\n\t * for contributions are initialized.\n\t *\n\t * @param container Container the terminal will be rendered in\n\t * @param options Additional options for mounting the terminal in an element\n\t */\n\tattachToElement(container: HTMLElement, options?: Partial<IXtermAttachToElementOptions>): void;\n}\n\nexport const isDetachedTerminalInstance = (t: ITerminalInstance | IDetachedTerminalInstance): t is IDetachedTerminalInstance => typeof (t as ITerminalInstance).instanceId !== 'number';\n\nexport interface ITerminalService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all terminal instances, including editor, terminal view (group), and background instances. */\n\treadonly instances: readonly ITerminalInstance[];\n\n\treadonly foregroundInstances: readonly ITerminalInstance[];\n\n\t/** Gets detached terminal instances created via {@link createDetachedXterm}. */\n\treadonly detachedInstances: Iterable<IDetachedTerminalInstance>;\n\n\treadonly isProcessSupportRegistered: boolean;\n\treadonly connectionState: TerminalConnectionState;\n\treadonly whenConnected: Promise<void>;\n\t/** The number of restored terminal groups on startup. */\n\treadonly restoredGroupCount: number;\n\n\treadonly onDidCreateInstance: Event<ITerminalInstance>;\n\treadonly onDidChangeInstanceDimensions: Event<ITerminalInstance>;\n\treadonly onDidRequestStartExtensionTerminal: Event<IStartExtensionTerminalRequest>;\n\treadonly onDidRegisterProcessSupport: Event<void>;\n\treadonly onDidChangeConnectionState: Event<void>;\n\n\t// Group events\n\treadonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;\n\n\t// Multiplexed events\n\treadonly onAnyInstanceData: Event<{ instance: ITerminalInstance; data: string }>;\n\treadonly onAnyInstanceDataInput: Event<ITerminalInstance>;\n\treadonly onAnyInstanceIconChange: Event<{ instance: ITerminalInstance; userInitiated: boolean }>;\n\treadonly onAnyInstanceMaximumDimensionsChange: Event<ITerminalInstance>;\n\treadonly onAnyInstancePrimaryStatusChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceProcessIdReady: Event<ITerminalInstance>;\n\treadonly onAnyInstanceSelectionChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceTitleChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceShellTypeChanged: Event<ITerminalInstance>;\n\treadonly onAnyInstanceAddedCapabilityType: Event<TerminalCapability>;\n\n\t/**\n\t * Creates a terminal.\n\t * @param options The options to create the terminal with, when not specified the default\n\t * profile will be used at the default target.\n\t */\n\tcreateTerminal(options?: ICreateTerminalOptions): Promise<ITerminalInstance>;\n\n\t/**\n\t * Creates and focuses a terminal.\n\t * @param options The options to create the terminal with, when not specified the default\n\t * profile will be used at the default target.\n\t */\n\tcreateAndFocusTerminal(options?: ICreateTerminalOptions): Promise<ITerminalInstance>;\n\n\t/**\n\t * Creates a detached xterm instance which is not attached to the DOM or\n\t * tracked as a terminal instance.\n\t * @params options The options to create the terminal with\n\t */\n\tcreateDetachedTerminal(options: IDetachedXTermOptions): Promise<IDetachedTerminalInstance>;\n\n\t/**\n\t * Creates a raw terminal instance, this should not be used outside of the terminal part.\n\t */\n\tgetInstanceFromId(terminalId: number): ITerminalInstance | undefined;\n\n\t/**\n\t * An owner of terminals might be created after reconnection has occurred,\n\t * so store them to be requested/adopted later\n\t * @deprecated Use {@link onDidReconnectToSession}\n\t */\n\tgetReconnectedTerminals(reconnectionOwner: string): ITerminalInstance[] | undefined;\n\n\tgetActiveOrCreateInstance(options?: { acceptsInput?: boolean }): Promise<ITerminalInstance>;\n\trevealTerminal(source: ITerminalInstance, preserveFocus?: boolean): Promise<void>;\n\t/**\n\t * @param instance\n\t * @param suppressSetActive Do not set the active instance when there is only one terminal\n\t * @param forceSaveState Used when the window is shutting down and we need to reveal and save hideFromUser terminals\n\t */\n\tshowBackgroundTerminal(instance: ITerminalInstance, suppressSetActive?: boolean): Promise<void>;\n\trevealActiveTerminal(preserveFocus?: boolean): Promise<void>;\n\tmoveToEditor(source: ITerminalInstance, group?: GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE | AUX_WINDOW_GROUP_TYPE): void;\n\tmoveIntoNewEditor(source: ITerminalInstance): void;\n\tmoveToTerminalView(source: ITerminalInstance | URI): Promise<void>;\n\tgetPrimaryBackend(): ITerminalBackend | undefined;\n\n\t/**\n\t * Fire the onActiveTabChanged event, this will trigger the terminal dropdown to be updated,\n\t * among other things.\n\t */\n\trefreshActiveGroup(): void;\n\n\tregisterProcessSupport(isSupported: boolean): void;\n\n\tshowProfileQuickPick(type: 'setDefault' | 'createInstance', cwd?: string | URI): Promise<ITerminalInstance | undefined>;\n\n\tsetContainers(panelContainer: HTMLElement, terminalContainer: HTMLElement): void;\n\n\trequestStartExtensionTerminal(proxy: ITerminalProcessExtHostProxy, cols: number, rows: number): Promise<ITerminalLaunchError | undefined>;\n\tisAttachedToTerminal(remoteTerm: IRemoteTerminalAttachTarget): boolean;\n\tsafeDisposeTerminal(instance: ITerminalInstance): Promise<void>;\n\n\tgetDefaultInstanceHost(): ITerminalInstanceHost;\n\tgetInstanceHost(target: ITerminalLocationOptions | undefined): Promise<ITerminalInstanceHost>;\n\n\tresolveLocation(location?: ITerminalLocationOptions): Promise<TerminalLocation | undefined>;\n\tsetNativeDelegate(nativeCalls: ITerminalServiceNativeDelegate): void;\n\n\t/**\n\t * Creates an instance event listener that listens to all instances, dynamically adding new\n\t * instances and removing old instances as needed.\n\t * @param getEvent Maps the instance to the event.\n\t */\n\tcreateOnInstanceEvent<T>(getEvent: (instance: ITerminalInstance) => Event<T>): DynamicListEventMultiplexer<ITerminalInstance, T>;\n\n\t/**\n\t * Creates a capability event listener that listens to capabilities on all instances,\n\t * dynamically adding and removing instances and capabilities as needed.\n\t * @param capabilityId The capability type to listen to an event on.\n\t * @param getEvent Maps the capability to the event.\n\t */\n\tcreateOnInstanceCapabilityEvent<T extends TerminalCapability, K>(capabilityId: T, getEvent: (capability: ITerminalCapabilityImplMap[T]) => Event<K>): IDynamicListEventMultiplexer<{ instance: ITerminalInstance; data: K }>;\n\n\t/**\n\t * Reveals the terminal and, if provided, scrolls to the command mark.\n\t * @param resource the terminal resource\n\t */\n\topenResource(resource: URI): void;\n}\n\n/**\n * A service that provides convenient access to the terminal configuration and derived values.\n */\nexport interface ITerminalConfigurationService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * A typed and partially validated representation of the terminal configuration.\n\t */\n\treadonly config: Readonly<ITerminalConfiguration>;\n\n\t/**\n\t * The default location for terminals.\n\t */\n\treadonly defaultLocation: TerminalLocation;\n\n\t/**\n\t * Fires when something within the terminal configuration changes.\n\t */\n\treadonly onConfigChanged: Event<void>;\n\n\tsetPanelContainer(panelContainer: HTMLElement): void;\n\tconfigFontIsMonospace(): boolean;\n\tgetFont(w: Window, xtermCore?: IXtermCore, excludeDimensions?: boolean): ITerminalFont;\n}\n\nexport class TerminalLinkQuickPickEvent extends MouseEvent {\n\n}\nexport interface ITerminalServiceNativeDelegate {\n\tgetWindowCount(): Promise<number>;\n}\n\n/**\n * This service is responsible for integrating with the editor service and managing terminal\n * editors.\n */\nexport interface ITerminalEditorService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all _terminal editor_ instances. */\n\treadonly instances: readonly ITerminalInstance[];\n\n\topenEditor(instance: ITerminalInstance, editorOptions?: TerminalEditorLocation): Promise<void>;\n\tdetachInstance(instance: ITerminalInstance): void;\n\tsplitInstance(instanceToSplit: ITerminalInstance, shellLaunchConfig?: IShellLaunchConfig): ITerminalInstance;\n\trevealActiveEditor(preserveFocus?: boolean): Promise<void>;\n\tresolveResource(instance: ITerminalInstance): URI;\n\treviveInput(deserializedInput: IDeserializedTerminalEditorInput): EditorInput;\n\tgetInputFromResource(resource: URI): TerminalEditorInput;\n}\n\nexport const terminalEditorId = 'terminalEditor';\n\ninterface ITerminalEditorInputObject {\n\treadonly id: number;\n\treadonly pid: number;\n\treadonly title: string;\n\treadonly titleSource: TitleEventSource;\n\treadonly cwd: string;\n\treadonly icon: TerminalIcon | undefined;\n\treadonly color: string | undefined;\n\treadonly hasChildProcesses?: boolean;\n\treadonly type?: TerminalType;\n\treadonly isFeatureTerminal?: boolean;\n\treadonly hideFromUser?: boolean;\n\treadonly reconnectionProperties?: IReconnectionProperties;\n\treadonly shellIntegrationNonce: string;\n}\n\nexport interface ISerializedTerminalEditorInput extends ITerminalEditorInputObject {\n}\n\nexport interface IDeserializedTerminalEditorInput extends ITerminalEditorInputObject {\n}\n\nexport type ITerminalLocationOptions = TerminalLocation | TerminalEditorLocation | { parentTerminal: MaybePromise<ITerminalInstance> } | { splitActiveTerminal: boolean };\n\nexport interface ICreateTerminalOptions {\n\t/**\n\t * The shell launch config or profile to launch with, when not specified the default terminal\n\t * profile will be used.\n\t */\n\tconfig?: IShellLaunchConfig | ITerminalProfile | IExtensionTerminalProfile;\n\t/**\n\t * The current working directory to start with, this will override IShellLaunchConfig.cwd if\n\t * specified.\n\t */\n\tcwd?: string | URI;\n\t/**\n\t * The terminal's resource, passed when the terminal has moved windows.\n\t */\n\tresource?: URI;\n\n\t/**\n\t * The terminal's location (editor or panel), it's terminal parent (split to the right), or editor group\n\t */\n\tlocation?: ITerminalLocationOptions;\n\n\t/**\n\t * This terminal will not wait for contributed profiles to resolve which means it will proceed\n\t * when the workbench is not yet loaded.\n\t */\n\tskipContributedProfileCheck?: boolean;\n}\n\nexport interface TerminalEditorLocation {\n\tviewColumn: GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE | AUX_WINDOW_GROUP_TYPE;\n\tpreserveFocus?: boolean;\n\tauxiliary?: IEditorOptions['auxiliary'];\n}\n\n/**\n * This service is responsible for managing terminal groups, that is the terminals that are hosted\n * within the terminal panel, not in an editor.\n */\nexport interface ITerminalGroupService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all _terminal view_ instances, ie. instances contained within terminal groups. */\n\treadonly instances: readonly ITerminalInstance[];\n\treadonly groups: readonly ITerminalGroup[];\n\tactiveGroup: ITerminalGroup | undefined;\n\treadonly activeGroupIndex: number;\n\t/**\n\t * Gets or sets the last accessed menu, this is used to select the instance(s) for menu actions.\n\t */\n\tlastAccessedMenu: 'inline-tab' | 'tab-list';\n\n\treadonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;\n\treadonly onDidDisposeGroup: Event<ITerminalGroup>;\n\t/** Fires when a group is created, disposed of, or shown (in the case of a background group). */\n\treadonly onDidChangeGroups: Event<void>;\n\t/** Fires when the panel has been shown and expanded, so has non-zero dimensions. */\n\treadonly onDidShow: Event<void>;\n\treadonly onDidChangePanelOrientation: Event<Orientation>;\n\n\tcreateGroup(shellLaunchConfig?: IShellLaunchConfig): ITerminalGroup;\n\tcreateGroup(instance?: ITerminalInstance): ITerminalGroup;\n\tgetGroupForInstance(instance: ITerminalInstance): ITerminalGroup | undefined;\n\n\t/**\n\t * Moves a terminal instance's group to the target instance group's position.\n\t * @param source The source instance to move.\n\t * @param target The target instance to move the source instance to.\n\t */\n\tmoveGroup(source: SingleOrMany<ITerminalInstance>, target: ITerminalInstance): void;\n\tmoveGroupToEnd(source: SingleOrMany<ITerminalInstance>): void;\n\n\tmoveInstance(source: ITerminalInstance, target: ITerminalInstance, side: 'before' | 'after'): void;\n\tunsplitInstance(instance: ITerminalInstance): void;\n\tjoinInstances(instances: ITerminalInstance[]): void;\n\tinstanceIsSplit(instance: ITerminalInstance): boolean;\n\n\tgetGroupLabels(): string[];\n\tsetActiveGroupByIndex(index: number): void;\n\tsetActiveGroupToNext(): void;\n\tsetActiveGroupToPrevious(): void;\n\n\tsetActiveInstanceByIndex(terminalIndex: number): void;\n\n\tsetContainer(container: HTMLElement): void;\n\n\tshowPanel(focus?: boolean): Promise<void>;\n\thidePanel(): void;\n\tfocusTabs(): void;\n\tfocusHover(): void;\n\tupdateVisibility(): void;\n}\n\n/**\n * An interface that indicates the implementer hosts terminal instances, exposing a common set of\n * properties and events.\n */\nexport interface ITerminalInstanceHost {\n\treadonly activeInstance: ITerminalInstance | undefined;\n\treadonly instances: readonly ITerminalInstance[];\n\n\treadonly onDidDisposeInstance: Event<ITerminalInstance>;\n\treadonly onDidFocusInstance: Event<ITerminalInstance>;\n\treadonly onDidChangeActiveInstance: Event<ITerminalInstance | undefined>;\n\treadonly onDidChangeInstances: Event<void>;\n\treadonly onDidChangeInstanceCapability: Event<ITerminalInstance>;\n\n\tsetActiveInstance(instance: ITerminalInstance): void;\n\t/**\n\t * Reveal and focus the instance, regardless of its location.\n\t */\n\tfocusInstance(instance: ITerminalInstance): void;\n\t/**\n\t * Reveal and focus the active instance, regardless of its location.\n\t */\n\tfocusActiveInstance(): Promise<void>;\n\t/**\n\t * Gets an instance from a resource if it exists. This MUST be used instead of getInstanceFromId\n\t * when you only know about a terminal's URI. (a URI's instance ID may not be this window's instance ID)\n\t */\n\tgetInstanceFromResource(resource: UriComponents | undefined): ITerminalInstance | undefined;\n}\n\n/**\n * Similar to xterm.js' ILinkProvider but using promises and hides xterm.js internals (like buffer\n * positions, decorations, etc.) from the rest of vscode. This is the interface to use for\n * workbench integrations.\n */\nexport interface ITerminalExternalLinkProvider {\n\tprovideLinks(instance: ITerminalInstance, line: string): Promise<ITerminalLink[] | undefined>;\n}\n\nexport interface ITerminalLink {\n\t/** The startIndex of the link in the line. */\n\tstartIndex: number;\n\t/** The length of the link in the line. */\n\tlength: number;\n\t/** The descriptive label for what the link does when activated. */\n\tlabel?: string;\n\t/**\n\t * Activates the link.\n\t * @param text The text of the link.\n\t */\n\tactivate(text: string): void;\n}\n\nexport interface ISearchOptions {\n\t/** Whether the find should be done as a regex. */\n\tregex?: boolean;\n\t/** Whether only whole words should match. */\n\twholeWord?: boolean;\n\t/** Whether find should pay attention to case. */\n\tcaseSensitive?: boolean;\n\t/** Whether the search should start at the current search position (not the next row). */\n\tincremental?: boolean;\n}\n\nexport interface ITerminalInstance extends IBaseTerminalInstance {\n\t/**\n\t * The ID of the terminal instance, this is an arbitrary number only used to uniquely identify\n\t * terminal instances within a window.\n\t */\n\treadonly instanceId: number;\n\t/**\n\t * A unique URI for this terminal instance with the following encoding:\n\t * path: /<workspace ID>/<instance ID>\n\t * fragment: Title\n\t * Note that when dragging terminals across windows, this will retain the original workspace ID /instance ID\n\t * from the other window.\n\t */\n\treadonly resource: URI;\n\n\treadonly cols: number;\n\treadonly rows: number;\n\treadonly maxCols: number;\n\treadonly maxRows: number;\n\treadonly fixedCols?: number;\n\treadonly fixedRows?: number;\n\treadonly domElement: HTMLElement;\n\treadonly icon?: TerminalIcon;\n\treadonly color?: string;\n\treadonly reconnectionProperties?: IReconnectionProperties;\n\treadonly processName: string;\n\treadonly sequence?: string;\n\treadonly staticTitle?: string;\n\treadonly progressState?: IProgressState;\n\treadonly workspaceFolder?: IWorkspaceFolder;\n\treadonly cwd?: string;\n\treadonly initialCwd?: string;\n\treadonly os?: OperatingSystem;\n\treadonly usedShellIntegrationInjection: boolean;\n\treadonly shellIntegrationInjectionFailureReason: ShellIntegrationInjectionFailureReason | undefined;\n\treadonly injectedArgs: string[] | undefined;\n\treadonly extEnvironmentVariableCollection: IMergedEnvironmentVariableCollection | undefined;\n\n\t/**\n\t * The underlying disposable store, allowing objects who share the same lifecycle as the\n\t * terminal instance but are created externally to be managed by the instance.\n\t */\n\treadonly store: DisposableStore;\n\n\treadonly statusList: ITerminalStatusList;\n\n\t/**\n\t * The process ID of the shell process, this is undefined when there is no process associated\n\t * with this terminal.\n\t */\n\tprocessId: number | undefined;\n\n\t/**\n\t * The position of the terminal.\n\t */\n\ttarget: TerminalLocation | undefined;\n\ttargetRef: IReference<TerminalLocation | undefined>;\n\n\t/**\n\t * The id of a persistent process. This is defined if this is a terminal created by a pty host\n\t * that supports reconnection.\n\t */\n\treadonly persistentProcessId: number | undefined;\n\n\t/**\n\t * Whether the process should be persisted across reloads.\n\t */\n\treadonly shouldPersist: boolean;\n\n\t/*\n\t * Whether this terminal has been disposed of\n\t */\n\treadonly isDisposed: boolean;\n\n\t/**\n\t * Whether the terminal's pty is hosted on a remote.\n\t */\n\treadonly hasRemoteAuthority: boolean;\n\n\t/**\n\t * The remote authority of the terminal's pty.\n\t */\n\treadonly remoteAuthority: string | undefined;\n\n\t/**\n\t * Whether an element within this terminal is focused.\n\t */\n\treadonly hasFocus: boolean;\n\n\t/**\n\t * The ID of the session that this terminal is connected to\n\t */\n\treadonly sessionId: string;\n\n\t/**\n\t * Get or set the behavior of the terminal when it closes. This was indented only to be called\n\t * after reconnecting to a terminal.\n\t */\n\twaitOnExit: WaitOnExitValue | undefined;\n\n\t/**\n\t * An event that fires when the terminal instance's title changes.\n\t */\n\treadonly onTitleChanged: Event<ITerminalInstance>;\n\n\t/**\n\t * An event that fires when the terminal instance's icon changes.\n\t */\n\treadonly onIconChanged: Event<{ instance: ITerminalInstance; userInitiated: boolean }>;\n\n\t/**\n\t * An event that fires when the terminal instance is disposed.\n\t */\n\treadonly onDisposed: Event<ITerminalInstance>;\n\n\treadonly onProcessIdReady: Event<ITerminalInstance>;\n\treadonly onProcessReplayComplete: Event<void>;\n\treadonly onRequestExtHostProcess: Event<ITerminalInstance>;\n\treadonly onDimensionsChanged: Event<void>;\n\treadonly onMaximumDimensionsChanged: Event<void>;\n\treadonly onDidChangeHasChildProcesses: Event<boolean>;\n\n\treadonly onDidFocus: Event<ITerminalInstance>;\n\treadonly onDidRequestFocus: Event<void>;\n\treadonly onDidBlur: Event<ITerminalInstance>;\n\treadonly onDidInputData: Event<string>;\n\treadonly onDidChangeSelection: Event<ITerminalInstance>;\n\treadonly onDidExecuteText: Event<void>;\n\treadonly onDidChangeTarget: Event<TerminalLocation | undefined>;\n\treadonly onDidSendText: Event<string>;\n\treadonly onDidChangeShellType: Event<TerminalShellType>;\n\treadonly onDidChangeVisibility: Event<boolean>;\n\n\t/**\n\t * An event that fires when a terminal is dropped on this instance via drag and drop.\n\t */\n\treadonly onRequestAddInstanceToGroup: Event<IRequestAddInstanceToGroupEvent>;\n\n\t/**\n\t * Attach a listener to the raw data stream coming from the pty, including ANSI escape\n\t * sequences.\n\t */\n\treadonly onData: Event<string>;\n\treadonly onWillData: Event<string>;\n\n\t/**\n\t * Attach a listener to the binary data stream coming from xterm and going to pty\n\t */\n\treadonly onBinary: Event<string>;\n\n\t/**\n\t * Attach a listener to listen for new lines added to this terminal instance.\n\t *\n\t * @param listener The listener function which takes new line strings added to the terminal,\n\t * excluding ANSI escape sequences. The line event will fire when an LF character is added to\n\t * the terminal (ie. the line is not wrapped). Note that this means that the line data will\n\t * not fire for the last line, until either the line is ended with a LF character of the process\n\t * is exited. The lineData string will contain the fully wrapped line, not containing any LF/CR\n\t * characters.\n\t */\n\treadonly onLineData: Event<string>;\n\n\t/**\n\t * Attach a listener that fires when the terminal's pty process exits. The number in the event\n\t * is the processes' exit code, an exit code of undefined means the process was killed as a result of\n\t * the ITerminalInstance being disposed.\n\t */\n\treadonly onExit: Event<number | ITerminalLaunchError | undefined>;\n\n\t/**\n\t * The exit code or undefined when the terminal process hasn't yet exited or\n\t * the process exit code could not be determined. Use {@link exitReason} to see\n\t * why the process has exited.\n\t */\n\treadonly exitCode: number | undefined;\n\n\t/**\n\t * The reason the terminal process exited, this will be undefined if the process is still\n\t * running.\n\t */\n\treadonly exitReason: TerminalExitReason | undefined;\n\n\t/**\n\t * The xterm.js instance for this terminal.\n\t */\n\treadonly xterm?: XtermTerminal;\n\n\t/**\n\t * Resolves when the xterm.js instance for this terminal is ready.\n\t */\n\treadonly xtermReadyPromise: Promise<XtermTerminal | undefined>;\n\n\t/**\n\t * Returns an array of data events that have fired within the first 10 seconds. If this is\n\t * called 10 seconds after the terminal has existed the result will be undefined. This is useful\n\t * when objects that depend on the data events have delayed initialization, like extension\n\t * hosts.\n\t */\n\treadonly initialDataEvents: string[] | undefined;\n\n\t/** A promise that resolves when the terminal's pty/process have been created. */\n\treadonly processReady: Promise<void>;\n\n\t/** Whether the terminal's process has child processes (ie. is dirty/busy). */\n\treadonly hasChildProcesses: boolean;\n\n\t/**\n\t * The title of the terminal. This is either title or the process currently running or an\n\t * explicit name given to the terminal instance through the extension API.\n\t */\n\treadonly title: string;\n\n\t/**\n\t * How the current title was set.\n\t */\n\treadonly titleSource: TitleEventSource;\n\n\t/**\n\t * The shell type of the terminal.\n\t */\n\treadonly shellType: TerminalShellType | undefined;\n\n\t/**\n\t * The focus state of the terminal before exiting.\n\t */\n\treadonly hadFocusOnExit: boolean;\n\n\t/**\n\t * False when the title is set by an API or the user. We check this to make sure we\n\t * do not override the title when the process title changes in the terminal.\n\t */\n\tisTitleSetByProcess: boolean;\n\n\t/**\n\t * The shell launch config used to launch the shell.\n\t */\n\treadonly shellLaunchConfig: IShellLaunchConfig;\n\n\t/**\n\t * Whether to disable layout for the terminal. This is useful when the size of the terminal is\n\t * being manipulating (e.g. adding a split pane) and we want the terminal to ignore particular\n\t * resize events.\n\t */\n\tdisableLayout: boolean;\n\n\t/**\n\t * The description of the terminal, this is typically displayed next to {@link title}.\n\t */\n\tdescription: string | undefined;\n\n\t/**\n\t * The remote-aware $HOME directory (or Windows equivalent) of the terminal.\n\t */\n\tuserHome: string | undefined;\n\n\t/**\n\t * The nonce used to verify commands coming from shell integration.\n\t */\n\tshellIntegrationNonce: string;\n\n\t/**\n\t * Registers and returns a marker\n\t * @param the y offset from the cursor\n\t */\n\tregisterMarker(offset?: number): IMarker | undefined;\n\n\t/**\n\t * Adds a marker to the buffer, mapping it to an ID if provided.\n\t */\n\taddBufferMarker(properties: IMarkProperties): void;\n\n\t/**\n\t *\n\t * @param startMarkId The ID for the start marker\n\t * @param endMarkId The ID for the end marker\n\t * @param highlight Whether the buffer from startMarker to endMarker\n\t * should be highlighted\n\t */\n\tscrollToMark(startMarkId: string, endMarkId?: string, highlight?: boolean): void;\n\n\t/**\n\t * Dispose the terminal instance, removing it from the panel/service and freeing up resources.\n\t *\n\t * @param reason The reason why the terminal is being disposed\n\t */\n\tdispose(reason?: TerminalExitReason): void;\n\n\t/**\n\t * Informs the process that the terminal is now detached and\n\t * then disposes the terminal.\n\t *\n\t * @param reason The reason why the terminal is being disposed\n\t */\n\tdetachProcessAndDispose(reason: TerminalExitReason): Promise<void>;\n\n\t/**\n\t * When the panel is hidden or a terminal in the editor area becomes inactive, reset the focus context key\n\t * to avoid issues like #147180.\n\t */\n\tresetFocusContextKey(): void;\n\n\t/**\n\t * Focuses the terminal instance when it's ready (the xterm.js instance much exist). This is the\n\t * best focus call when the terminal is being shown for example.\n\t * when the terminal is being shown.\n\t *\n\t * @param force Force focus even if there is a selection.\n\t */\n\tfocusWhenReady(force?: boolean): Promise<void>;\n\n\t/**\n\t * Send text to the terminal instance. The text is written to the stdin of the underlying pty\n\t * process (shell) of the terminal instance.\n\t *\n\t * @param text The text to send.\n\t * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.\n\t * The character(s) added are \\n or \\r\\n, depending on the platform. This defaults to `true`.\n\t * @param bracketedPasteMode Whether to wrap the text in the bracketed paste mode sequence when\n\t * it's enabled. When true, the shell will treat the text as if it were pasted into the shell,\n\t * this may for example select the text and it will also ensure that the text will not be\n\t * interpreted as a shell keybinding.\n\t */\n\tsendText(text: string, shouldExecute: boolean, bracketedPasteMode?: boolean): Promise<void>;\n\n\t/**\n\t * Sends a signal to the terminal instance's process.\n\t *\n\t * @param signal The signal to send (e.g., 'SIGTERM', 'SIGINT', 'SIGKILL').\n\t */\n\tsendSignal(signal: string): Promise<void>;\n\n\t/**\n\t * Sends a path to the terminal instance, preparing it as needed based on the detected shell\n\t * running within the terminal. The text is written to the stdin of the underlying pty process\n\t * (shell) of the terminal instance.\n\t *\n\t * @param originalPath The path to send.\n\t * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.\n\t * The character(s) added are \\n or \\r\\n, depending on the platform. This defaults to `true`.\n\t */\n\tsendPath(originalPath: string | URI, shouldExecute: boolean): Promise<void>;\n\n\trunCommand(command: string, shouldExecute?: boolean, commandId?: string): Promise<void>;\n\n\t/**\n\t * Takes a path and returns the properly escaped path to send to a given shell. On Windows, this\n\t * includes trying to prepare the path for WSL if needed.\n\t *\n\t * @param originalPath The path to be escaped and formatted.\n\t */\n\tpreparePathForShell(originalPath: string): Promise<string>;\n\n\t/**\n\t * Formats a file system URI for display in UI so that it appears in the terminal shell's format.\n\t * @param uri The URI to format.\n\t */\n\tgetUriLabelForShell(uri: URI): Promise<string>;\n\n\t/** Scroll the terminal buffer down 1 line. */   scrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page. */   scrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */ scrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line. */     scrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page. */     scrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top. */    scrollToTop(): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line and moving it to the top of the\n\t * viewport.\n\t */\n\tclearBuffer(): void;\n\n\t/**\n\t * Attaches the terminal instance to an element on the DOM, before this is called the terminal\n\t * instance process may run in the background but cannot be displayed on the UI.\n\t *\n\t * @param container The element to attach the terminal instance to.\n\t */\n\tattachToElement(container: HTMLElement): void;\n\n\t/**\n\t * Detaches the terminal instance from the terminal editor DOM element.\n\t */\n\tdetachFromElement(): void;\n\n\t/**\n\t * Layout the terminal instance.\n\t *\n\t * @param dimension The dimensions of the container.\n\t */\n\tlayout(dimension: { width: number; height: number }): void;\n\n\t/**\n\t * Sets whether the terminal instance's element is visible in the DOM.\n\t *\n\t * @param visible Whether the element is visible.\n\t */\n\tsetVisible(visible: boolean): void;\n\n\t/**\n\t * Immediately kills the terminal's current pty process and launches a new one to replace it.\n\t *\n\t * @param shell The new launch configuration.\n\t */\n\treuseTerminal(shell: IShellLaunchConfig): Promise<void>;\n\n\t/**\n\t * Relaunches the terminal, killing it and reusing the launch config used initially. Any\n\t * environment variable changes will be recalculated when this happens.\n\t */\n\trelaunch(): void;\n\n\t/**\n\t * Sets the terminal instance's dimensions to the values provided via the onDidOverrideDimensions event,\n\t * which allows overriding the regular dimensions (fit to the size of the panel).\n\t */\n\tsetOverrideDimensions(dimensions: ITerminalDimensions): void;\n\n\t/**\n\t * Sets the terminal instance's dimensions to the values provided via quick input.\n\t */\n\tsetFixedDimensions(): Promise<void>;\n\n\t/**\n\t * Toggles terminal line wrapping.\n\t */\n\ttoggleSizeToContentWidth(): Promise<void>;\n\n\t/**\n\t * Gets the initial current working directory, fetching it from the backend if required.\n\t */\n\tgetInitialCwd(): Promise<string>;\n\n\t/**\n\t * Gets the current working directory from cwd detection capabilities if available, otherwise\n\t * from the backend. This will return the initial cwd if cwd detection is not available (ie.\n\t * on Windows when shell integration is disabled).\n\t */\n\tgetSpeculativeCwd(): Promise<string>;\n\n\t/**\n\t * Gets the cwd as a URI that has been validated to exist.\n\t */\n\tgetCwdResource(): Promise<URI | undefined>;\n\n\t/**\n\t * Sets the title of the terminal to the provided string. If no title is provided, it will reset\n\t * to the terminal's title if it was not explicitly set by the user or API.\n\t * @param title The new title.\n\t */\n\trename(title?: string): Promise<void>;\n\n\t/**\n\t * Sets or triggers a quick pick to change the icon of this terminal.\n\t */\n\tchangeIcon(icon?: TerminalIcon): Promise<TerminalIcon | undefined>;\n\n\t/**\n\t * Sets or triggers a quick pick to change the color of the associated terminal tab icon.\n\t */\n\tchangeColor(color?: string, skipQuickPick?: boolean): Promise<string | undefined>;\n\n\t/**\n\t * Attempts to detect and kill the process listening on specified port.\n\t * If successful, places commandToRun on the command line\n\t */\n\tfreePortKillProcess(port: string, commandToRun: string): Promise<void>;\n\n\t/**\n\t * Update the parent context key service to use for this terminal instance.\n\t */\n\tsetParentContextKeyService(parentContextKeyService: IContextKeyService): void;\n\n\t/**\n\t * Handles a mouse event for the terminal, this may happen on an anscestor of the terminal\n\t * instance's element.\n\t * @param event The mouse event.\n\t * @param contextMenu The context menu to show if needed.\n\t * @returns Whether the context menu should be suppressed.\n\t */\n\thandleMouseEvent(event: MouseEvent, contextMenu: IMenu): Promise<{ cancelContextMenu: boolean } | void>;\n}\n\nexport const enum XtermTerminalConstants {\n\tSearchHighlightLimit = 20000\n}\n\nexport interface IXtermAttachToElementOptions {\n\t/**\n\t * Whether GPU rendering should be enabled for this element, defaults to true.\n\t */\n\tenableGpu: boolean;\n}\n\nexport interface IXtermTerminal extends IDisposable {\n\t/**\n\t * An object that tracks when commands are run and enables navigating and selecting between\n\t * them.\n\t */\n\treadonly markTracker: IMarkTracker;\n\n\t/**\n\t * Reports the status of shell integration and fires events relating to it.\n\t */\n\treadonly shellIntegration: IShellIntegration;\n\n\treadonly decorationAddon: IDecorationAddon;\n\n\treadonly onDidChangeSelection: Event<void>;\n\treadonly onDidChangeFindResults: Event<{ resultIndex: number; resultCount: number }>;\n\treadonly onDidRequestRunCommand: Event<{ command: ITerminalCommand; noNewLine?: boolean }>;\n\treadonly onDidRequestCopyAsHtml: Event<{ command: ITerminalCommand }>;\n\n\t/**\n\t * Event fired when focus enters (fires with true) or leaves (false) the terminal.\n\t */\n\treadonly onDidChangeFocus: Event<boolean>;\n\n\t/**\n\t * Gets a view of the current texture atlas used by the renderers.\n\t */\n\treadonly textureAtlas: Promise<ImageBitmap> | undefined;\n\n\t/**\n\t * Whether the `disableStdin` option in xterm.js is set.\n\t */\n\treadonly isStdinDisabled: boolean;\n\n\t/**\n\t * Whether the terminal is currently focused.\n\t */\n\treadonly isFocused: boolean;\n\n\t/**\n\t * Whether a canvas-based renderer is being used.\n\t */\n\treadonly isGpuAccelerated: boolean;\n\n\t/**\n\t * The last `onData` input event fired by {@link RawXtermTerminal.onData}.\n\t */\n\treadonly lastInputEvent: string | undefined;\n\n\t/**\n\t * Attached the terminal to the given element\n\t * @param container Container the terminal will be rendered in\n\t * @param options Additional options for mounting the terminal in an element\n\t */\n\tattachToElement(container: HTMLElement, options?: Partial<IXtermAttachToElementOptions>): void;\n\n\tfindResult?: { resultIndex: number; resultCount: number };\n\n\t/**\n\t * Find the next instance of the term\n\t*/\n\tfindNext(term: string, searchOptions: ISearchOptions): Promise<boolean>;\n\n\t/**\n\t * Find the previous instance of the term\n\t */\n\tfindPrevious(term: string, searchOptions: ISearchOptions): Promise<boolean>;\n\n\t/**\n\t * Forces the terminal to redraw its viewport.\n\t */\n\tforceRedraw(): void;\n\n\t/**\n\t * Gets the font metrics of this xterm.js instance.\n\t */\n\tgetFont(): ITerminalFont;\n\n\t/**\n\t * Gets whether there's any terminal selection.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Clears any terminal selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Selects all terminal contents/\n\t */\n\tselectAll(): void;\n\n\t/**\n\t * Selects the content between the two markers by their VS Code OSC `SetMarker`\n\t * ID. It's a no-op if either of the two markers are not found.\n\t *\n\t * @param fromMarkerId Start marker ID\n\t * @param toMarkerId End marker ID\n\t * @param scrollIntoView Whether the terminal should scroll to the start of\n\t * the range, defaults tof alse\n\t */\n\tselectMarkedRange(fromMarkerId: string, toMarkerId: string, scrollIntoView?: boolean): void;\n\n\t/**\n\t * Copies the terminal selection.\n\t * @param copyAsHtml Whether to copy selection as HTML, defaults to false.\n\t */\n\tcopySelection(copyAsHtml?: boolean, command?: ITerminalCommand): void;\n\t/**\n\t * Focuses the terminal. Warning: {@link ITerminalInstance.focus} should be\n\t * preferred when dealing with terminal instances in order to get\n\t * accessibility triggers.\n\t */\n\tfocus(): void;\n\n\t/** Scroll the terminal buffer down 1 line.   */ scrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page.   */ scrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */ scrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line.     */ scrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page.     */ scrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top.    */ scrollToTop(): void;\n\t/** Scroll the terminal buffer to a set line  */ scrollToLine(line: number, position?: ScrollPosition): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line and moving it to the top of the\n\t * viewport.\n\t */\n\tclearBuffer(): void;\n\n\t/**\n\t * Clears the search result decorations\n\t */\n\tclearSearchDecorations(): void;\n\n\t/**\n\t * Clears the active search result decorations\n\t */\n\tclearActiveSearchDecoration(): void;\n\n\t/**\n\t * Returns a reverse iterator of buffer lines as strings\n\t */\n\tgetBufferReverseIterator(): IterableIterator<string>;\n\n\t/**\n\t * Gets the contents of the buffer from a start marker (or line 0) to the end marker (or the\n\t * last line).\n\t */\n\tgetContentsAsText(startMarker?: IXtermMarker, endMarker?: IXtermMarker): string;\n\n\t/**\n\t * Gets the buffer contents as HTML.\n\t */\n\tgetContentsAsHtml(): Promise<string>;\n\n\t/**\n\t * Refreshes the terminal after it has been moved.\n\t */\n\trefresh(): void;\n\n\tgetXtermTheme(theme?: IColorTheme): ITheme;\n}\n\nexport interface IDetachedXtermTerminal extends IXtermTerminal {\n\t/**\n\t * Writes data to the terminal.\n\t * @param data data to write\n\t * @param callback Optional callback that fires when the data was processed\n\t * by the parser.\n\t */\n\twrite(data: string | Uint8Array, callback?: () => void): void;\n\n\t/**\n\t * Resizes the terminal.\n\t */\n\tresize(columns: number, rows: number): void;\n}\n\nexport interface IInternalXtermTerminal {\n\t/**\n\t * Writes text directly to the terminal, bypassing the process.\n\t *\n\t * **WARNING:** This should never be used outside of the terminal component and only for\n\t * developer purposed inside the terminal component.\n\t */\n\t_writeText(data: string): void; // eslint-disable-line @typescript-eslint/naming-convention\n}\n\nexport interface IXtermColorProvider {\n\tgetBackgroundColor(theme: IColorTheme): Color | undefined;\n}\n\nexport interface IRequestAddInstanceToGroupEvent {\n\turi: URI;\n\tside: 'before' | 'after';\n}\n\nexport const enum LinuxDistro {\n\tUnknown = 1,\n\tFedora = 2,\n\tUbuntu = 3,\n}\n\nexport const enum TerminalDataTransfers {\n\tTerminals = 'Terminals'\n}\n"],
      version: 3
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "807673b7a62ed529e510f5ee1714494acafa37e1"
  };
  var coverage = global[gcv] || (global[gcv] = {});
  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }
  var actualCoverage = coverage[path];
  {
    // @ts-ignore
    cov_2gh0w04gn0 = function () {
      return actualCoverage;
    };
  }
  return actualCoverage;
}
cov_2gh0w04gn0();
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';
export const ITerminalService =
/* istanbul ignore next */
(cov_2gh0w04gn0().s[0]++, createDecorator('terminalService'));
export const ITerminalConfigurationService =
/* istanbul ignore next */
(cov_2gh0w04gn0().s[1]++, createDecorator('terminalConfigurationService'));
export const ITerminalEditorService =
/* istanbul ignore next */
(cov_2gh0w04gn0().s[2]++, createDecorator('terminalEditorService'));
export const ITerminalEditingService =
/* istanbul ignore next */
(cov_2gh0w04gn0().s[3]++, createDecorator('terminalEditingService'));
export const ITerminalGroupService =
/* istanbul ignore next */
(cov_2gh0w04gn0().s[4]++, createDecorator('terminalGroupService'));
export const ITerminalInstanceService =
/* istanbul ignore next */
(cov_2gh0w04gn0().s[5]++, createDecorator('terminalInstanceService'));
export const ITerminalChatService =
/* istanbul ignore next */
(cov_2gh0w04gn0().s[6]++, createDecorator('terminalChatService'));
/* istanbul ignore next */
cov_2gh0w04gn0().s[7]++;
export const isDetachedTerminalInstance = t => {
  /* istanbul ignore next */
  cov_2gh0w04gn0().f[0]++;
  cov_2gh0w04gn0().s[8]++;
  return typeof t.instanceId !== 'number';
};
export class TerminalLinkQuickPickEvent extends MouseEvent {}
export const terminalEditorId =
/* istanbul ignore next */
(cov_2gh0w04gn0().s[9]++, 'terminalEditor');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb3ZfMmdoMHcwNGduMCIsImFjdHVhbENvdmVyYWdlIiwiY3JlYXRlRGVjb3JhdG9yIiwiSVRlcm1pbmFsU2VydmljZSIsInMiLCJJVGVybWluYWxDb25maWd1cmF0aW9uU2VydmljZSIsIklUZXJtaW5hbEVkaXRvclNlcnZpY2UiLCJJVGVybWluYWxFZGl0aW5nU2VydmljZSIsIklUZXJtaW5hbEdyb3VwU2VydmljZSIsIklUZXJtaW5hbEluc3RhbmNlU2VydmljZSIsIklUZXJtaW5hbENoYXRTZXJ2aWNlIiwiaXNEZXRhY2hlZFRlcm1pbmFsSW5zdGFuY2UiLCJ0IiwiZiIsImluc3RhbmNlSWQiLCJUZXJtaW5hbExpbmtRdWlja1BpY2tFdmVudCIsIk1vdXNlRXZlbnQiLCJ0ZXJtaW5hbEVkaXRvcklkIl0sInNvdXJjZXMiOlsiL2hvbWUvdXNlci9EZXNrdG9wL01pbnRNaW5kL3NyYy92cy93b3JrYmVuY2gvY29udHJpYi90ZXJtaW5hbC9icm93c2VyL3Rlcm1pbmFsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5pbXBvcnQgeyBJRGltZW5zaW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9icm93c2VyL2RvbS5qcyc7XG5pbXBvcnQgeyBPcmllbnRhdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvYnJvd3Nlci91aS9zcGxpdHZpZXcvc3BsaXR2aWV3LmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vY29sb3IuanMnO1xuaW1wb3J0IHsgRXZlbnQsIElEeW5hbWljTGlzdEV2ZW50TXVsdGlwbGV4ZXIsIHR5cGUgRHluYW1pY0xpc3RFdmVudE11bHRpcGxleGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vZXZlbnQuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZVN0b3JlLCBJRGlzcG9zYWJsZSwgdHlwZSBJUmVmZXJlbmNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IE9wZXJhdGluZ1N5c3RlbSB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IFVSSSwgVXJpQ29tcG9uZW50cyB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL3VyaS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVEZWNvcmF0b3IgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS9pbnN0YW50aWF0aW9uL2NvbW1vbi9pbnN0YW50aWF0aW9uLmpzJztcbmltcG9ydCB7IElLZXlNb2RzIH0gZnJvbSAnLi4vLi4vLi4vLi4vcGxhdGZvcm0vcXVpY2tpbnB1dC9jb21tb24vcXVpY2tJbnB1dC5qcyc7XG5pbXBvcnQgeyBJTWFya1Byb3BlcnRpZXMsIElUZXJtaW5hbENhcGFiaWxpdHlJbXBsTWFwLCBJVGVybWluYWxDYXBhYmlsaXR5U3RvcmUsIElUZXJtaW5hbENvbW1hbmQsIFRlcm1pbmFsQ2FwYWJpbGl0eSB9IGZyb20gJy4uLy4uLy4uLy4uL3BsYXRmb3JtL3Rlcm1pbmFsL2NvbW1vbi9jYXBhYmlsaXRpZXMvY2FwYWJpbGl0aWVzLmpzJztcbmltcG9ydCB7IElNZXJnZWRFbnZpcm9ubWVudFZhcmlhYmxlQ29sbGVjdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uL3BsYXRmb3JtL3Rlcm1pbmFsL2NvbW1vbi9lbnZpcm9ubWVudFZhcmlhYmxlLmpzJztcbmltcG9ydCB7IElFeHRlbnNpb25UZXJtaW5hbFByb2ZpbGUsIElSZWNvbm5lY3Rpb25Qcm9wZXJ0aWVzLCBJU2hlbGxJbnRlZ3JhdGlvbiwgSVNoZWxsTGF1bmNoQ29uZmlnLCBJVGVybWluYWxCYWNrZW5kLCBJVGVybWluYWxEaW1lbnNpb25zLCBJVGVybWluYWxMYXVuY2hFcnJvciwgSVRlcm1pbmFsUHJvZmlsZSwgSVRlcm1pbmFsVGFiTGF5b3V0SW5mb0J5SWQsIFRlcm1pbmFsRXhpdFJlYXNvbiwgVGVybWluYWxJY29uLCBUZXJtaW5hbExvY2F0aW9uLCBUZXJtaW5hbFNoZWxsVHlwZSwgVGVybWluYWxUeXBlLCBUaXRsZUV2ZW50U291cmNlLCBXYWl0T25FeGl0VmFsdWUsIHR5cGUgSURlY29yYXRpb25BZGRvbiwgdHlwZSBTaGVsbEludGVncmF0aW9uSW5qZWN0aW9uRmFpbHVyZVJlYXNvbiB9IGZyb20gJy4uLy4uLy4uLy4uL3BsYXRmb3JtL3Rlcm1pbmFsL2NvbW1vbi90ZXJtaW5hbC5qcyc7XG5pbXBvcnQgeyBJQ29sb3JUaGVtZSB9IGZyb20gJy4uLy4uLy4uLy4uL3BsYXRmb3JtL3RoZW1lL2NvbW1vbi90aGVtZVNlcnZpY2UuanMnO1xuaW1wb3J0IHsgSVdvcmtzcGFjZUZvbGRlciB9IGZyb20gJy4uLy4uLy4uLy4uL3BsYXRmb3JtL3dvcmtzcGFjZS9jb21tb24vd29ya3NwYWNlLmpzJztcbmltcG9ydCB7IEVkaXRvcklucHV0IH0gZnJvbSAnLi4vLi4vLi4vY29tbW9uL2VkaXRvci9lZGl0b3JJbnB1dC5qcyc7XG5pbXBvcnQgeyBJRWRpdGFibGVEYXRhIH0gZnJvbSAnLi4vLi4vLi4vY29tbW9uL3ZpZXdzLmpzJztcbmltcG9ydCB7IElUZXJtaW5hbFN0YXR1c0xpc3QgfSBmcm9tICcuL3Rlcm1pbmFsU3RhdHVzTGlzdC5qcyc7XG5pbXBvcnQgeyBYdGVybVRlcm1pbmFsIH0gZnJvbSAnLi94dGVybS94dGVybVRlcm1pbmFsLmpzJztcbmltcG9ydCB7IElSZWdpc3RlckNvbnRyaWJ1dGVkUHJvZmlsZUFyZ3MsIElSZW1vdGVUZXJtaW5hbEF0dGFjaFRhcmdldCwgSVN0YXJ0RXh0ZW5zaW9uVGVybWluYWxSZXF1ZXN0LCBJVGVybWluYWxDb25maWd1cmF0aW9uLCBJVGVybWluYWxGb250LCBJVGVybWluYWxQcm9jZXNzRXh0SG9zdFByb3h5LCBJVGVybWluYWxQcm9jZXNzSW5mbyB9IGZyb20gJy4uL2NvbW1vbi90ZXJtaW5hbC5qcyc7XG5pbXBvcnQgdHlwZSB7IElNYXJrZXIsIElUaGVtZSwgVGVybWluYWwgYXMgUmF3WHRlcm1UZXJtaW5hbCwgSUJ1ZmZlclJhbmdlLCBJTWFya2VyIGFzIElYdGVybU1hcmtlciB9IGZyb20gJ0B4dGVybS94dGVybSc7XG5pbXBvcnQgeyBTY3JvbGxQb3NpdGlvbiB9IGZyb20gJy4veHRlcm0vbWFya05hdmlnYXRpb25BZGRvbi5qcyc7XG5pbXBvcnQgeyBJQ29udGV4dEtleVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS9jb250ZXh0a2V5L2NvbW1vbi9jb250ZXh0a2V5LmpzJztcbmltcG9ydCB7IEdyb3VwSWRlbnRpZmllciB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9lZGl0b3IuanMnO1xuaW1wb3J0IHsgQUNUSVZFX0dST1VQX1RZUEUsIEFVWF9XSU5ET1dfR1JPVVBfVFlQRSwgU0lERV9HUk9VUF9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvZWRpdG9yL2NvbW1vbi9lZGl0b3JTZXJ2aWNlLmpzJztcbmltcG9ydCB0eXBlIHsgSUN1cnJlbnRQYXJ0aWFsQ29tbWFuZCB9IGZyb20gJy4uLy4uLy4uLy4uL3BsYXRmb3JtL3Rlcm1pbmFsL2NvbW1vbi9jYXBhYmlsaXRpZXMvY29tbWFuZERldGVjdGlvbi90ZXJtaW5hbENvbW1hbmQuanMnO1xuaW1wb3J0IHR5cGUgeyBJWHRlcm1Db3JlIH0gZnJvbSAnLi94dGVybS1wcml2YXRlLmpzJztcbmltcG9ydCB0eXBlIHsgSU1lbnUgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS9hY3Rpb25zL2NvbW1vbi9hY3Rpb25zLmpzJztcbmltcG9ydCB0eXBlIHsgSVByb2dyZXNzU3RhdGUgfSBmcm9tICdAeHRlcm0vYWRkb24tcHJvZ3Jlc3MnO1xuaW1wb3J0IHR5cGUgeyBJRWRpdG9yT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL3BsYXRmb3JtL2VkaXRvci9jb21tb24vZWRpdG9yLmpzJztcbmltcG9ydCB0eXBlIHsgVGVybWluYWxFZGl0b3JJbnB1dCB9IGZyb20gJy4vdGVybWluYWxFZGl0b3JJbnB1dC5qcyc7XG5pbXBvcnQgdHlwZSB7IE1heWJlUHJvbWlzZSB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2FzeW5jLmpzJztcbmltcG9ydCB0eXBlIHsgU2luZ2xlT3JNYW55IH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vdHlwZXMuanMnO1xuXG5leHBvcnQgY29uc3QgSVRlcm1pbmFsU2VydmljZSA9IGNyZWF0ZURlY29yYXRvcjxJVGVybWluYWxTZXJ2aWNlPigndGVybWluYWxTZXJ2aWNlJyk7XG5leHBvcnQgY29uc3QgSVRlcm1pbmFsQ29uZmlndXJhdGlvblNlcnZpY2UgPSBjcmVhdGVEZWNvcmF0b3I8SVRlcm1pbmFsQ29uZmlndXJhdGlvblNlcnZpY2U+KCd0ZXJtaW5hbENvbmZpZ3VyYXRpb25TZXJ2aWNlJyk7XG5leHBvcnQgY29uc3QgSVRlcm1pbmFsRWRpdG9yU2VydmljZSA9IGNyZWF0ZURlY29yYXRvcjxJVGVybWluYWxFZGl0b3JTZXJ2aWNlPigndGVybWluYWxFZGl0b3JTZXJ2aWNlJyk7XG5leHBvcnQgY29uc3QgSVRlcm1pbmFsRWRpdGluZ1NlcnZpY2UgPSBjcmVhdGVEZWNvcmF0b3I8SVRlcm1pbmFsRWRpdGluZ1NlcnZpY2U+KCd0ZXJtaW5hbEVkaXRpbmdTZXJ2aWNlJyk7XG5leHBvcnQgY29uc3QgSVRlcm1pbmFsR3JvdXBTZXJ2aWNlID0gY3JlYXRlRGVjb3JhdG9yPElUZXJtaW5hbEdyb3VwU2VydmljZT4oJ3Rlcm1pbmFsR3JvdXBTZXJ2aWNlJyk7XG5leHBvcnQgY29uc3QgSVRlcm1pbmFsSW5zdGFuY2VTZXJ2aWNlID0gY3JlYXRlRGVjb3JhdG9yPElUZXJtaW5hbEluc3RhbmNlU2VydmljZT4oJ3Rlcm1pbmFsSW5zdGFuY2VTZXJ2aWNlJyk7XG5leHBvcnQgY29uc3QgSVRlcm1pbmFsQ2hhdFNlcnZpY2UgPSBjcmVhdGVEZWNvcmF0b3I8SVRlcm1pbmFsQ2hhdFNlcnZpY2U+KCd0ZXJtaW5hbENoYXRTZXJ2aWNlJyk7XG5cbi8qKlxuICogQSB0ZXJtaW5hbCBjb250cmlidXRpb24gdGhhdCBnZXRzIGNyZWF0ZWQgd2hlbmV2ZXIgYSB0ZXJtaW5hbCBpcyBjcmVhdGVkLiBBIGNvbnRyaWJ1dGlvbiBoYXNcbiAqIGFjY2VzcyB0byB0aGUgcHJvY2VzcyBtYW5hZ2VyIHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yIGFuZCBwcm92aWRlcyBhIG1ldGhvZCBmb3Igd2hlbiB4dGVybS5qcyBoYXNcbiAqIGJlZW4gaW5pdGlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVRlcm1pbmFsQ29udHJpYnV0aW9uIGV4dGVuZHMgSURpc3Bvc2FibGUge1xuXHRsYXlvdXQ/KHh0ZXJtOiBJWHRlcm1UZXJtaW5hbCAmIHsgcmF3OiBSYXdYdGVybVRlcm1pbmFsIH0sIGRpbWVuc2lvbjogSURpbWVuc2lvbik6IHZvaWQ7XG5cdHh0ZXJtT3Blbj8oeHRlcm06IElYdGVybVRlcm1pbmFsICYgeyByYXc6IFJhd1h0ZXJtVGVybWluYWwgfSk6IHZvaWQ7XG5cdHh0ZXJtUmVhZHk/KHh0ZXJtOiBJWHRlcm1UZXJtaW5hbCAmIHsgcmF3OiBSYXdYdGVybVRlcm1pbmFsIH0pOiB2b2lkO1xuXG5cdGhhbmRsZU1vdXNlRXZlbnQ/KGV2ZW50OiBNb3VzZUV2ZW50KTogTWF5YmVQcm9taXNlPHsgaGFuZGxlZDogYm9vbGVhbiB9IHwgdm9pZD47XG59XG5cbi8qKlxuICogQSBzZXJ2aWNlIHVzZWQgdG8gY3JlYXRlIGluc3RhbmNlcyBvciBmZXRjaCBiYWNrZW5kcywgdGhpcyBzZXJ2aWNlcyBhbGxvd3Mgc2VydmljZXMgdGhhdFxuICogSVRlcm1pbmFsU2VydmljZSBkZXBlbmRzIG9uIHRvIGFsc28gY3JlYXRlIGluc3RhbmNlcy5cbiAqXG4gKiAqKlRoaXMgc2VydmljZSBpcyBpbnRlbmRlZCB0byBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSB0ZXJtaW5hbCBjb250cmliLioqXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVRlcm1pbmFsSW5zdGFuY2VTZXJ2aWNlIHtcblx0cmVhZG9ubHkgX3NlcnZpY2VCcmFuZDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCB0aGF0J3MgZmlyZWQgd2hlbiBhIHRlcm1pbmFsIGluc3RhbmNlIGlzIGNyZWF0ZWQuXG5cdCAqL1xuXHRyZWFkb25seSBvbkRpZENyZWF0ZUluc3RhbmNlOiBFdmVudDxJVGVybWluYWxJbnN0YW5jZT47XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IHRoYXQncyBmaXJlZCB3aGVuIGEgbmV3IGJhY2tlbmQgaXMgcmVnaXN0ZXJlZC5cblx0ICovXG5cdHJlYWRvbmx5IG9uRGlkUmVnaXN0ZXJCYWNrZW5kOiBFdmVudDxJVGVybWluYWxCYWNrZW5kPjtcblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBzaGVsbCBsYXVuY2ggY29uZmlnLCBhIHByb2ZpbGUgb3IgdW5kZWZpbmVkIGludG8gaXRzIGVxdWl2YWxlbnRcblx0ICogc2hlbGwgbGF1bmNoIGNvbmZpZy5cblx0ICogQHBhcmFtIHNoZWxsTGF1bmNoQ29uZmlnT3JQcm9maWxlIEEgc2hlbGwgbGF1bmNoIGNvbmZpZywgYSBwcm9maWxlIG9yIHVuZGVmaW5lZFxuXHQgKiBAcGFyYW0gY3dkIEEgY3dkIHRvIG92ZXJyaWRlLlxuXHQgKi9cblx0Y29udmVydFByb2ZpbGVUb1NoZWxsTGF1bmNoQ29uZmlnKHNoZWxsTGF1bmNoQ29uZmlnT3JQcm9maWxlPzogSVNoZWxsTGF1bmNoQ29uZmlnIHwgSVRlcm1pbmFsUHJvZmlsZSwgY3dkPzogc3RyaW5nIHwgVVJJKTogSVNoZWxsTGF1bmNoQ29uZmlnO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgdGVybWluYWwgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSBsYXVuY2hDb25maWcgVGhlIHNoZWxsIGxhdW5jaCBjb25maWcuXG5cdCAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgdGVybWluYWwuXG5cdCAqL1xuXHRjcmVhdGVJbnN0YW5jZShsYXVuY2hDb25maWc6IElTaGVsbExhdW5jaENvbmZpZywgdGFyZ2V0OiBUZXJtaW5hbExvY2F0aW9uLCBlZGl0b3JPcHRpb25zPzogVGVybWluYWxFZGl0b3JMb2NhdGlvbik6IElUZXJtaW5hbEluc3RhbmNlO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSByZWdpc3RlcmVkIGJhY2tlbmQgZm9yIGEgcmVtb3RlIGF1dGhvcml0eSAodW5kZWZpbmVkID0gbG9jYWwpLiBUaGlzIGlzIGEgY29udmVuaWVuY2Vcblx0ICogbWV0aG9kIHRvIGF2b2lkIHVzaW5nIHRoZSBtb3JlIHZlcmJvc2UgZmV0Y2hpbmcgZnJvbSB0aGUgcmVnaXN0cnkuXG5cdCAqIEBwYXJhbSByZW1vdGVBdXRob3JpdHkgVGhlIHJlbW90ZSBhdXRob3JpdHkgb2YgdGhlIGJhY2tlbmQuXG5cdCAqL1xuXHRnZXRCYWNrZW5kKHJlbW90ZUF1dGhvcml0eT86IHN0cmluZyk6IFByb21pc2U8SVRlcm1pbmFsQmFja2VuZCB8IHVuZGVmaW5lZD47XG5cblx0Z2V0UmVnaXN0ZXJlZEJhY2tlbmRzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8SVRlcm1pbmFsQmFja2VuZD47XG5cdGRpZFJlZ2lzdGVyQmFja2VuZChiYWNrZW5kOiBJVGVybWluYWxCYWNrZW5kKTogdm9pZDtcbn1cblxuLyoqXG4gKiBTZXJ2aWNlIGVuYWJsaW5nIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgY2hhdCB0b29sIGltcGxlbWVudGF0aW9uIGluIHRlcm1pbmFsIGNvbnRyaWIgYW5kIHdvcmtiZW5jaCBjb250cmlicy5cbiAqIEFjdHMgYXMgYSBjb21tdW5pY2F0aW9uIG1lY2hhbmlzbSBmb3IgY2hhdC1yZWxhdGVkIHRlcm1pbmFsIGZlYXR1cmVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElUZXJtaW5hbENoYXRTZXJ2aWNlIHtcblx0cmVhZG9ubHkgX3NlcnZpY2VCcmFuZDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBGaXJlZCB3aGVuIGEgdGVybWluYWwgaW5zdGFuY2UgaXMgcmVnaXN0ZXJlZCBmb3IgYSB0b29sIHNlc3Npb24gaWQuIFRoaXMgY2FuIGhhcHBlbiBhZnRlclxuXHQgKiB0aGUgY2hhdCBVSSBmaXJzdCByZW5kZXJzLCBlbmFibGluZyBsYXRlIGJpbmRpbmcgb2YgdGhlIGZvY3VzIGFjdGlvbi5cblx0ICovXG5cdHJlYWRvbmx5IG9uRGlkUmVnaXN0ZXJUZXJtaW5hbEluc3RhbmNlV2l0aFRvb2xTZXNzaW9uOiBFdmVudDxJVGVybWluYWxJbnN0YW5jZT47XG5cblx0LyoqXG5cdCAqIEFzc29jaWF0ZSBhIHRvb2wgc2Vzc2lvbiBpZCB3aXRoIGEgdGVybWluYWwgaW5zdGFuY2UuIFRoZSBhc3NvY2lhdGlvbiBpcyBhdXRvbWF0aWNhbGx5XG5cdCAqIGNsZWFyZWQgd2hlbiB0aGUgaW5zdGFuY2UgaXMgZGlzcG9zZWQuXG5cdCAqL1xuXHRyZWdpc3RlclRlcm1pbmFsSW5zdGFuY2VXaXRoVG9vbFNlc3Npb24odGVybWluYWxUb29sU2Vzc2lvbklkOiBzdHJpbmcgfCB1bmRlZmluZWQsIGluc3RhbmNlOiBJVGVybWluYWxJbnN0YW5jZSk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlc29sdmUgYSB0ZXJtaW5hbCBpbnN0YW5jZSBieSBpdHMgdG9vbCBzZXNzaW9uIGlkLlxuXHQgKiBAcGFyYW0gdGVybWluYWxUb29sU2Vzc2lvbklkIFRoZSB0b29sIHNlc3Npb24gaWQgcHJvdmlkZWQgaW4gdG9vbFNwZWNpZmljRGF0YS5cblx0ICogSWYgbm8gdG9vbCBzZXNzaW9uIElEIGlzIHByb3ZpZGVkLCB3ZSBkbyBub3RoaW5nLlxuXHQgKi9cblx0Z2V0VGVybWluYWxJbnN0YW5jZUJ5VG9vbFNlc3Npb25JZCh0ZXJtaW5hbFRvb2xTZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8SVRlcm1pbmFsSW5zdGFuY2UgfCB1bmRlZmluZWQ+O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHRlcm1pbmFsIGluc3RhbmNlcyB0aGF0IGhhdmUgYmVlbiByZWdpc3RlcmVkIHdpdGggYSB0b29sIHNlc3Npb24gaWQuXG5cdCAqIFRoaXMgaXMgdXNlZCBmb3Igc3VyZmFjaW5nIHRvb2wtZHJpdmVuL2JhY2tncm91bmQgdGVybWluYWxzIGluIFVJIChlZy4gcXVpY2sgcGlja3MpLlxuXHQgKi9cblx0Z2V0VG9vbFNlc3Npb25UZXJtaW5hbEluc3RhbmNlcyhoaWRkZW5Pbmx5PzogYm9vbGVhbik6IHJlYWRvbmx5IElUZXJtaW5hbEluc3RhbmNlW107XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRvb2wgc2Vzc2lvbiBJRCBmb3IgYSBnaXZlbiB0ZXJtaW5hbCBpbnN0YW5jZSwgaWYgaXQgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cblx0ICogQHBhcmFtIGluc3RhbmNlIFRoZSB0ZXJtaW5hbCBpbnN0YW5jZSB0byBsb29rIHVwXG5cdCAqIEByZXR1cm5zIFRoZSB0b29sIHNlc3Npb24gSUQgaWYgZm91bmQsIHVuZGVmaW5lZCBvdGhlcndpc2Vcblx0ICovXG5cdGdldFRvb2xTZXNzaW9uSWRGb3JJbnN0YW5jZShpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2UpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEFzc29jaWF0ZSBhIGNoYXQgc2Vzc2lvbiBJRCB3aXRoIGEgdGVybWluYWwgaW5zdGFuY2UuIFRoaXMgaXMgdXNlZCB0byByZXRyaWV2ZSB0aGUgY2hhdFxuXHQgKiBzZXNzaW9uIHRpdGxlIGZvciBkaXNwbGF5IHB1cnBvc2VzLlxuXHQgKiBAcGFyYW0gY2hhdFNlc3Npb25JZCBUaGUgY2hhdCBzZXNzaW9uIElEXG5cdCAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgdGVybWluYWwgaW5zdGFuY2Vcblx0ICovXG5cdHJlZ2lzdGVyVGVybWluYWxJbnN0YW5jZVdpdGhDaGF0U2Vzc2lvbihjaGF0U2Vzc2lvbklkOiBzdHJpbmcsIGluc3RhbmNlOiBJVGVybWluYWxJbnN0YW5jZSk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNoYXQgc2Vzc2lvbiBJRCBmb3IgYSBnaXZlbiB0ZXJtaW5hbCBpbnN0YW5jZSwgaWYgaXQgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cblx0ICogQHBhcmFtIGluc3RhbmNlIFRoZSB0ZXJtaW5hbCBpbnN0YW5jZSB0byBsb29rIHVwXG5cdCAqIEByZXR1cm5zIFRoZSBjaGF0IHNlc3Npb24gSUQgaWYgZm91bmQsIHVuZGVmaW5lZCBvdGhlcndpc2Vcblx0ICovXG5cdGdldENoYXRTZXNzaW9uSWRGb3JJbnN0YW5jZShpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2UpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cblx0aXNCYWNrZ3JvdW5kVGVybWluYWwodGVybWluYWxUb29sU2Vzc2lvbklkPzogc3RyaW5nKTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIHNlcnZpY2UgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHRlcm1pbmFsIGVkaXRpbmcgc3RhdGUgYW5kIGZ1bmN0aW9uYWxpdHkuIFRoaXMgaW5jbHVkZXNcbiAqIHRyYWNraW5nIHdoaWNoIHRlcm1pbmFsIGlzIGN1cnJlbnRseSBiZWluZyBlZGl0ZWQgYW5kIG1hbmFnaW5nIGVkaXRhYmxlIGRhdGEgYXNzb2NpYXRlZCB3aXRoXG4gKiB0ZXJtaW5hbCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVRlcm1pbmFsRWRpdGluZ1NlcnZpY2Uge1xuXHRyZWFkb25seSBfc2VydmljZUJyYW5kOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgZWRpdGFibGUgZGF0YSBmb3IgYSB0ZXJtaW5hbCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIGluc3RhbmNlIFRoZSB0ZXJtaW5hbCBpbnN0YW5jZS5cblx0ICogQHJldHVybnMgVGhlIGVkaXRhYmxlIGRhdGEgaWYgdGhlIGluc3RhbmNlIGlzIGVkaXRhYmxlLCB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuXHQgKi9cblx0Z2V0RWRpdGFibGVEYXRhKGluc3RhbmNlOiBJVGVybWluYWxJbnN0YW5jZSk6IElFZGl0YWJsZURhdGEgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZWRpdGFibGUgZGF0YSBmb3IgYSB0ZXJtaW5hbCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIGluc3RhbmNlIFRoZSB0ZXJtaW5hbCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIGRhdGEgVGhlIGVkaXRhYmxlIGRhdGEgdG8gc2V0LCBvciBudWxsIHRvIGNsZWFyLlxuXHQgKi9cblx0c2V0RWRpdGFibGUoaW5zdGFuY2U6IElUZXJtaW5hbEluc3RhbmNlLCBkYXRhOiBJRWRpdGFibGVEYXRhIHwgbnVsbCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGEgdGVybWluYWwgaW5zdGFuY2UgaXMgY3VycmVudGx5IGVkaXRhYmxlLlxuXHQgKiBAcGFyYW0gaW5zdGFuY2UgVGhlIHRlcm1pbmFsIGluc3RhbmNlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBpbnN0YW5jZSBpcyBlZGl0YWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0aXNFZGl0YWJsZShpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2UgfCB1bmRlZmluZWQpOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHRlcm1pbmFsIGluc3RhbmNlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGVkaXRlZC5cblx0ICogQHJldHVybnMgVGhlIHRlcm1pbmFsIGluc3RhbmNlIGJlaW5nIGVkaXRlZCwgb3IgdW5kZWZpbmVkIGlmIG5vbmUuXG5cdCAqL1xuXHRnZXRFZGl0aW5nVGVybWluYWwoKTogSVRlcm1pbmFsSW5zdGFuY2UgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgdGVybWluYWwgaW5zdGFuY2UgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgZWRpdGVkLlxuXHQgKiBAcGFyYW0gaW5zdGFuY2UgVGhlIHRlcm1pbmFsIGluc3RhbmNlIHRvIHNldCBhcyBlZGl0aW5nLCBvciB1bmRlZmluZWQgdG8gY2xlYXIuXG5cdCAqL1xuXHRzZXRFZGl0aW5nVGVybWluYWwoaW5zdGFuY2U6IElUZXJtaW5hbEluc3RhbmNlIHwgdW5kZWZpbmVkKTogdm9pZDtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gRGlyZWN0aW9uIHtcblx0TGVmdCA9IDAsXG5cdFJpZ2h0ID0gMSxcblx0VXAgPSAyLFxuXHREb3duID0gM1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElRdWlja1BpY2tUZXJtaW5hbE9iamVjdCB7XG5cdGNvbmZpZzogSVJlZ2lzdGVyQ29udHJpYnV0ZWRQcm9maWxlQXJncyB8IElUZXJtaW5hbFByb2ZpbGUgfCB7IHByb2ZpbGU6IElFeHRlbnNpb25UZXJtaW5hbFByb2ZpbGU7IG9wdGlvbnM6IHsgaWNvbj86IHN0cmluZzsgY29sb3I/OiBzdHJpbmcgfSB9IHwgdW5kZWZpbmVkO1xuXHRrZXlNb2RzOiBJS2V5TW9kcyB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWFya1RyYWNrZXIge1xuXHRzY3JvbGxUb1ByZXZpb3VzTWFyayhzY3JvbGxQb3NpdGlvbj86IFNjcm9sbFBvc2l0aW9uLCByZXRhaW5TZWxlY3Rpb24/OiBib29sZWFuLCBza2lwRW1wdHlDb21tYW5kcz86IGJvb2xlYW4pOiB2b2lkO1xuXHRzY3JvbGxUb05leHRNYXJrKCk6IHZvaWQ7XG5cdHNlbGVjdFRvUHJldmlvdXNNYXJrKCk6IHZvaWQ7XG5cdHNlbGVjdFRvTmV4dE1hcmsoKTogdm9pZDtcblx0c2VsZWN0VG9QcmV2aW91c0xpbmUoKTogdm9pZDtcblx0c2VsZWN0VG9OZXh0TGluZSgpOiB2b2lkO1xuXHRjbGVhcigpOiB2b2lkO1xuXHRzY3JvbGxUb0Nsb3Nlc3RNYXJrZXIoc3RhcnRNYXJrZXJJZDogc3RyaW5nLCBlbmRNYXJrZXJJZD86IHN0cmluZywgaGlnaGxpZ2h0PzogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IHZvaWQ7XG5cblx0c2Nyb2xsVG9MaW5lKGxpbmU6IG51bWJlciwgcG9zaXRpb246IFNjcm9sbFBvc2l0aW9uKTogdm9pZDtcblx0cmV2ZWFsQ29tbWFuZChjb21tYW5kOiBJVGVybWluYWxDb21tYW5kIHwgSUN1cnJlbnRQYXJ0aWFsQ29tbWFuZCB8IFVSSSwgcG9zaXRpb24/OiBTY3JvbGxQb3NpdGlvbik6IHZvaWQ7XG5cdHJldmVhbFJhbmdlKHJhbmdlOiBJQnVmZmVyUmFuZ2UpOiB2b2lkO1xuXHRyZWdpc3RlclRlbXBvcmFyeURlY29yYXRpb24obWFya2VyOiBJTWFya2VyLCBlbmRNYXJrZXI6IElNYXJrZXIgfCB1bmRlZmluZWQsIHNob3dPdXRsaW5lOiBib29sZWFuKTogdm9pZDtcblx0c2hvd0NvbW1hbmRHdWlkZShjb21tYW5kOiBJVGVybWluYWxDb21tYW5kIHwgdW5kZWZpbmVkKTogdm9pZDtcblxuXHRzYXZlU2Nyb2xsU3RhdGUoKTogdm9pZDtcblx0cmVzdG9yZVNjcm9sbFN0YXRlKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRlcm1pbmFsR3JvdXAge1xuXHRhY3RpdmVJbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2UgfCB1bmRlZmluZWQ7XG5cdHRlcm1pbmFsSW5zdGFuY2VzOiBJVGVybWluYWxJbnN0YW5jZVtdO1xuXHR0aXRsZTogc3RyaW5nO1xuXHRyZWFkb25seSBoYWRGb2N1c09uRXhpdDogYm9vbGVhbjtcblxuXHRyZWFkb25seSBvbkRpZERpc3Bvc2VJbnN0YW5jZTogRXZlbnQ8SVRlcm1pbmFsSW5zdGFuY2U+O1xuXHRyZWFkb25seSBvbkRpc3Bvc2VkOiBFdmVudDxJVGVybWluYWxHcm91cD47XG5cdHJlYWRvbmx5IG9uSW5zdGFuY2VzQ2hhbmdlZDogRXZlbnQ8dm9pZD47XG5cdHJlYWRvbmx5IG9uUGFuZWxPcmllbnRhdGlvbkNoYW5nZWQ6IEV2ZW50PE9yaWVudGF0aW9uPjtcblxuXHRmb2N1c1ByZXZpb3VzUGFuZSgpOiB2b2lkO1xuXHRmb2N1c05leHRQYW5lKCk6IHZvaWQ7XG5cdHJlc2l6ZVBhbmUoZGlyZWN0aW9uOiBEaXJlY3Rpb24pOiB2b2lkO1xuXHRyZXNpemVQYW5lcyhyZWxhdGl2ZVNpemVzOiBudW1iZXJbXSk6IHZvaWQ7XG5cdHNldEFjdGl2ZUluc3RhbmNlQnlJbmRleChpbmRleDogbnVtYmVyLCBmb3JjZT86IGJvb2xlYW4pOiB2b2lkO1xuXHRhdHRhY2hUb0VsZW1lbnQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXHRhZGRJbnN0YW5jZShpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2UpOiB2b2lkO1xuXHRyZW1vdmVJbnN0YW5jZShpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2UpOiB2b2lkO1xuXHRtb3ZlSW5zdGFuY2UoaW5zdGFuY2VzOiBTaW5nbGVPck1hbnk8SVRlcm1pbmFsSW5zdGFuY2U+LCBpbmRleDogbnVtYmVyLCBwb3NpdGlvbjogJ2JlZm9yZScgfCAnYWZ0ZXInKTogdm9pZDtcblx0c2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZDtcblx0bGF5b3V0KHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZDtcblx0YWRkRGlzcG9zYWJsZShkaXNwb3NhYmxlOiBJRGlzcG9zYWJsZSk6IHZvaWQ7XG5cdHNwbGl0KHNoZWxsTGF1bmNoQ29uZmlnOiBJU2hlbGxMYXVuY2hDb25maWcpOiBJVGVybWluYWxJbnN0YW5jZTtcblx0Z2V0TGF5b3V0SW5mbyhpc0FjdGl2ZTogYm9vbGVhbik6IElUZXJtaW5hbFRhYkxheW91dEluZm9CeUlkO1xufVxuXG5leHBvcnQgY29uc3QgZW51bSBUZXJtaW5hbENvbm5lY3Rpb25TdGF0ZSB7XG5cdENvbm5lY3RpbmcsXG5cdENvbm5lY3RlZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEZXRhY2hlZFhUZXJtT3B0aW9ucyB7XG5cdGNvbHM6IG51bWJlcjtcblx0cm93czogbnVtYmVyO1xuXHRjb2xvclByb3ZpZGVyOiBJWHRlcm1Db2xvclByb3ZpZGVyO1xuXHRjYXBhYmlsaXRpZXM/OiBJVGVybWluYWxDYXBhYmlsaXR5U3RvcmU7XG5cdHJlYWRvbmx5PzogYm9vbGVhbjtcblx0cHJvY2Vzc0luZm86IElUZXJtaW5hbFByb2Nlc3NJbmZvO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBpbnRlcmZhY2UgaW1wbGVtZW50ZWQgaW4gYm90aCB0aGUge0BsaW5rIElUZXJtaW5hbEluc3RhbmNlfSAoYW5cbiAqIGludGVyZmFjZSB1c2VkIGZvciB0ZXJtaW5hbHMgYXR0YWNoZWQgdG8gdGhlIHRlcm1pbmFsIHBhbmVsIG9yIGVkaXRvcikgYW5kXG4gKiB7QGxpbmsgSURldGFjaGVkVGVybWluYWxJbnN0YW5jZX0gKGEgdGVybWluYWwgdXNlZCBlbHNld2hlcmUgaW4gVlMgQ29kZSBVSSkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUJhc2VUZXJtaW5hbEluc3RhbmNlIHtcblx0cmVhZG9ubHkgY2FwYWJpbGl0aWVzOiBJVGVybWluYWxDYXBhYmlsaXR5U3RvcmU7XG5cblx0LyoqXG5cdCAqIERPTSBlbGVtZW50IHRoZSB0ZXJtaW5hbCBpcyBtb3VudGVkIGluLlxuXHQgKi9cblx0cmVhZG9ubHkgZG9tRWxlbWVudD86IEhUTUxFbGVtZW50O1xuXG5cdC8qKlxuXHQgKiBDdXJyZW50IHNlbGVjdGlvbiBpbiB0aGUgdGVybWluYWwuXG5cdCAqL1xuXHRyZWFkb25seSBzZWxlY3Rpb246IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgYW55dGhpbmcgaXMgc2VsZWN0ZWQgaW4gdGVybWluYWwuXG5cdCAqL1xuXHRoYXNTZWxlY3Rpb24oKTogYm9vbGVhbjtcblxuXHQvKipcblx0ICogQ2xlYXIgY3VycmVudCBzZWxlY3Rpb24uXG5cdCAqL1xuXHRjbGVhclNlbGVjdGlvbigpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBGb2N1c2VzIHRoZSB0ZXJtaW5hbCBpbnN0YW5jZSBpZiBpdCdzIGFibGUgdG8gKHRoZSB4dGVybS5qcyBpbnN0YW5jZSBtdXN0IGV4aXN0KS5cblx0ICpcblx0ICogQHBhcmFtIGZvcmNlIEZvcmNlIGZvY3VzIGV2ZW4gaWYgdGhlcmUgaXMgYSBzZWxlY3Rpb24uXG5cdCAqL1xuXHRmb2N1cyhmb3JjZT86IGJvb2xlYW4pOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBGb3JjZSB0aGUgc2Nyb2xsIGJhciB0byBiZSB2aXNpYmxlIHVudGlsIHtAbGluayByZXNldFNjcm9sbGJhclZpc2liaWxpdHl9IGlzIGNhbGxlZC5cblx0ICovXG5cdGZvcmNlU2Nyb2xsYmFyVmlzaWJpbGl0eSgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIHNjcm9sbCBiYXIgdG8gb25seSBiZSB2aXNpYmxlIHdoZW4gbmVlZGVkLCB0aGlzIGRvZXMgbm90aGluZyB1bmxlc3Ncblx0ICoge0BsaW5rIGZvcmNlU2Nyb2xsYmFyVmlzaWJpbGl0eX0gd2FzIGNhbGxlZC5cblx0ICovXG5cdHJlc2V0U2Nyb2xsYmFyVmlzaWJpbGl0eSgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBHZXRzIGEgdGVybWluYWwgY29udHJpYnV0aW9uIGJ5IGl0cyBJRC5cblx0ICovXG5cdGdldENvbnRyaWJ1dGlvbjxUIGV4dGVuZHMgSVRlcm1pbmFsQ29udHJpYnV0aW9uPihpZDogc3RyaW5nKTogVCB8IG51bGw7XG59XG5cbi8qKlxuICogQSB7QGxpbmsgSVRlcm1pbmFsSW5zdGFuY2V9LWxpa2Ugb2JqZWN0IHRoYXQgZW11bGF0ZXMgYSBzdWJzZXQgb2ZcbiAqIGNhcGFiaWxpdGllcy4gVGhpcyBpbnN0YW5jZSBpcyByZXR1cm5lZCBmcm9tIHtAbGluayBJVGVybWluYWxTZXJ2aWNlLmNyZWF0ZURldGFjaGVkVGVybWluYWx9XG4gKiB0byByZXByZXNlbnQgdGVybWluYWxzIHRoYXQgYXBwZWFyIGluIG90aGVyIHBhcnRzIG9mIHRoZSBWUyBDb2RlIFVJIG91dHNpZGVcbiAqIG9mIHRoZSBcIlRlcm1pbmFsXCIgdmlldyBvciBlZGl0b3JzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElEZXRhY2hlZFRlcm1pbmFsSW5zdGFuY2UgZXh0ZW5kcyBJRGlzcG9zYWJsZSwgSUJhc2VUZXJtaW5hbEluc3RhbmNlIHtcblx0cmVhZG9ubHkgeHRlcm06IElEZXRhY2hlZFh0ZXJtVGVybWluYWw7XG5cblx0LyoqXG5cdCAqIEF0dGFjaGVkIHRoZSB0ZXJtaW5hbCB0byB0aGUgZ2l2ZW4gZWxlbWVudC4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIG92ZXJcblx0ICogY2FsbGluZyB7QGxpbmsgSVh0ZXJtVGVybWluYWwuYXR0YWNoVG9FbGVtZW50fSBzbyB0aGF0IGV4dHJhIERPTSBlbGVtZW50c1xuXHQgKiBmb3IgY29udHJpYnV0aW9ucyBhcmUgaW5pdGlhbGl6ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSBjb250YWluZXIgQ29udGFpbmVyIHRoZSB0ZXJtaW5hbCB3aWxsIGJlIHJlbmRlcmVkIGluXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbW91bnRpbmcgdGhlIHRlcm1pbmFsIGluIGFuIGVsZW1lbnRcblx0ICovXG5cdGF0dGFjaFRvRWxlbWVudChjb250YWluZXI6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogUGFydGlhbDxJWHRlcm1BdHRhY2hUb0VsZW1lbnRPcHRpb25zPik6IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBpc0RldGFjaGVkVGVybWluYWxJbnN0YW5jZSA9ICh0OiBJVGVybWluYWxJbnN0YW5jZSB8IElEZXRhY2hlZFRlcm1pbmFsSW5zdGFuY2UpOiB0IGlzIElEZXRhY2hlZFRlcm1pbmFsSW5zdGFuY2UgPT4gdHlwZW9mICh0IGFzIElUZXJtaW5hbEluc3RhbmNlKS5pbnN0YW5jZUlkICE9PSAnbnVtYmVyJztcblxuZXhwb3J0IGludGVyZmFjZSBJVGVybWluYWxTZXJ2aWNlIGV4dGVuZHMgSVRlcm1pbmFsSW5zdGFuY2VIb3N0IHtcblx0cmVhZG9ubHkgX3NlcnZpY2VCcmFuZDogdW5kZWZpbmVkO1xuXG5cdC8qKiBHZXRzIGFsbCB0ZXJtaW5hbCBpbnN0YW5jZXMsIGluY2x1ZGluZyBlZGl0b3IsIHRlcm1pbmFsIHZpZXcgKGdyb3VwKSwgYW5kIGJhY2tncm91bmQgaW5zdGFuY2VzLiAqL1xuXHRyZWFkb25seSBpbnN0YW5jZXM6IHJlYWRvbmx5IElUZXJtaW5hbEluc3RhbmNlW107XG5cblx0cmVhZG9ubHkgZm9yZWdyb3VuZEluc3RhbmNlczogcmVhZG9ubHkgSVRlcm1pbmFsSW5zdGFuY2VbXTtcblxuXHQvKiogR2V0cyBkZXRhY2hlZCB0ZXJtaW5hbCBpbnN0YW5jZXMgY3JlYXRlZCB2aWEge0BsaW5rIGNyZWF0ZURldGFjaGVkWHRlcm19LiAqL1xuXHRyZWFkb25seSBkZXRhY2hlZEluc3RhbmNlczogSXRlcmFibGU8SURldGFjaGVkVGVybWluYWxJbnN0YW5jZT47XG5cblx0cmVhZG9ubHkgaXNQcm9jZXNzU3VwcG9ydFJlZ2lzdGVyZWQ6IGJvb2xlYW47XG5cdHJlYWRvbmx5IGNvbm5lY3Rpb25TdGF0ZTogVGVybWluYWxDb25uZWN0aW9uU3RhdGU7XG5cdHJlYWRvbmx5IHdoZW5Db25uZWN0ZWQ6IFByb21pc2U8dm9pZD47XG5cdC8qKiBUaGUgbnVtYmVyIG9mIHJlc3RvcmVkIHRlcm1pbmFsIGdyb3VwcyBvbiBzdGFydHVwLiAqL1xuXHRyZWFkb25seSByZXN0b3JlZEdyb3VwQ291bnQ6IG51bWJlcjtcblxuXHRyZWFkb25seSBvbkRpZENyZWF0ZUluc3RhbmNlOiBFdmVudDxJVGVybWluYWxJbnN0YW5jZT47XG5cdHJlYWRvbmx5IG9uRGlkQ2hhbmdlSW5zdGFuY2VEaW1lbnNpb25zOiBFdmVudDxJVGVybWluYWxJbnN0YW5jZT47XG5cdHJlYWRvbmx5IG9uRGlkUmVxdWVzdFN0YXJ0RXh0ZW5zaW9uVGVybWluYWw6IEV2ZW50PElTdGFydEV4dGVuc2lvblRlcm1pbmFsUmVxdWVzdD47XG5cdHJlYWRvbmx5IG9uRGlkUmVnaXN0ZXJQcm9jZXNzU3VwcG9ydDogRXZlbnQ8dm9pZD47XG5cdHJlYWRvbmx5IG9uRGlkQ2hhbmdlQ29ubmVjdGlvblN0YXRlOiBFdmVudDx2b2lkPjtcblxuXHQvLyBHcm91cCBldmVudHNcblx0cmVhZG9ubHkgb25EaWRDaGFuZ2VBY3RpdmVHcm91cDogRXZlbnQ8SVRlcm1pbmFsR3JvdXAgfCB1bmRlZmluZWQ+O1xuXG5cdC8vIE11bHRpcGxleGVkIGV2ZW50c1xuXHRyZWFkb25seSBvbkFueUluc3RhbmNlRGF0YTogRXZlbnQ8eyBpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2U7IGRhdGE6IHN0cmluZyB9Pjtcblx0cmVhZG9ubHkgb25BbnlJbnN0YW5jZURhdGFJbnB1dDogRXZlbnQ8SVRlcm1pbmFsSW5zdGFuY2U+O1xuXHRyZWFkb25seSBvbkFueUluc3RhbmNlSWNvbkNoYW5nZTogRXZlbnQ8eyBpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2U7IHVzZXJJbml0aWF0ZWQ6IGJvb2xlYW4gfT47XG5cdHJlYWRvbmx5IG9uQW55SW5zdGFuY2VNYXhpbXVtRGltZW5zaW9uc0NoYW5nZTogRXZlbnQ8SVRlcm1pbmFsSW5zdGFuY2U+O1xuXHRyZWFkb25seSBvbkFueUluc3RhbmNlUHJpbWFyeVN0YXR1c0NoYW5nZTogRXZlbnQ8SVRlcm1pbmFsSW5zdGFuY2U+O1xuXHRyZWFkb25seSBvbkFueUluc3RhbmNlUHJvY2Vzc0lkUmVhZHk6IEV2ZW50PElUZXJtaW5hbEluc3RhbmNlPjtcblx0cmVhZG9ubHkgb25BbnlJbnN0YW5jZVNlbGVjdGlvbkNoYW5nZTogRXZlbnQ8SVRlcm1pbmFsSW5zdGFuY2U+O1xuXHRyZWFkb25seSBvbkFueUluc3RhbmNlVGl0bGVDaGFuZ2U6IEV2ZW50PElUZXJtaW5hbEluc3RhbmNlPjtcblx0cmVhZG9ubHkgb25BbnlJbnN0YW5jZVNoZWxsVHlwZUNoYW5nZWQ6IEV2ZW50PElUZXJtaW5hbEluc3RhbmNlPjtcblx0cmVhZG9ubHkgb25BbnlJbnN0YW5jZUFkZGVkQ2FwYWJpbGl0eVR5cGU6IEV2ZW50PFRlcm1pbmFsQ2FwYWJpbGl0eT47XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSB0ZXJtaW5hbC5cblx0ICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSB0ZXJtaW5hbCB3aXRoLCB3aGVuIG5vdCBzcGVjaWZpZWQgdGhlIGRlZmF1bHRcblx0ICogcHJvZmlsZSB3aWxsIGJlIHVzZWQgYXQgdGhlIGRlZmF1bHQgdGFyZ2V0LlxuXHQgKi9cblx0Y3JlYXRlVGVybWluYWwob3B0aW9ucz86IElDcmVhdGVUZXJtaW5hbE9wdGlvbnMpOiBQcm9taXNlPElUZXJtaW5hbEluc3RhbmNlPjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbmQgZm9jdXNlcyBhIHRlcm1pbmFsLlxuXHQgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyB0byBjcmVhdGUgdGhlIHRlcm1pbmFsIHdpdGgsIHdoZW4gbm90IHNwZWNpZmllZCB0aGUgZGVmYXVsdFxuXHQgKiBwcm9maWxlIHdpbGwgYmUgdXNlZCBhdCB0aGUgZGVmYXVsdCB0YXJnZXQuXG5cdCAqL1xuXHRjcmVhdGVBbmRGb2N1c1Rlcm1pbmFsKG9wdGlvbnM/OiBJQ3JlYXRlVGVybWluYWxPcHRpb25zKTogUHJvbWlzZTxJVGVybWluYWxJbnN0YW5jZT47XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBkZXRhY2hlZCB4dGVybSBpbnN0YW5jZSB3aGljaCBpcyBub3QgYXR0YWNoZWQgdG8gdGhlIERPTSBvclxuXHQgKiB0cmFja2VkIGFzIGEgdGVybWluYWwgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbXMgb3B0aW9ucyBUaGUgb3B0aW9ucyB0byBjcmVhdGUgdGhlIHRlcm1pbmFsIHdpdGhcblx0ICovXG5cdGNyZWF0ZURldGFjaGVkVGVybWluYWwob3B0aW9uczogSURldGFjaGVkWFRlcm1PcHRpb25zKTogUHJvbWlzZTxJRGV0YWNoZWRUZXJtaW5hbEluc3RhbmNlPjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHJhdyB0ZXJtaW5hbCBpbnN0YW5jZSwgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgdGVybWluYWwgcGFydC5cblx0ICovXG5cdGdldEluc3RhbmNlRnJvbUlkKHRlcm1pbmFsSWQ6IG51bWJlcik6IElUZXJtaW5hbEluc3RhbmNlIHwgdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBBbiBvd25lciBvZiB0ZXJtaW5hbHMgbWlnaHQgYmUgY3JlYXRlZCBhZnRlciByZWNvbm5lY3Rpb24gaGFzIG9jY3VycmVkLFxuXHQgKiBzbyBzdG9yZSB0aGVtIHRvIGJlIHJlcXVlc3RlZC9hZG9wdGVkIGxhdGVyXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgb25EaWRSZWNvbm5lY3RUb1Nlc3Npb259XG5cdCAqL1xuXHRnZXRSZWNvbm5lY3RlZFRlcm1pbmFscyhyZWNvbm5lY3Rpb25Pd25lcjogc3RyaW5nKTogSVRlcm1pbmFsSW5zdGFuY2VbXSB8IHVuZGVmaW5lZDtcblxuXHRnZXRBY3RpdmVPckNyZWF0ZUluc3RhbmNlKG9wdGlvbnM/OiB7IGFjY2VwdHNJbnB1dD86IGJvb2xlYW4gfSk6IFByb21pc2U8SVRlcm1pbmFsSW5zdGFuY2U+O1xuXHRyZXZlYWxUZXJtaW5hbChzb3VyY2U6IElUZXJtaW5hbEluc3RhbmNlLCBwcmVzZXJ2ZUZvY3VzPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD47XG5cdC8qKlxuXHQgKiBAcGFyYW0gaW5zdGFuY2Vcblx0ICogQHBhcmFtIHN1cHByZXNzU2V0QWN0aXZlIERvIG5vdCBzZXQgdGhlIGFjdGl2ZSBpbnN0YW5jZSB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRlcm1pbmFsXG5cdCAqIEBwYXJhbSBmb3JjZVNhdmVTdGF0ZSBVc2VkIHdoZW4gdGhlIHdpbmRvdyBpcyBzaHV0dGluZyBkb3duIGFuZCB3ZSBuZWVkIHRvIHJldmVhbCBhbmQgc2F2ZSBoaWRlRnJvbVVzZXIgdGVybWluYWxzXG5cdCAqL1xuXHRzaG93QmFja2dyb3VuZFRlcm1pbmFsKGluc3RhbmNlOiBJVGVybWluYWxJbnN0YW5jZSwgc3VwcHJlc3NTZXRBY3RpdmU/OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPjtcblx0cmV2ZWFsQWN0aXZlVGVybWluYWwocHJlc2VydmVGb2N1cz86IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXHRtb3ZlVG9FZGl0b3Ioc291cmNlOiBJVGVybWluYWxJbnN0YW5jZSwgZ3JvdXA/OiBHcm91cElkZW50aWZpZXIgfCBTSURFX0dST1VQX1RZUEUgfCBBQ1RJVkVfR1JPVVBfVFlQRSB8IEFVWF9XSU5ET1dfR1JPVVBfVFlQRSk6IHZvaWQ7XG5cdG1vdmVJbnRvTmV3RWRpdG9yKHNvdXJjZTogSVRlcm1pbmFsSW5zdGFuY2UpOiB2b2lkO1xuXHRtb3ZlVG9UZXJtaW5hbFZpZXcoc291cmNlOiBJVGVybWluYWxJbnN0YW5jZSB8IFVSSSk6IFByb21pc2U8dm9pZD47XG5cdGdldFByaW1hcnlCYWNrZW5kKCk6IElUZXJtaW5hbEJhY2tlbmQgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEZpcmUgdGhlIG9uQWN0aXZlVGFiQ2hhbmdlZCBldmVudCwgdGhpcyB3aWxsIHRyaWdnZXIgdGhlIHRlcm1pbmFsIGRyb3Bkb3duIHRvIGJlIHVwZGF0ZWQsXG5cdCAqIGFtb25nIG90aGVyIHRoaW5ncy5cblx0ICovXG5cdHJlZnJlc2hBY3RpdmVHcm91cCgpOiB2b2lkO1xuXG5cdHJlZ2lzdGVyUHJvY2Vzc1N1cHBvcnQoaXNTdXBwb3J0ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuXG5cdHNob3dQcm9maWxlUXVpY2tQaWNrKHR5cGU6ICdzZXREZWZhdWx0JyB8ICdjcmVhdGVJbnN0YW5jZScsIGN3ZD86IHN0cmluZyB8IFVSSSk6IFByb21pc2U8SVRlcm1pbmFsSW5zdGFuY2UgfCB1bmRlZmluZWQ+O1xuXG5cdHNldENvbnRhaW5lcnMocGFuZWxDb250YWluZXI6IEhUTUxFbGVtZW50LCB0ZXJtaW5hbENvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXG5cdHJlcXVlc3RTdGFydEV4dGVuc2lvblRlcm1pbmFsKHByb3h5OiBJVGVybWluYWxQcm9jZXNzRXh0SG9zdFByb3h5LCBjb2xzOiBudW1iZXIsIHJvd3M6IG51bWJlcik6IFByb21pc2U8SVRlcm1pbmFsTGF1bmNoRXJyb3IgfCB1bmRlZmluZWQ+O1xuXHRpc0F0dGFjaGVkVG9UZXJtaW5hbChyZW1vdGVUZXJtOiBJUmVtb3RlVGVybWluYWxBdHRhY2hUYXJnZXQpOiBib29sZWFuO1xuXHRzYWZlRGlzcG9zZVRlcm1pbmFsKGluc3RhbmNlOiBJVGVybWluYWxJbnN0YW5jZSk6IFByb21pc2U8dm9pZD47XG5cblx0Z2V0RGVmYXVsdEluc3RhbmNlSG9zdCgpOiBJVGVybWluYWxJbnN0YW5jZUhvc3Q7XG5cdGdldEluc3RhbmNlSG9zdCh0YXJnZXQ6IElUZXJtaW5hbExvY2F0aW9uT3B0aW9ucyB8IHVuZGVmaW5lZCk6IFByb21pc2U8SVRlcm1pbmFsSW5zdGFuY2VIb3N0PjtcblxuXHRyZXNvbHZlTG9jYXRpb24obG9jYXRpb24/OiBJVGVybWluYWxMb2NhdGlvbk9wdGlvbnMpOiBQcm9taXNlPFRlcm1pbmFsTG9jYXRpb24gfCB1bmRlZmluZWQ+O1xuXHRzZXROYXRpdmVEZWxlZ2F0ZShuYXRpdmVDYWxsczogSVRlcm1pbmFsU2VydmljZU5hdGl2ZURlbGVnYXRlKTogdm9pZDtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBldmVudCBsaXN0ZW5lciB0aGF0IGxpc3RlbnMgdG8gYWxsIGluc3RhbmNlcywgZHluYW1pY2FsbHkgYWRkaW5nIG5ld1xuXHQgKiBpbnN0YW5jZXMgYW5kIHJlbW92aW5nIG9sZCBpbnN0YW5jZXMgYXMgbmVlZGVkLlxuXHQgKiBAcGFyYW0gZ2V0RXZlbnQgTWFwcyB0aGUgaW5zdGFuY2UgdG8gdGhlIGV2ZW50LlxuXHQgKi9cblx0Y3JlYXRlT25JbnN0YW5jZUV2ZW50PFQ+KGdldEV2ZW50OiAoaW5zdGFuY2U6IElUZXJtaW5hbEluc3RhbmNlKSA9PiBFdmVudDxUPik6IER5bmFtaWNMaXN0RXZlbnRNdWx0aXBsZXhlcjxJVGVybWluYWxJbnN0YW5jZSwgVD47XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBjYXBhYmlsaXR5IGV2ZW50IGxpc3RlbmVyIHRoYXQgbGlzdGVucyB0byBjYXBhYmlsaXRpZXMgb24gYWxsIGluc3RhbmNlcyxcblx0ICogZHluYW1pY2FsbHkgYWRkaW5nIGFuZCByZW1vdmluZyBpbnN0YW5jZXMgYW5kIGNhcGFiaWxpdGllcyBhcyBuZWVkZWQuXG5cdCAqIEBwYXJhbSBjYXBhYmlsaXR5SWQgVGhlIGNhcGFiaWxpdHkgdHlwZSB0byBsaXN0ZW4gdG8gYW4gZXZlbnQgb24uXG5cdCAqIEBwYXJhbSBnZXRFdmVudCBNYXBzIHRoZSBjYXBhYmlsaXR5IHRvIHRoZSBldmVudC5cblx0ICovXG5cdGNyZWF0ZU9uSW5zdGFuY2VDYXBhYmlsaXR5RXZlbnQ8VCBleHRlbmRzIFRlcm1pbmFsQ2FwYWJpbGl0eSwgSz4oY2FwYWJpbGl0eUlkOiBULCBnZXRFdmVudDogKGNhcGFiaWxpdHk6IElUZXJtaW5hbENhcGFiaWxpdHlJbXBsTWFwW1RdKSA9PiBFdmVudDxLPik6IElEeW5hbWljTGlzdEV2ZW50TXVsdGlwbGV4ZXI8eyBpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2U7IGRhdGE6IEsgfT47XG5cblx0LyoqXG5cdCAqIFJldmVhbHMgdGhlIHRlcm1pbmFsIGFuZCwgaWYgcHJvdmlkZWQsIHNjcm9sbHMgdG8gdGhlIGNvbW1hbmQgbWFyay5cblx0ICogQHBhcmFtIHJlc291cmNlIHRoZSB0ZXJtaW5hbCByZXNvdXJjZVxuXHQgKi9cblx0b3BlblJlc291cmNlKHJlc291cmNlOiBVUkkpOiB2b2lkO1xufVxuXG4vKipcbiAqIEEgc2VydmljZSB0aGF0IHByb3ZpZGVzIGNvbnZlbmllbnQgYWNjZXNzIHRvIHRoZSB0ZXJtaW5hbCBjb25maWd1cmF0aW9uIGFuZCBkZXJpdmVkIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJVGVybWluYWxDb25maWd1cmF0aW9uU2VydmljZSB7XG5cdHJlYWRvbmx5IF9zZXJ2aWNlQnJhbmQ6IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQSB0eXBlZCBhbmQgcGFydGlhbGx5IHZhbGlkYXRlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGVybWluYWwgY29uZmlndXJhdGlvbi5cblx0ICovXG5cdHJlYWRvbmx5IGNvbmZpZzogUmVhZG9ubHk8SVRlcm1pbmFsQ29uZmlndXJhdGlvbj47XG5cblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0IGxvY2F0aW9uIGZvciB0ZXJtaW5hbHMuXG5cdCAqL1xuXHRyZWFkb25seSBkZWZhdWx0TG9jYXRpb246IFRlcm1pbmFsTG9jYXRpb247XG5cblx0LyoqXG5cdCAqIEZpcmVzIHdoZW4gc29tZXRoaW5nIHdpdGhpbiB0aGUgdGVybWluYWwgY29uZmlndXJhdGlvbiBjaGFuZ2VzLlxuXHQgKi9cblx0cmVhZG9ubHkgb25Db25maWdDaGFuZ2VkOiBFdmVudDx2b2lkPjtcblxuXHRzZXRQYW5lbENvbnRhaW5lcihwYW5lbENvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXHRjb25maWdGb250SXNNb25vc3BhY2UoKTogYm9vbGVhbjtcblx0Z2V0Rm9udCh3OiBXaW5kb3csIHh0ZXJtQ29yZT86IElYdGVybUNvcmUsIGV4Y2x1ZGVEaW1lbnNpb25zPzogYm9vbGVhbik6IElUZXJtaW5hbEZvbnQ7XG59XG5cbmV4cG9ydCBjbGFzcyBUZXJtaW5hbExpbmtRdWlja1BpY2tFdmVudCBleHRlbmRzIE1vdXNlRXZlbnQge1xuXG59XG5leHBvcnQgaW50ZXJmYWNlIElUZXJtaW5hbFNlcnZpY2VOYXRpdmVEZWxlZ2F0ZSB7XG5cdGdldFdpbmRvd0NvdW50KCk6IFByb21pc2U8bnVtYmVyPjtcbn1cblxuLyoqXG4gKiBUaGlzIHNlcnZpY2UgaXMgcmVzcG9uc2libGUgZm9yIGludGVncmF0aW5nIHdpdGggdGhlIGVkaXRvciBzZXJ2aWNlIGFuZCBtYW5hZ2luZyB0ZXJtaW5hbFxuICogZWRpdG9ycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJVGVybWluYWxFZGl0b3JTZXJ2aWNlIGV4dGVuZHMgSVRlcm1pbmFsSW5zdGFuY2VIb3N0IHtcblx0cmVhZG9ubHkgX3NlcnZpY2VCcmFuZDogdW5kZWZpbmVkO1xuXG5cdC8qKiBHZXRzIGFsbCBfdGVybWluYWwgZWRpdG9yXyBpbnN0YW5jZXMuICovXG5cdHJlYWRvbmx5IGluc3RhbmNlczogcmVhZG9ubHkgSVRlcm1pbmFsSW5zdGFuY2VbXTtcblxuXHRvcGVuRWRpdG9yKGluc3RhbmNlOiBJVGVybWluYWxJbnN0YW5jZSwgZWRpdG9yT3B0aW9ucz86IFRlcm1pbmFsRWRpdG9yTG9jYXRpb24pOiBQcm9taXNlPHZvaWQ+O1xuXHRkZXRhY2hJbnN0YW5jZShpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2UpOiB2b2lkO1xuXHRzcGxpdEluc3RhbmNlKGluc3RhbmNlVG9TcGxpdDogSVRlcm1pbmFsSW5zdGFuY2UsIHNoZWxsTGF1bmNoQ29uZmlnPzogSVNoZWxsTGF1bmNoQ29uZmlnKTogSVRlcm1pbmFsSW5zdGFuY2U7XG5cdHJldmVhbEFjdGl2ZUVkaXRvcihwcmVzZXJ2ZUZvY3VzPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD47XG5cdHJlc29sdmVSZXNvdXJjZShpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2UpOiBVUkk7XG5cdHJldml2ZUlucHV0KGRlc2VyaWFsaXplZElucHV0OiBJRGVzZXJpYWxpemVkVGVybWluYWxFZGl0b3JJbnB1dCk6IEVkaXRvcklucHV0O1xuXHRnZXRJbnB1dEZyb21SZXNvdXJjZShyZXNvdXJjZTogVVJJKTogVGVybWluYWxFZGl0b3JJbnB1dDtcbn1cblxuZXhwb3J0IGNvbnN0IHRlcm1pbmFsRWRpdG9ySWQgPSAndGVybWluYWxFZGl0b3InO1xuXG5pbnRlcmZhY2UgSVRlcm1pbmFsRWRpdG9ySW5wdXRPYmplY3Qge1xuXHRyZWFkb25seSBpZDogbnVtYmVyO1xuXHRyZWFkb25seSBwaWQ6IG51bWJlcjtcblx0cmVhZG9ubHkgdGl0bGU6IHN0cmluZztcblx0cmVhZG9ubHkgdGl0bGVTb3VyY2U6IFRpdGxlRXZlbnRTb3VyY2U7XG5cdHJlYWRvbmx5IGN3ZDogc3RyaW5nO1xuXHRyZWFkb25seSBpY29uOiBUZXJtaW5hbEljb24gfCB1bmRlZmluZWQ7XG5cdHJlYWRvbmx5IGNvbG9yOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cdHJlYWRvbmx5IGhhc0NoaWxkUHJvY2Vzc2VzPzogYm9vbGVhbjtcblx0cmVhZG9ubHkgdHlwZT86IFRlcm1pbmFsVHlwZTtcblx0cmVhZG9ubHkgaXNGZWF0dXJlVGVybWluYWw/OiBib29sZWFuO1xuXHRyZWFkb25seSBoaWRlRnJvbVVzZXI/OiBib29sZWFuO1xuXHRyZWFkb25seSByZWNvbm5lY3Rpb25Qcm9wZXJ0aWVzPzogSVJlY29ubmVjdGlvblByb3BlcnRpZXM7XG5cdHJlYWRvbmx5IHNoZWxsSW50ZWdyYXRpb25Ob25jZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElTZXJpYWxpemVkVGVybWluYWxFZGl0b3JJbnB1dCBleHRlbmRzIElUZXJtaW5hbEVkaXRvcklucHV0T2JqZWN0IHtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRGVzZXJpYWxpemVkVGVybWluYWxFZGl0b3JJbnB1dCBleHRlbmRzIElUZXJtaW5hbEVkaXRvcklucHV0T2JqZWN0IHtcbn1cblxuZXhwb3J0IHR5cGUgSVRlcm1pbmFsTG9jYXRpb25PcHRpb25zID0gVGVybWluYWxMb2NhdGlvbiB8IFRlcm1pbmFsRWRpdG9yTG9jYXRpb24gfCB7IHBhcmVudFRlcm1pbmFsOiBNYXliZVByb21pc2U8SVRlcm1pbmFsSW5zdGFuY2U+IH0gfCB7IHNwbGl0QWN0aXZlVGVybWluYWw6IGJvb2xlYW4gfTtcblxuZXhwb3J0IGludGVyZmFjZSBJQ3JlYXRlVGVybWluYWxPcHRpb25zIHtcblx0LyoqXG5cdCAqIFRoZSBzaGVsbCBsYXVuY2ggY29uZmlnIG9yIHByb2ZpbGUgdG8gbGF1bmNoIHdpdGgsIHdoZW4gbm90IHNwZWNpZmllZCB0aGUgZGVmYXVsdCB0ZXJtaW5hbFxuXHQgKiBwcm9maWxlIHdpbGwgYmUgdXNlZC5cblx0ICovXG5cdGNvbmZpZz86IElTaGVsbExhdW5jaENvbmZpZyB8IElUZXJtaW5hbFByb2ZpbGUgfCBJRXh0ZW5zaW9uVGVybWluYWxQcm9maWxlO1xuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkgdG8gc3RhcnQgd2l0aCwgdGhpcyB3aWxsIG92ZXJyaWRlIElTaGVsbExhdW5jaENvbmZpZy5jd2QgaWZcblx0ICogc3BlY2lmaWVkLlxuXHQgKi9cblx0Y3dkPzogc3RyaW5nIHwgVVJJO1xuXHQvKipcblx0ICogVGhlIHRlcm1pbmFsJ3MgcmVzb3VyY2UsIHBhc3NlZCB3aGVuIHRoZSB0ZXJtaW5hbCBoYXMgbW92ZWQgd2luZG93cy5cblx0ICovXG5cdHJlc291cmNlPzogVVJJO1xuXG5cdC8qKlxuXHQgKiBUaGUgdGVybWluYWwncyBsb2NhdGlvbiAoZWRpdG9yIG9yIHBhbmVsKSwgaXQncyB0ZXJtaW5hbCBwYXJlbnQgKHNwbGl0IHRvIHRoZSByaWdodCksIG9yIGVkaXRvciBncm91cFxuXHQgKi9cblx0bG9jYXRpb24/OiBJVGVybWluYWxMb2NhdGlvbk9wdGlvbnM7XG5cblx0LyoqXG5cdCAqIFRoaXMgdGVybWluYWwgd2lsbCBub3Qgd2FpdCBmb3IgY29udHJpYnV0ZWQgcHJvZmlsZXMgdG8gcmVzb2x2ZSB3aGljaCBtZWFucyBpdCB3aWxsIHByb2NlZWRcblx0ICogd2hlbiB0aGUgd29ya2JlbmNoIGlzIG5vdCB5ZXQgbG9hZGVkLlxuXHQgKi9cblx0c2tpcENvbnRyaWJ1dGVkUHJvZmlsZUNoZWNrPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZXJtaW5hbEVkaXRvckxvY2F0aW9uIHtcblx0dmlld0NvbHVtbjogR3JvdXBJZGVudGlmaWVyIHwgU0lERV9HUk9VUF9UWVBFIHwgQUNUSVZFX0dST1VQX1RZUEUgfCBBVVhfV0lORE9XX0dST1VQX1RZUEU7XG5cdHByZXNlcnZlRm9jdXM/OiBib29sZWFuO1xuXHRhdXhpbGlhcnk/OiBJRWRpdG9yT3B0aW9uc1snYXV4aWxpYXJ5J107XG59XG5cbi8qKlxuICogVGhpcyBzZXJ2aWNlIGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB0ZXJtaW5hbCBncm91cHMsIHRoYXQgaXMgdGhlIHRlcm1pbmFscyB0aGF0IGFyZSBob3N0ZWRcbiAqIHdpdGhpbiB0aGUgdGVybWluYWwgcGFuZWwsIG5vdCBpbiBhbiBlZGl0b3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVRlcm1pbmFsR3JvdXBTZXJ2aWNlIGV4dGVuZHMgSVRlcm1pbmFsSW5zdGFuY2VIb3N0IHtcblx0cmVhZG9ubHkgX3NlcnZpY2VCcmFuZDogdW5kZWZpbmVkO1xuXG5cdC8qKiBHZXRzIGFsbCBfdGVybWluYWwgdmlld18gaW5zdGFuY2VzLCBpZS4gaW5zdGFuY2VzIGNvbnRhaW5lZCB3aXRoaW4gdGVybWluYWwgZ3JvdXBzLiAqL1xuXHRyZWFkb25seSBpbnN0YW5jZXM6IHJlYWRvbmx5IElUZXJtaW5hbEluc3RhbmNlW107XG5cdHJlYWRvbmx5IGdyb3VwczogcmVhZG9ubHkgSVRlcm1pbmFsR3JvdXBbXTtcblx0YWN0aXZlR3JvdXA6IElUZXJtaW5hbEdyb3VwIHwgdW5kZWZpbmVkO1xuXHRyZWFkb25seSBhY3RpdmVHcm91cEluZGV4OiBudW1iZXI7XG5cdC8qKlxuXHQgKiBHZXRzIG9yIHNldHMgdGhlIGxhc3QgYWNjZXNzZWQgbWVudSwgdGhpcyBpcyB1c2VkIHRvIHNlbGVjdCB0aGUgaW5zdGFuY2UocykgZm9yIG1lbnUgYWN0aW9ucy5cblx0ICovXG5cdGxhc3RBY2Nlc3NlZE1lbnU6ICdpbmxpbmUtdGFiJyB8ICd0YWItbGlzdCc7XG5cblx0cmVhZG9ubHkgb25EaWRDaGFuZ2VBY3RpdmVHcm91cDogRXZlbnQ8SVRlcm1pbmFsR3JvdXAgfCB1bmRlZmluZWQ+O1xuXHRyZWFkb25seSBvbkRpZERpc3Bvc2VHcm91cDogRXZlbnQ8SVRlcm1pbmFsR3JvdXA+O1xuXHQvKiogRmlyZXMgd2hlbiBhIGdyb3VwIGlzIGNyZWF0ZWQsIGRpc3Bvc2VkIG9mLCBvciBzaG93biAoaW4gdGhlIGNhc2Ugb2YgYSBiYWNrZ3JvdW5kIGdyb3VwKS4gKi9cblx0cmVhZG9ubHkgb25EaWRDaGFuZ2VHcm91cHM6IEV2ZW50PHZvaWQ+O1xuXHQvKiogRmlyZXMgd2hlbiB0aGUgcGFuZWwgaGFzIGJlZW4gc2hvd24gYW5kIGV4cGFuZGVkLCBzbyBoYXMgbm9uLXplcm8gZGltZW5zaW9ucy4gKi9cblx0cmVhZG9ubHkgb25EaWRTaG93OiBFdmVudDx2b2lkPjtcblx0cmVhZG9ubHkgb25EaWRDaGFuZ2VQYW5lbE9yaWVudGF0aW9uOiBFdmVudDxPcmllbnRhdGlvbj47XG5cblx0Y3JlYXRlR3JvdXAoc2hlbGxMYXVuY2hDb25maWc/OiBJU2hlbGxMYXVuY2hDb25maWcpOiBJVGVybWluYWxHcm91cDtcblx0Y3JlYXRlR3JvdXAoaW5zdGFuY2U/OiBJVGVybWluYWxJbnN0YW5jZSk6IElUZXJtaW5hbEdyb3VwO1xuXHRnZXRHcm91cEZvckluc3RhbmNlKGluc3RhbmNlOiBJVGVybWluYWxJbnN0YW5jZSk6IElUZXJtaW5hbEdyb3VwIHwgdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBNb3ZlcyBhIHRlcm1pbmFsIGluc3RhbmNlJ3MgZ3JvdXAgdG8gdGhlIHRhcmdldCBpbnN0YW5jZSBncm91cCdzIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2UgaW5zdGFuY2UgdG8gbW92ZS5cblx0ICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IGluc3RhbmNlIHRvIG1vdmUgdGhlIHNvdXJjZSBpbnN0YW5jZSB0by5cblx0ICovXG5cdG1vdmVHcm91cChzb3VyY2U6IFNpbmdsZU9yTWFueTxJVGVybWluYWxJbnN0YW5jZT4sIHRhcmdldDogSVRlcm1pbmFsSW5zdGFuY2UpOiB2b2lkO1xuXHRtb3ZlR3JvdXBUb0VuZChzb3VyY2U6IFNpbmdsZU9yTWFueTxJVGVybWluYWxJbnN0YW5jZT4pOiB2b2lkO1xuXG5cdG1vdmVJbnN0YW5jZShzb3VyY2U6IElUZXJtaW5hbEluc3RhbmNlLCB0YXJnZXQ6IElUZXJtaW5hbEluc3RhbmNlLCBzaWRlOiAnYmVmb3JlJyB8ICdhZnRlcicpOiB2b2lkO1xuXHR1bnNwbGl0SW5zdGFuY2UoaW5zdGFuY2U6IElUZXJtaW5hbEluc3RhbmNlKTogdm9pZDtcblx0am9pbkluc3RhbmNlcyhpbnN0YW5jZXM6IElUZXJtaW5hbEluc3RhbmNlW10pOiB2b2lkO1xuXHRpbnN0YW5jZUlzU3BsaXQoaW5zdGFuY2U6IElUZXJtaW5hbEluc3RhbmNlKTogYm9vbGVhbjtcblxuXHRnZXRHcm91cExhYmVscygpOiBzdHJpbmdbXTtcblx0c2V0QWN0aXZlR3JvdXBCeUluZGV4KGluZGV4OiBudW1iZXIpOiB2b2lkO1xuXHRzZXRBY3RpdmVHcm91cFRvTmV4dCgpOiB2b2lkO1xuXHRzZXRBY3RpdmVHcm91cFRvUHJldmlvdXMoKTogdm9pZDtcblxuXHRzZXRBY3RpdmVJbnN0YW5jZUJ5SW5kZXgodGVybWluYWxJbmRleDogbnVtYmVyKTogdm9pZDtcblxuXHRzZXRDb250YWluZXIoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IHZvaWQ7XG5cblx0c2hvd1BhbmVsKGZvY3VzPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD47XG5cdGhpZGVQYW5lbCgpOiB2b2lkO1xuXHRmb2N1c1RhYnMoKTogdm9pZDtcblx0Zm9jdXNIb3ZlcigpOiB2b2lkO1xuXHR1cGRhdGVWaXNpYmlsaXR5KCk6IHZvaWQ7XG59XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHRoYXQgaW5kaWNhdGVzIHRoZSBpbXBsZW1lbnRlciBob3N0cyB0ZXJtaW5hbCBpbnN0YW5jZXMsIGV4cG9zaW5nIGEgY29tbW9uIHNldCBvZlxuICogcHJvcGVydGllcyBhbmQgZXZlbnRzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElUZXJtaW5hbEluc3RhbmNlSG9zdCB7XG5cdHJlYWRvbmx5IGFjdGl2ZUluc3RhbmNlOiBJVGVybWluYWxJbnN0YW5jZSB8IHVuZGVmaW5lZDtcblx0cmVhZG9ubHkgaW5zdGFuY2VzOiByZWFkb25seSBJVGVybWluYWxJbnN0YW5jZVtdO1xuXG5cdHJlYWRvbmx5IG9uRGlkRGlzcG9zZUluc3RhbmNlOiBFdmVudDxJVGVybWluYWxJbnN0YW5jZT47XG5cdHJlYWRvbmx5IG9uRGlkRm9jdXNJbnN0YW5jZTogRXZlbnQ8SVRlcm1pbmFsSW5zdGFuY2U+O1xuXHRyZWFkb25seSBvbkRpZENoYW5nZUFjdGl2ZUluc3RhbmNlOiBFdmVudDxJVGVybWluYWxJbnN0YW5jZSB8IHVuZGVmaW5lZD47XG5cdHJlYWRvbmx5IG9uRGlkQ2hhbmdlSW5zdGFuY2VzOiBFdmVudDx2b2lkPjtcblx0cmVhZG9ubHkgb25EaWRDaGFuZ2VJbnN0YW5jZUNhcGFiaWxpdHk6IEV2ZW50PElUZXJtaW5hbEluc3RhbmNlPjtcblxuXHRzZXRBY3RpdmVJbnN0YW5jZShpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2UpOiB2b2lkO1xuXHQvKipcblx0ICogUmV2ZWFsIGFuZCBmb2N1cyB0aGUgaW5zdGFuY2UsIHJlZ2FyZGxlc3Mgb2YgaXRzIGxvY2F0aW9uLlxuXHQgKi9cblx0Zm9jdXNJbnN0YW5jZShpbnN0YW5jZTogSVRlcm1pbmFsSW5zdGFuY2UpOiB2b2lkO1xuXHQvKipcblx0ICogUmV2ZWFsIGFuZCBmb2N1cyB0aGUgYWN0aXZlIGluc3RhbmNlLCByZWdhcmRsZXNzIG9mIGl0cyBsb2NhdGlvbi5cblx0ICovXG5cdGZvY3VzQWN0aXZlSW5zdGFuY2UoKTogUHJvbWlzZTx2b2lkPjtcblx0LyoqXG5cdCAqIEdldHMgYW4gaW5zdGFuY2UgZnJvbSBhIHJlc291cmNlIGlmIGl0IGV4aXN0cy4gVGhpcyBNVVNUIGJlIHVzZWQgaW5zdGVhZCBvZiBnZXRJbnN0YW5jZUZyb21JZFxuXHQgKiB3aGVuIHlvdSBvbmx5IGtub3cgYWJvdXQgYSB0ZXJtaW5hbCdzIFVSSS4gKGEgVVJJJ3MgaW5zdGFuY2UgSUQgbWF5IG5vdCBiZSB0aGlzIHdpbmRvdydzIGluc3RhbmNlIElEKVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VGcm9tUmVzb3VyY2UocmVzb3VyY2U6IFVyaUNvbXBvbmVudHMgfCB1bmRlZmluZWQpOiBJVGVybWluYWxJbnN0YW5jZSB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIHh0ZXJtLmpzJyBJTGlua1Byb3ZpZGVyIGJ1dCB1c2luZyBwcm9taXNlcyBhbmQgaGlkZXMgeHRlcm0uanMgaW50ZXJuYWxzIChsaWtlIGJ1ZmZlclxuICogcG9zaXRpb25zLCBkZWNvcmF0aW9ucywgZXRjLikgZnJvbSB0aGUgcmVzdCBvZiB2c2NvZGUuIFRoaXMgaXMgdGhlIGludGVyZmFjZSB0byB1c2UgZm9yXG4gKiB3b3JrYmVuY2ggaW50ZWdyYXRpb25zLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElUZXJtaW5hbEV4dGVybmFsTGlua1Byb3ZpZGVyIHtcblx0cHJvdmlkZUxpbmtzKGluc3RhbmNlOiBJVGVybWluYWxJbnN0YW5jZSwgbGluZTogc3RyaW5nKTogUHJvbWlzZTxJVGVybWluYWxMaW5rW10gfCB1bmRlZmluZWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElUZXJtaW5hbExpbmsge1xuXHQvKiogVGhlIHN0YXJ0SW5kZXggb2YgdGhlIGxpbmsgaW4gdGhlIGxpbmUuICovXG5cdHN0YXJ0SW5kZXg6IG51bWJlcjtcblx0LyoqIFRoZSBsZW5ndGggb2YgdGhlIGxpbmsgaW4gdGhlIGxpbmUuICovXG5cdGxlbmd0aDogbnVtYmVyO1xuXHQvKiogVGhlIGRlc2NyaXB0aXZlIGxhYmVsIGZvciB3aGF0IHRoZSBsaW5rIGRvZXMgd2hlbiBhY3RpdmF0ZWQuICovXG5cdGxhYmVsPzogc3RyaW5nO1xuXHQvKipcblx0ICogQWN0aXZhdGVzIHRoZSBsaW5rLlxuXHQgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCBvZiB0aGUgbGluay5cblx0ICovXG5cdGFjdGl2YXRlKHRleHQ6IHN0cmluZyk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNlYXJjaE9wdGlvbnMge1xuXHQvKiogV2hldGhlciB0aGUgZmluZCBzaG91bGQgYmUgZG9uZSBhcyBhIHJlZ2V4LiAqL1xuXHRyZWdleD86IGJvb2xlYW47XG5cdC8qKiBXaGV0aGVyIG9ubHkgd2hvbGUgd29yZHMgc2hvdWxkIG1hdGNoLiAqL1xuXHR3aG9sZVdvcmQ/OiBib29sZWFuO1xuXHQvKiogV2hldGhlciBmaW5kIHNob3VsZCBwYXkgYXR0ZW50aW9uIHRvIGNhc2UuICovXG5cdGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuXHQvKiogV2hldGhlciB0aGUgc2VhcmNoIHNob3VsZCBzdGFydCBhdCB0aGUgY3VycmVudCBzZWFyY2ggcG9zaXRpb24gKG5vdCB0aGUgbmV4dCByb3cpLiAqL1xuXHRpbmNyZW1lbnRhbD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRlcm1pbmFsSW5zdGFuY2UgZXh0ZW5kcyBJQmFzZVRlcm1pbmFsSW5zdGFuY2Uge1xuXHQvKipcblx0ICogVGhlIElEIG9mIHRoZSB0ZXJtaW5hbCBpbnN0YW5jZSwgdGhpcyBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9ubHkgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeVxuXHQgKiB0ZXJtaW5hbCBpbnN0YW5jZXMgd2l0aGluIGEgd2luZG93LlxuXHQgKi9cblx0cmVhZG9ubHkgaW5zdGFuY2VJZDogbnVtYmVyO1xuXHQvKipcblx0ICogQSB1bmlxdWUgVVJJIGZvciB0aGlzIHRlcm1pbmFsIGluc3RhbmNlIHdpdGggdGhlIGZvbGxvd2luZyBlbmNvZGluZzpcblx0ICogcGF0aDogLzx3b3Jrc3BhY2UgSUQ+LzxpbnN0YW5jZSBJRD5cblx0ICogZnJhZ21lbnQ6IFRpdGxlXG5cdCAqIE5vdGUgdGhhdCB3aGVuIGRyYWdnaW5nIHRlcm1pbmFscyBhY3Jvc3Mgd2luZG93cywgdGhpcyB3aWxsIHJldGFpbiB0aGUgb3JpZ2luYWwgd29ya3NwYWNlIElEIC9pbnN0YW5jZSBJRFxuXHQgKiBmcm9tIHRoZSBvdGhlciB3aW5kb3cuXG5cdCAqL1xuXHRyZWFkb25seSByZXNvdXJjZTogVVJJO1xuXG5cdHJlYWRvbmx5IGNvbHM6IG51bWJlcjtcblx0cmVhZG9ubHkgcm93czogbnVtYmVyO1xuXHRyZWFkb25seSBtYXhDb2xzOiBudW1iZXI7XG5cdHJlYWRvbmx5IG1heFJvd3M6IG51bWJlcjtcblx0cmVhZG9ubHkgZml4ZWRDb2xzPzogbnVtYmVyO1xuXHRyZWFkb25seSBmaXhlZFJvd3M/OiBudW1iZXI7XG5cdHJlYWRvbmx5IGRvbUVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuXHRyZWFkb25seSBpY29uPzogVGVybWluYWxJY29uO1xuXHRyZWFkb25seSBjb2xvcj86IHN0cmluZztcblx0cmVhZG9ubHkgcmVjb25uZWN0aW9uUHJvcGVydGllcz86IElSZWNvbm5lY3Rpb25Qcm9wZXJ0aWVzO1xuXHRyZWFkb25seSBwcm9jZXNzTmFtZTogc3RyaW5nO1xuXHRyZWFkb25seSBzZXF1ZW5jZT86IHN0cmluZztcblx0cmVhZG9ubHkgc3RhdGljVGl0bGU/OiBzdHJpbmc7XG5cdHJlYWRvbmx5IHByb2dyZXNzU3RhdGU/OiBJUHJvZ3Jlc3NTdGF0ZTtcblx0cmVhZG9ubHkgd29ya3NwYWNlRm9sZGVyPzogSVdvcmtzcGFjZUZvbGRlcjtcblx0cmVhZG9ubHkgY3dkPzogc3RyaW5nO1xuXHRyZWFkb25seSBpbml0aWFsQ3dkPzogc3RyaW5nO1xuXHRyZWFkb25seSBvcz86IE9wZXJhdGluZ1N5c3RlbTtcblx0cmVhZG9ubHkgdXNlZFNoZWxsSW50ZWdyYXRpb25JbmplY3Rpb246IGJvb2xlYW47XG5cdHJlYWRvbmx5IHNoZWxsSW50ZWdyYXRpb25JbmplY3Rpb25GYWlsdXJlUmVhc29uOiBTaGVsbEludGVncmF0aW9uSW5qZWN0aW9uRmFpbHVyZVJlYXNvbiB8IHVuZGVmaW5lZDtcblx0cmVhZG9ubHkgaW5qZWN0ZWRBcmdzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcblx0cmVhZG9ubHkgZXh0RW52aXJvbm1lbnRWYXJpYWJsZUNvbGxlY3Rpb246IElNZXJnZWRFbnZpcm9ubWVudFZhcmlhYmxlQ29sbGVjdGlvbiB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogVGhlIHVuZGVybHlpbmcgZGlzcG9zYWJsZSBzdG9yZSwgYWxsb3dpbmcgb2JqZWN0cyB3aG8gc2hhcmUgdGhlIHNhbWUgbGlmZWN5Y2xlIGFzIHRoZVxuXHQgKiB0ZXJtaW5hbCBpbnN0YW5jZSBidXQgYXJlIGNyZWF0ZWQgZXh0ZXJuYWxseSB0byBiZSBtYW5hZ2VkIGJ5IHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHJlYWRvbmx5IHN0b3JlOiBEaXNwb3NhYmxlU3RvcmU7XG5cblx0cmVhZG9ubHkgc3RhdHVzTGlzdDogSVRlcm1pbmFsU3RhdHVzTGlzdDtcblxuXHQvKipcblx0ICogVGhlIHByb2Nlc3MgSUQgb2YgdGhlIHNoZWxsIHByb2Nlc3MsIHRoaXMgaXMgdW5kZWZpbmVkIHdoZW4gdGhlcmUgaXMgbm8gcHJvY2VzcyBhc3NvY2lhdGVkXG5cdCAqIHdpdGggdGhpcyB0ZXJtaW5hbC5cblx0ICovXG5cdHByb2Nlc3NJZDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBUaGUgcG9zaXRpb24gb2YgdGhlIHRlcm1pbmFsLlxuXHQgKi9cblx0dGFyZ2V0OiBUZXJtaW5hbExvY2F0aW9uIHwgdW5kZWZpbmVkO1xuXHR0YXJnZXRSZWY6IElSZWZlcmVuY2U8VGVybWluYWxMb2NhdGlvbiB8IHVuZGVmaW5lZD47XG5cblx0LyoqXG5cdCAqIFRoZSBpZCBvZiBhIHBlcnNpc3RlbnQgcHJvY2Vzcy4gVGhpcyBpcyBkZWZpbmVkIGlmIHRoaXMgaXMgYSB0ZXJtaW5hbCBjcmVhdGVkIGJ5IGEgcHR5IGhvc3Rcblx0ICogdGhhdCBzdXBwb3J0cyByZWNvbm5lY3Rpb24uXG5cdCAqL1xuXHRyZWFkb25seSBwZXJzaXN0ZW50UHJvY2Vzc0lkOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhlIHByb2Nlc3Mgc2hvdWxkIGJlIHBlcnNpc3RlZCBhY3Jvc3MgcmVsb2Fkcy5cblx0ICovXG5cdHJlYWRvbmx5IHNob3VsZFBlcnNpc3Q6IGJvb2xlYW47XG5cblx0Lypcblx0ICogV2hldGhlciB0aGlzIHRlcm1pbmFsIGhhcyBiZWVuIGRpc3Bvc2VkIG9mXG5cdCAqL1xuXHRyZWFkb25seSBpc0Rpc3Bvc2VkOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRoZSB0ZXJtaW5hbCdzIHB0eSBpcyBob3N0ZWQgb24gYSByZW1vdGUuXG5cdCAqL1xuXHRyZWFkb25seSBoYXNSZW1vdGVBdXRob3JpdHk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIFRoZSByZW1vdGUgYXV0aG9yaXR5IG9mIHRoZSB0ZXJtaW5hbCdzIHB0eS5cblx0ICovXG5cdHJlYWRvbmx5IHJlbW90ZUF1dGhvcml0eTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIGFuIGVsZW1lbnQgd2l0aGluIHRoaXMgdGVybWluYWwgaXMgZm9jdXNlZC5cblx0ICovXG5cdHJlYWRvbmx5IGhhc0ZvY3VzOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBUaGUgSUQgb2YgdGhlIHNlc3Npb24gdGhhdCB0aGlzIHRlcm1pbmFsIGlzIGNvbm5lY3RlZCB0b1xuXHQgKi9cblx0cmVhZG9ubHkgc2Vzc2lvbklkOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIEdldCBvciBzZXQgdGhlIGJlaGF2aW9yIG9mIHRoZSB0ZXJtaW5hbCB3aGVuIGl0IGNsb3Nlcy4gVGhpcyB3YXMgaW5kZW50ZWQgb25seSB0byBiZSBjYWxsZWRcblx0ICogYWZ0ZXIgcmVjb25uZWN0aW5nIHRvIGEgdGVybWluYWwuXG5cdCAqL1xuXHR3YWl0T25FeGl0OiBXYWl0T25FeGl0VmFsdWUgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiB0aGUgdGVybWluYWwgaW5zdGFuY2UncyB0aXRsZSBjaGFuZ2VzLlxuXHQgKi9cblx0cmVhZG9ubHkgb25UaXRsZUNoYW5nZWQ6IEV2ZW50PElUZXJtaW5hbEluc3RhbmNlPjtcblxuXHQvKipcblx0ICogQW4gZXZlbnQgdGhhdCBmaXJlcyB3aGVuIHRoZSB0ZXJtaW5hbCBpbnN0YW5jZSdzIGljb24gY2hhbmdlcy5cblx0ICovXG5cdHJlYWRvbmx5IG9uSWNvbkNoYW5nZWQ6IEV2ZW50PHsgaW5zdGFuY2U6IElUZXJtaW5hbEluc3RhbmNlOyB1c2VySW5pdGlhdGVkOiBib29sZWFuIH0+O1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCB0aGF0IGZpcmVzIHdoZW4gdGhlIHRlcm1pbmFsIGluc3RhbmNlIGlzIGRpc3Bvc2VkLlxuXHQgKi9cblx0cmVhZG9ubHkgb25EaXNwb3NlZDogRXZlbnQ8SVRlcm1pbmFsSW5zdGFuY2U+O1xuXG5cdHJlYWRvbmx5IG9uUHJvY2Vzc0lkUmVhZHk6IEV2ZW50PElUZXJtaW5hbEluc3RhbmNlPjtcblx0cmVhZG9ubHkgb25Qcm9jZXNzUmVwbGF5Q29tcGxldGU6IEV2ZW50PHZvaWQ+O1xuXHRyZWFkb25seSBvblJlcXVlc3RFeHRIb3N0UHJvY2VzczogRXZlbnQ8SVRlcm1pbmFsSW5zdGFuY2U+O1xuXHRyZWFkb25seSBvbkRpbWVuc2lvbnNDaGFuZ2VkOiBFdmVudDx2b2lkPjtcblx0cmVhZG9ubHkgb25NYXhpbXVtRGltZW5zaW9uc0NoYW5nZWQ6IEV2ZW50PHZvaWQ+O1xuXHRyZWFkb25seSBvbkRpZENoYW5nZUhhc0NoaWxkUHJvY2Vzc2VzOiBFdmVudDxib29sZWFuPjtcblxuXHRyZWFkb25seSBvbkRpZEZvY3VzOiBFdmVudDxJVGVybWluYWxJbnN0YW5jZT47XG5cdHJlYWRvbmx5IG9uRGlkUmVxdWVzdEZvY3VzOiBFdmVudDx2b2lkPjtcblx0cmVhZG9ubHkgb25EaWRCbHVyOiBFdmVudDxJVGVybWluYWxJbnN0YW5jZT47XG5cdHJlYWRvbmx5IG9uRGlkSW5wdXREYXRhOiBFdmVudDxzdHJpbmc+O1xuXHRyZWFkb25seSBvbkRpZENoYW5nZVNlbGVjdGlvbjogRXZlbnQ8SVRlcm1pbmFsSW5zdGFuY2U+O1xuXHRyZWFkb25seSBvbkRpZEV4ZWN1dGVUZXh0OiBFdmVudDx2b2lkPjtcblx0cmVhZG9ubHkgb25EaWRDaGFuZ2VUYXJnZXQ6IEV2ZW50PFRlcm1pbmFsTG9jYXRpb24gfCB1bmRlZmluZWQ+O1xuXHRyZWFkb25seSBvbkRpZFNlbmRUZXh0OiBFdmVudDxzdHJpbmc+O1xuXHRyZWFkb25seSBvbkRpZENoYW5nZVNoZWxsVHlwZTogRXZlbnQ8VGVybWluYWxTaGVsbFR5cGU+O1xuXHRyZWFkb25seSBvbkRpZENoYW5nZVZpc2liaWxpdHk6IEV2ZW50PGJvb2xlYW4+O1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCB0aGF0IGZpcmVzIHdoZW4gYSB0ZXJtaW5hbCBpcyBkcm9wcGVkIG9uIHRoaXMgaW5zdGFuY2UgdmlhIGRyYWcgYW5kIGRyb3AuXG5cdCAqL1xuXHRyZWFkb25seSBvblJlcXVlc3RBZGRJbnN0YW5jZVRvR3JvdXA6IEV2ZW50PElSZXF1ZXN0QWRkSW5zdGFuY2VUb0dyb3VwRXZlbnQ+O1xuXG5cdC8qKlxuXHQgKiBBdHRhY2ggYSBsaXN0ZW5lciB0byB0aGUgcmF3IGRhdGEgc3RyZWFtIGNvbWluZyBmcm9tIHRoZSBwdHksIGluY2x1ZGluZyBBTlNJIGVzY2FwZVxuXHQgKiBzZXF1ZW5jZXMuXG5cdCAqL1xuXHRyZWFkb25seSBvbkRhdGE6IEV2ZW50PHN0cmluZz47XG5cdHJlYWRvbmx5IG9uV2lsbERhdGE6IEV2ZW50PHN0cmluZz47XG5cblx0LyoqXG5cdCAqIEF0dGFjaCBhIGxpc3RlbmVyIHRvIHRoZSBiaW5hcnkgZGF0YSBzdHJlYW0gY29taW5nIGZyb20geHRlcm0gYW5kIGdvaW5nIHRvIHB0eVxuXHQgKi9cblx0cmVhZG9ubHkgb25CaW5hcnk6IEV2ZW50PHN0cmluZz47XG5cblx0LyoqXG5cdCAqIEF0dGFjaCBhIGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgbmV3IGxpbmVzIGFkZGVkIHRvIHRoaXMgdGVybWluYWwgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gd2hpY2ggdGFrZXMgbmV3IGxpbmUgc3RyaW5ncyBhZGRlZCB0byB0aGUgdGVybWluYWwsXG5cdCAqIGV4Y2x1ZGluZyBBTlNJIGVzY2FwZSBzZXF1ZW5jZXMuIFRoZSBsaW5lIGV2ZW50IHdpbGwgZmlyZSB3aGVuIGFuIExGIGNoYXJhY3RlciBpcyBhZGRlZCB0b1xuXHQgKiB0aGUgdGVybWluYWwgKGllLiB0aGUgbGluZSBpcyBub3Qgd3JhcHBlZCkuIE5vdGUgdGhhdCB0aGlzIG1lYW5zIHRoYXQgdGhlIGxpbmUgZGF0YSB3aWxsXG5cdCAqIG5vdCBmaXJlIGZvciB0aGUgbGFzdCBsaW5lLCB1bnRpbCBlaXRoZXIgdGhlIGxpbmUgaXMgZW5kZWQgd2l0aCBhIExGIGNoYXJhY3RlciBvZiB0aGUgcHJvY2Vzc1xuXHQgKiBpcyBleGl0ZWQuIFRoZSBsaW5lRGF0YSBzdHJpbmcgd2lsbCBjb250YWluIHRoZSBmdWxseSB3cmFwcGVkIGxpbmUsIG5vdCBjb250YWluaW5nIGFueSBMRi9DUlxuXHQgKiBjaGFyYWN0ZXJzLlxuXHQgKi9cblx0cmVhZG9ubHkgb25MaW5lRGF0YTogRXZlbnQ8c3RyaW5nPjtcblxuXHQvKipcblx0ICogQXR0YWNoIGEgbGlzdGVuZXIgdGhhdCBmaXJlcyB3aGVuIHRoZSB0ZXJtaW5hbCdzIHB0eSBwcm9jZXNzIGV4aXRzLiBUaGUgbnVtYmVyIGluIHRoZSBldmVudFxuXHQgKiBpcyB0aGUgcHJvY2Vzc2VzJyBleGl0IGNvZGUsIGFuIGV4aXQgY29kZSBvZiB1bmRlZmluZWQgbWVhbnMgdGhlIHByb2Nlc3Mgd2FzIGtpbGxlZCBhcyBhIHJlc3VsdCBvZlxuXHQgKiB0aGUgSVRlcm1pbmFsSW5zdGFuY2UgYmVpbmcgZGlzcG9zZWQuXG5cdCAqL1xuXHRyZWFkb25seSBvbkV4aXQ6IEV2ZW50PG51bWJlciB8IElUZXJtaW5hbExhdW5jaEVycm9yIHwgdW5kZWZpbmVkPjtcblxuXHQvKipcblx0ICogVGhlIGV4aXQgY29kZSBvciB1bmRlZmluZWQgd2hlbiB0aGUgdGVybWluYWwgcHJvY2VzcyBoYXNuJ3QgeWV0IGV4aXRlZCBvclxuXHQgKiB0aGUgcHJvY2VzcyBleGl0IGNvZGUgY291bGQgbm90IGJlIGRldGVybWluZWQuIFVzZSB7QGxpbmsgZXhpdFJlYXNvbn0gdG8gc2VlXG5cdCAqIHdoeSB0aGUgcHJvY2VzcyBoYXMgZXhpdGVkLlxuXHQgKi9cblx0cmVhZG9ubHkgZXhpdENvZGU6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogVGhlIHJlYXNvbiB0aGUgdGVybWluYWwgcHJvY2VzcyBleGl0ZWQsIHRoaXMgd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIHByb2Nlc3MgaXMgc3RpbGxcblx0ICogcnVubmluZy5cblx0ICovXG5cdHJlYWRvbmx5IGV4aXRSZWFzb246IFRlcm1pbmFsRXhpdFJlYXNvbiB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogVGhlIHh0ZXJtLmpzIGluc3RhbmNlIGZvciB0aGlzIHRlcm1pbmFsLlxuXHQgKi9cblx0cmVhZG9ubHkgeHRlcm0/OiBYdGVybVRlcm1pbmFsO1xuXG5cdC8qKlxuXHQgKiBSZXNvbHZlcyB3aGVuIHRoZSB4dGVybS5qcyBpbnN0YW5jZSBmb3IgdGhpcyB0ZXJtaW5hbCBpcyByZWFkeS5cblx0ICovXG5cdHJlYWRvbmx5IHh0ZXJtUmVhZHlQcm9taXNlOiBQcm9taXNlPFh0ZXJtVGVybWluYWwgfCB1bmRlZmluZWQ+O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRhdGEgZXZlbnRzIHRoYXQgaGF2ZSBmaXJlZCB3aXRoaW4gdGhlIGZpcnN0IDEwIHNlY29uZHMuIElmIHRoaXMgaXNcblx0ICogY2FsbGVkIDEwIHNlY29uZHMgYWZ0ZXIgdGhlIHRlcm1pbmFsIGhhcyBleGlzdGVkIHRoZSByZXN1bHQgd2lsbCBiZSB1bmRlZmluZWQuIFRoaXMgaXMgdXNlZnVsXG5cdCAqIHdoZW4gb2JqZWN0cyB0aGF0IGRlcGVuZCBvbiB0aGUgZGF0YSBldmVudHMgaGF2ZSBkZWxheWVkIGluaXRpYWxpemF0aW9uLCBsaWtlIGV4dGVuc2lvblxuXHQgKiBob3N0cy5cblx0ICovXG5cdHJlYWRvbmx5IGluaXRpYWxEYXRhRXZlbnRzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcblxuXHQvKiogQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgdGVybWluYWwncyBwdHkvcHJvY2VzcyBoYXZlIGJlZW4gY3JlYXRlZC4gKi9cblx0cmVhZG9ubHkgcHJvY2Vzc1JlYWR5OiBQcm9taXNlPHZvaWQ+O1xuXG5cdC8qKiBXaGV0aGVyIHRoZSB0ZXJtaW5hbCdzIHByb2Nlc3MgaGFzIGNoaWxkIHByb2Nlc3NlcyAoaWUuIGlzIGRpcnR5L2J1c3kpLiAqL1xuXHRyZWFkb25seSBoYXNDaGlsZFByb2Nlc3NlczogYm9vbGVhbjtcblxuXHQvKipcblx0ICogVGhlIHRpdGxlIG9mIHRoZSB0ZXJtaW5hbC4gVGhpcyBpcyBlaXRoZXIgdGl0bGUgb3IgdGhlIHByb2Nlc3MgY3VycmVudGx5IHJ1bm5pbmcgb3IgYW5cblx0ICogZXhwbGljaXQgbmFtZSBnaXZlbiB0byB0aGUgdGVybWluYWwgaW5zdGFuY2UgdGhyb3VnaCB0aGUgZXh0ZW5zaW9uIEFQSS5cblx0ICovXG5cdHJlYWRvbmx5IHRpdGxlOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIEhvdyB0aGUgY3VycmVudCB0aXRsZSB3YXMgc2V0LlxuXHQgKi9cblx0cmVhZG9ubHkgdGl0bGVTb3VyY2U6IFRpdGxlRXZlbnRTb3VyY2U7XG5cblx0LyoqXG5cdCAqIFRoZSBzaGVsbCB0eXBlIG9mIHRoZSB0ZXJtaW5hbC5cblx0ICovXG5cdHJlYWRvbmx5IHNoZWxsVHlwZTogVGVybWluYWxTaGVsbFR5cGUgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFRoZSBmb2N1cyBzdGF0ZSBvZiB0aGUgdGVybWluYWwgYmVmb3JlIGV4aXRpbmcuXG5cdCAqL1xuXHRyZWFkb25seSBoYWRGb2N1c09uRXhpdDogYm9vbGVhbjtcblxuXHQvKipcblx0ICogRmFsc2Ugd2hlbiB0aGUgdGl0bGUgaXMgc2V0IGJ5IGFuIEFQSSBvciB0aGUgdXNlci4gV2UgY2hlY2sgdGhpcyB0byBtYWtlIHN1cmUgd2Vcblx0ICogZG8gbm90IG92ZXJyaWRlIHRoZSB0aXRsZSB3aGVuIHRoZSBwcm9jZXNzIHRpdGxlIGNoYW5nZXMgaW4gdGhlIHRlcm1pbmFsLlxuXHQgKi9cblx0aXNUaXRsZVNldEJ5UHJvY2VzczogYm9vbGVhbjtcblxuXHQvKipcblx0ICogVGhlIHNoZWxsIGxhdW5jaCBjb25maWcgdXNlZCB0byBsYXVuY2ggdGhlIHNoZWxsLlxuXHQgKi9cblx0cmVhZG9ubHkgc2hlbGxMYXVuY2hDb25maWc6IElTaGVsbExhdW5jaENvbmZpZztcblxuXHQvKipcblx0ICogV2hldGhlciB0byBkaXNhYmxlIGxheW91dCBmb3IgdGhlIHRlcm1pbmFsLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRoZSBzaXplIG9mIHRoZSB0ZXJtaW5hbCBpc1xuXHQgKiBiZWluZyBtYW5pcHVsYXRpbmcgKGUuZy4gYWRkaW5nIGEgc3BsaXQgcGFuZSkgYW5kIHdlIHdhbnQgdGhlIHRlcm1pbmFsIHRvIGlnbm9yZSBwYXJ0aWN1bGFyXG5cdCAqIHJlc2l6ZSBldmVudHMuXG5cdCAqL1xuXHRkaXNhYmxlTGF5b3V0OiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIHRlcm1pbmFsLCB0aGlzIGlzIHR5cGljYWxseSBkaXNwbGF5ZWQgbmV4dCB0byB7QGxpbmsgdGl0bGV9LlxuXHQgKi9cblx0ZGVzY3JpcHRpb246IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogVGhlIHJlbW90ZS1hd2FyZSAkSE9NRSBkaXJlY3RvcnkgKG9yIFdpbmRvd3MgZXF1aXZhbGVudCkgb2YgdGhlIHRlcm1pbmFsLlxuXHQgKi9cblx0dXNlckhvbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogVGhlIG5vbmNlIHVzZWQgdG8gdmVyaWZ5IGNvbW1hbmRzIGNvbWluZyBmcm9tIHNoZWxsIGludGVncmF0aW9uLlxuXHQgKi9cblx0c2hlbGxJbnRlZ3JhdGlvbk5vbmNlOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhbmQgcmV0dXJucyBhIG1hcmtlclxuXHQgKiBAcGFyYW0gdGhlIHkgb2Zmc2V0IGZyb20gdGhlIGN1cnNvclxuXHQgKi9cblx0cmVnaXN0ZXJNYXJrZXIob2Zmc2V0PzogbnVtYmVyKTogSU1hcmtlciB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQWRkcyBhIG1hcmtlciB0byB0aGUgYnVmZmVyLCBtYXBwaW5nIGl0IHRvIGFuIElEIGlmIHByb3ZpZGVkLlxuXHQgKi9cblx0YWRkQnVmZmVyTWFya2VyKHByb3BlcnRpZXM6IElNYXJrUHJvcGVydGllcyk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBzdGFydE1hcmtJZCBUaGUgSUQgZm9yIHRoZSBzdGFydCBtYXJrZXJcblx0ICogQHBhcmFtIGVuZE1hcmtJZCBUaGUgSUQgZm9yIHRoZSBlbmQgbWFya2VyXG5cdCAqIEBwYXJhbSBoaWdobGlnaHQgV2hldGhlciB0aGUgYnVmZmVyIGZyb20gc3RhcnRNYXJrZXIgdG8gZW5kTWFya2VyXG5cdCAqIHNob3VsZCBiZSBoaWdobGlnaHRlZFxuXHQgKi9cblx0c2Nyb2xsVG9NYXJrKHN0YXJ0TWFya0lkOiBzdHJpbmcsIGVuZE1hcmtJZD86IHN0cmluZywgaGlnaGxpZ2h0PzogYm9vbGVhbik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIERpc3Bvc2UgdGhlIHRlcm1pbmFsIGluc3RhbmNlLCByZW1vdmluZyBpdCBmcm9tIHRoZSBwYW5lbC9zZXJ2aWNlIGFuZCBmcmVlaW5nIHVwIHJlc291cmNlcy5cblx0ICpcblx0ICogQHBhcmFtIHJlYXNvbiBUaGUgcmVhc29uIHdoeSB0aGUgdGVybWluYWwgaXMgYmVpbmcgZGlzcG9zZWRcblx0ICovXG5cdGRpc3Bvc2UocmVhc29uPzogVGVybWluYWxFeGl0UmVhc29uKTogdm9pZDtcblxuXHQvKipcblx0ICogSW5mb3JtcyB0aGUgcHJvY2VzcyB0aGF0IHRoZSB0ZXJtaW5hbCBpcyBub3cgZGV0YWNoZWQgYW5kXG5cdCAqIHRoZW4gZGlzcG9zZXMgdGhlIHRlcm1pbmFsLlxuXHQgKlxuXHQgKiBAcGFyYW0gcmVhc29uIFRoZSByZWFzb24gd2h5IHRoZSB0ZXJtaW5hbCBpcyBiZWluZyBkaXNwb3NlZFxuXHQgKi9cblx0ZGV0YWNoUHJvY2Vzc0FuZERpc3Bvc2UocmVhc29uOiBUZXJtaW5hbEV4aXRSZWFzb24pOiBQcm9taXNlPHZvaWQ+O1xuXG5cdC8qKlxuXHQgKiBXaGVuIHRoZSBwYW5lbCBpcyBoaWRkZW4gb3IgYSB0ZXJtaW5hbCBpbiB0aGUgZWRpdG9yIGFyZWEgYmVjb21lcyBpbmFjdGl2ZSwgcmVzZXQgdGhlIGZvY3VzIGNvbnRleHQga2V5XG5cdCAqIHRvIGF2b2lkIGlzc3VlcyBsaWtlICMxNDcxODAuXG5cdCAqL1xuXHRyZXNldEZvY3VzQ29udGV4dEtleSgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBGb2N1c2VzIHRoZSB0ZXJtaW5hbCBpbnN0YW5jZSB3aGVuIGl0J3MgcmVhZHkgKHRoZSB4dGVybS5qcyBpbnN0YW5jZSBtdWNoIGV4aXN0KS4gVGhpcyBpcyB0aGVcblx0ICogYmVzdCBmb2N1cyBjYWxsIHdoZW4gdGhlIHRlcm1pbmFsIGlzIGJlaW5nIHNob3duIGZvciBleGFtcGxlLlxuXHQgKiB3aGVuIHRoZSB0ZXJtaW5hbCBpcyBiZWluZyBzaG93bi5cblx0ICpcblx0ICogQHBhcmFtIGZvcmNlIEZvcmNlIGZvY3VzIGV2ZW4gaWYgdGhlcmUgaXMgYSBzZWxlY3Rpb24uXG5cdCAqL1xuXHRmb2N1c1doZW5SZWFkeShmb3JjZT86IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXG5cdC8qKlxuXHQgKiBTZW5kIHRleHQgdG8gdGhlIHRlcm1pbmFsIGluc3RhbmNlLiBUaGUgdGV4dCBpcyB3cml0dGVuIHRvIHRoZSBzdGRpbiBvZiB0aGUgdW5kZXJseWluZyBwdHlcblx0ICogcHJvY2VzcyAoc2hlbGwpIG9mIHRoZSB0ZXJtaW5hbCBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gc2VuZC5cblx0ICogQHBhcmFtIHNob3VsZEV4ZWN1dGUgSW5kaWNhdGVzIHRoYXQgdGhlIHRleHQgYmVpbmcgc2VudCBzaG91bGQgYmUgZXhlY3V0ZWQgcmF0aGVyIHRoYW4ganVzdCBpbnNlcnRlZCBpbiB0aGUgdGVybWluYWwuXG5cdCAqIFRoZSBjaGFyYWN0ZXIocykgYWRkZWQgYXJlIFxcbiBvciBcXHJcXG4sIGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0uIFRoaXMgZGVmYXVsdHMgdG8gYHRydWVgLlxuXHQgKiBAcGFyYW0gYnJhY2tldGVkUGFzdGVNb2RlIFdoZXRoZXIgdG8gd3JhcCB0aGUgdGV4dCBpbiB0aGUgYnJhY2tldGVkIHBhc3RlIG1vZGUgc2VxdWVuY2Ugd2hlblxuXHQgKiBpdCdzIGVuYWJsZWQuIFdoZW4gdHJ1ZSwgdGhlIHNoZWxsIHdpbGwgdHJlYXQgdGhlIHRleHQgYXMgaWYgaXQgd2VyZSBwYXN0ZWQgaW50byB0aGUgc2hlbGwsXG5cdCAqIHRoaXMgbWF5IGZvciBleGFtcGxlIHNlbGVjdCB0aGUgdGV4dCBhbmQgaXQgd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZSB0ZXh0IHdpbGwgbm90IGJlXG5cdCAqIGludGVycHJldGVkIGFzIGEgc2hlbGwga2V5YmluZGluZy5cblx0ICovXG5cdHNlbmRUZXh0KHRleHQ6IHN0cmluZywgc2hvdWxkRXhlY3V0ZTogYm9vbGVhbiwgYnJhY2tldGVkUGFzdGVNb2RlPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD47XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgc2lnbmFsIHRvIHRoZSB0ZXJtaW5hbCBpbnN0YW5jZSdzIHByb2Nlc3MuXG5cdCAqXG5cdCAqIEBwYXJhbSBzaWduYWwgVGhlIHNpZ25hbCB0byBzZW5kIChlLmcuLCAnU0lHVEVSTScsICdTSUdJTlQnLCAnU0lHS0lMTCcpLlxuXHQgKi9cblx0c2VuZFNpZ25hbChzaWduYWw6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgcGF0aCB0byB0aGUgdGVybWluYWwgaW5zdGFuY2UsIHByZXBhcmluZyBpdCBhcyBuZWVkZWQgYmFzZWQgb24gdGhlIGRldGVjdGVkIHNoZWxsXG5cdCAqIHJ1bm5pbmcgd2l0aGluIHRoZSB0ZXJtaW5hbC4gVGhlIHRleHQgaXMgd3JpdHRlbiB0byB0aGUgc3RkaW4gb2YgdGhlIHVuZGVybHlpbmcgcHR5IHByb2Nlc3Ncblx0ICogKHNoZWxsKSBvZiB0aGUgdGVybWluYWwgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSBvcmlnaW5hbFBhdGggVGhlIHBhdGggdG8gc2VuZC5cblx0ICogQHBhcmFtIHNob3VsZEV4ZWN1dGUgSW5kaWNhdGVzIHRoYXQgdGhlIHRleHQgYmVpbmcgc2VudCBzaG91bGQgYmUgZXhlY3V0ZWQgcmF0aGVyIHRoYW4ganVzdCBpbnNlcnRlZCBpbiB0aGUgdGVybWluYWwuXG5cdCAqIFRoZSBjaGFyYWN0ZXIocykgYWRkZWQgYXJlIFxcbiBvciBcXHJcXG4sIGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0uIFRoaXMgZGVmYXVsdHMgdG8gYHRydWVgLlxuXHQgKi9cblx0c2VuZFBhdGgob3JpZ2luYWxQYXRoOiBzdHJpbmcgfCBVUkksIHNob3VsZEV4ZWN1dGU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXG5cdHJ1bkNvbW1hbmQoY29tbWFuZDogc3RyaW5nLCBzaG91bGRFeGVjdXRlPzogYm9vbGVhbiwgY29tbWFuZElkPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcblxuXHQvKipcblx0ICogVGFrZXMgYSBwYXRoIGFuZCByZXR1cm5zIHRoZSBwcm9wZXJseSBlc2NhcGVkIHBhdGggdG8gc2VuZCB0byBhIGdpdmVuIHNoZWxsLiBPbiBXaW5kb3dzLCB0aGlzXG5cdCAqIGluY2x1ZGVzIHRyeWluZyB0byBwcmVwYXJlIHRoZSBwYXRoIGZvciBXU0wgaWYgbmVlZGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gb3JpZ2luYWxQYXRoIFRoZSBwYXRoIHRvIGJlIGVzY2FwZWQgYW5kIGZvcm1hdHRlZC5cblx0ICovXG5cdHByZXBhcmVQYXRoRm9yU2hlbGwob3JpZ2luYWxQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47XG5cblx0LyoqXG5cdCAqIEZvcm1hdHMgYSBmaWxlIHN5c3RlbSBVUkkgZm9yIGRpc3BsYXkgaW4gVUkgc28gdGhhdCBpdCBhcHBlYXJzIGluIHRoZSB0ZXJtaW5hbCBzaGVsbCdzIGZvcm1hdC5cblx0ICogQHBhcmFtIHVyaSBUaGUgVVJJIHRvIGZvcm1hdC5cblx0ICovXG5cdGdldFVyaUxhYmVsRm9yU2hlbGwodXJpOiBVUkkpOiBQcm9taXNlPHN0cmluZz47XG5cblx0LyoqIFNjcm9sbCB0aGUgdGVybWluYWwgYnVmZmVyIGRvd24gMSBsaW5lLiAqLyAgIHNjcm9sbERvd25MaW5lKCk6IHZvaWQ7XG5cdC8qKiBTY3JvbGwgdGhlIHRlcm1pbmFsIGJ1ZmZlciBkb3duIDEgcGFnZS4gKi8gICBzY3JvbGxEb3duUGFnZSgpOiB2b2lkO1xuXHQvKiogU2Nyb2xsIHRoZSB0ZXJtaW5hbCBidWZmZXIgdG8gdGhlIGJvdHRvbS4gKi8gc2Nyb2xsVG9Cb3R0b20oKTogdm9pZDtcblx0LyoqIFNjcm9sbCB0aGUgdGVybWluYWwgYnVmZmVyIHVwIDEgbGluZS4gKi8gICAgIHNjcm9sbFVwTGluZSgpOiB2b2lkO1xuXHQvKiogU2Nyb2xsIHRoZSB0ZXJtaW5hbCBidWZmZXIgdXAgMSBwYWdlLiAqLyAgICAgc2Nyb2xsVXBQYWdlKCk6IHZvaWQ7XG5cdC8qKiBTY3JvbGwgdGhlIHRlcm1pbmFsIGJ1ZmZlciB0byB0aGUgdG9wLiAqLyAgICBzY3JvbGxUb1RvcCgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIHRlcm1pbmFsIGJ1ZmZlciwgbGVhdmluZyBvbmx5IHRoZSBwcm9tcHQgbGluZSBhbmQgbW92aW5nIGl0IHRvIHRoZSB0b3Agb2YgdGhlXG5cdCAqIHZpZXdwb3J0LlxuXHQgKi9cblx0Y2xlYXJCdWZmZXIoKTogdm9pZDtcblxuXHQvKipcblx0ICogQXR0YWNoZXMgdGhlIHRlcm1pbmFsIGluc3RhbmNlIHRvIGFuIGVsZW1lbnQgb24gdGhlIERPTSwgYmVmb3JlIHRoaXMgaXMgY2FsbGVkIHRoZSB0ZXJtaW5hbFxuXHQgKiBpbnN0YW5jZSBwcm9jZXNzIG1heSBydW4gaW4gdGhlIGJhY2tncm91bmQgYnV0IGNhbm5vdCBiZSBkaXNwbGF5ZWQgb24gdGhlIFVJLlxuXHQgKlxuXHQgKiBAcGFyYW0gY29udGFpbmVyIFRoZSBlbGVtZW50IHRvIGF0dGFjaCB0aGUgdGVybWluYWwgaW5zdGFuY2UgdG8uXG5cdCAqL1xuXHRhdHRhY2hUb0VsZW1lbnQoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIERldGFjaGVzIHRoZSB0ZXJtaW5hbCBpbnN0YW5jZSBmcm9tIHRoZSB0ZXJtaW5hbCBlZGl0b3IgRE9NIGVsZW1lbnQuXG5cdCAqL1xuXHRkZXRhY2hGcm9tRWxlbWVudCgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBMYXlvdXQgdGhlIHRlcm1pbmFsIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0gZGltZW5zaW9uIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb250YWluZXIuXG5cdCAqL1xuXHRsYXlvdXQoZGltZW5zaW9uOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0pOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHdoZXRoZXIgdGhlIHRlcm1pbmFsIGluc3RhbmNlJ3MgZWxlbWVudCBpcyB2aXNpYmxlIGluIHRoZSBET00uXG5cdCAqXG5cdCAqIEBwYXJhbSB2aXNpYmxlIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZS5cblx0ICovXG5cdHNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIEltbWVkaWF0ZWx5IGtpbGxzIHRoZSB0ZXJtaW5hbCdzIGN1cnJlbnQgcHR5IHByb2Nlc3MgYW5kIGxhdW5jaGVzIGEgbmV3IG9uZSB0byByZXBsYWNlIGl0LlxuXHQgKlxuXHQgKiBAcGFyYW0gc2hlbGwgVGhlIG5ldyBsYXVuY2ggY29uZmlndXJhdGlvbi5cblx0ICovXG5cdHJldXNlVGVybWluYWwoc2hlbGw6IElTaGVsbExhdW5jaENvbmZpZyk6IFByb21pc2U8dm9pZD47XG5cblx0LyoqXG5cdCAqIFJlbGF1bmNoZXMgdGhlIHRlcm1pbmFsLCBraWxsaW5nIGl0IGFuZCByZXVzaW5nIHRoZSBsYXVuY2ggY29uZmlnIHVzZWQgaW5pdGlhbGx5LiBBbnlcblx0ICogZW52aXJvbm1lbnQgdmFyaWFibGUgY2hhbmdlcyB3aWxsIGJlIHJlY2FsY3VsYXRlZCB3aGVuIHRoaXMgaGFwcGVucy5cblx0ICovXG5cdHJlbGF1bmNoKCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHRlcm1pbmFsIGluc3RhbmNlJ3MgZGltZW5zaW9ucyB0byB0aGUgdmFsdWVzIHByb3ZpZGVkIHZpYSB0aGUgb25EaWRPdmVycmlkZURpbWVuc2lvbnMgZXZlbnQsXG5cdCAqIHdoaWNoIGFsbG93cyBvdmVycmlkaW5nIHRoZSByZWd1bGFyIGRpbWVuc2lvbnMgKGZpdCB0byB0aGUgc2l6ZSBvZiB0aGUgcGFuZWwpLlxuXHQgKi9cblx0c2V0T3ZlcnJpZGVEaW1lbnNpb25zKGRpbWVuc2lvbnM6IElUZXJtaW5hbERpbWVuc2lvbnMpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB0ZXJtaW5hbCBpbnN0YW5jZSdzIGRpbWVuc2lvbnMgdG8gdGhlIHZhbHVlcyBwcm92aWRlZCB2aWEgcXVpY2sgaW5wdXQuXG5cdCAqL1xuXHRzZXRGaXhlZERpbWVuc2lvbnMoKTogUHJvbWlzZTx2b2lkPjtcblxuXHQvKipcblx0ICogVG9nZ2xlcyB0ZXJtaW5hbCBsaW5lIHdyYXBwaW5nLlxuXHQgKi9cblx0dG9nZ2xlU2l6ZVRvQ29udGVudFdpZHRoKCk6IFByb21pc2U8dm9pZD47XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGluaXRpYWwgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSwgZmV0Y2hpbmcgaXQgZnJvbSB0aGUgYmFja2VuZCBpZiByZXF1aXJlZC5cblx0ICovXG5cdGdldEluaXRpYWxDd2QoKTogUHJvbWlzZTxzdHJpbmc+O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IGZyb20gY3dkIGRldGVjdGlvbiBjYXBhYmlsaXRpZXMgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2Vcblx0ICogZnJvbSB0aGUgYmFja2VuZC4gVGhpcyB3aWxsIHJldHVybiB0aGUgaW5pdGlhbCBjd2QgaWYgY3dkIGRldGVjdGlvbiBpcyBub3QgYXZhaWxhYmxlIChpZS5cblx0ICogb24gV2luZG93cyB3aGVuIHNoZWxsIGludGVncmF0aW9uIGlzIGRpc2FibGVkKS5cblx0ICovXG5cdGdldFNwZWN1bGF0aXZlQ3dkKCk6IFByb21pc2U8c3RyaW5nPjtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgY3dkIGFzIGEgVVJJIHRoYXQgaGFzIGJlZW4gdmFsaWRhdGVkIHRvIGV4aXN0LlxuXHQgKi9cblx0Z2V0Q3dkUmVzb3VyY2UoKTogUHJvbWlzZTxVUkkgfCB1bmRlZmluZWQ+O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgdGVybWluYWwgdG8gdGhlIHByb3ZpZGVkIHN0cmluZy4gSWYgbm8gdGl0bGUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgcmVzZXRcblx0ICogdG8gdGhlIHRlcm1pbmFsJ3MgdGl0bGUgaWYgaXQgd2FzIG5vdCBleHBsaWNpdGx5IHNldCBieSB0aGUgdXNlciBvciBBUEkuXG5cdCAqIEBwYXJhbSB0aXRsZSBUaGUgbmV3IHRpdGxlLlxuXHQgKi9cblx0cmVuYW1lKHRpdGxlPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcblxuXHQvKipcblx0ICogU2V0cyBvciB0cmlnZ2VycyBhIHF1aWNrIHBpY2sgdG8gY2hhbmdlIHRoZSBpY29uIG9mIHRoaXMgdGVybWluYWwuXG5cdCAqL1xuXHRjaGFuZ2VJY29uKGljb24/OiBUZXJtaW5hbEljb24pOiBQcm9taXNlPFRlcm1pbmFsSWNvbiB8IHVuZGVmaW5lZD47XG5cblx0LyoqXG5cdCAqIFNldHMgb3IgdHJpZ2dlcnMgYSBxdWljayBwaWNrIHRvIGNoYW5nZSB0aGUgY29sb3Igb2YgdGhlIGFzc29jaWF0ZWQgdGVybWluYWwgdGFiIGljb24uXG5cdCAqL1xuXHRjaGFuZ2VDb2xvcihjb2xvcj86IHN0cmluZywgc2tpcFF1aWNrUGljaz86IGJvb2xlYW4pOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD47XG5cblx0LyoqXG5cdCAqIEF0dGVtcHRzIHRvIGRldGVjdCBhbmQga2lsbCB0aGUgcHJvY2VzcyBsaXN0ZW5pbmcgb24gc3BlY2lmaWVkIHBvcnQuXG5cdCAqIElmIHN1Y2Nlc3NmdWwsIHBsYWNlcyBjb21tYW5kVG9SdW4gb24gdGhlIGNvbW1hbmQgbGluZVxuXHQgKi9cblx0ZnJlZVBvcnRLaWxsUHJvY2Vzcyhwb3J0OiBzdHJpbmcsIGNvbW1hbmRUb1J1bjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBwYXJlbnQgY29udGV4dCBrZXkgc2VydmljZSB0byB1c2UgZm9yIHRoaXMgdGVybWluYWwgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRQYXJlbnRDb250ZXh0S2V5U2VydmljZShwYXJlbnRDb250ZXh0S2V5U2VydmljZTogSUNvbnRleHRLZXlTZXJ2aWNlKTogdm9pZDtcblxuXHQvKipcblx0ICogSGFuZGxlcyBhIG1vdXNlIGV2ZW50IGZvciB0aGUgdGVybWluYWwsIHRoaXMgbWF5IGhhcHBlbiBvbiBhbiBhbnNjZXN0b3Igb2YgdGhlIHRlcm1pbmFsXG5cdCAqIGluc3RhbmNlJ3MgZWxlbWVudC5cblx0ICogQHBhcmFtIGV2ZW50IFRoZSBtb3VzZSBldmVudC5cblx0ICogQHBhcmFtIGNvbnRleHRNZW51IFRoZSBjb250ZXh0IG1lbnUgdG8gc2hvdyBpZiBuZWVkZWQuXG5cdCAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGNvbnRleHQgbWVudSBzaG91bGQgYmUgc3VwcHJlc3NlZC5cblx0ICovXG5cdGhhbmRsZU1vdXNlRXZlbnQoZXZlbnQ6IE1vdXNlRXZlbnQsIGNvbnRleHRNZW51OiBJTWVudSk6IFByb21pc2U8eyBjYW5jZWxDb250ZXh0TWVudTogYm9vbGVhbiB9IHwgdm9pZD47XG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIFh0ZXJtVGVybWluYWxDb25zdGFudHMge1xuXHRTZWFyY2hIaWdobGlnaHRMaW1pdCA9IDIwMDAwXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVh0ZXJtQXR0YWNoVG9FbGVtZW50T3B0aW9ucyB7XG5cdC8qKlxuXHQgKiBXaGV0aGVyIEdQVSByZW5kZXJpbmcgc2hvdWxkIGJlIGVuYWJsZWQgZm9yIHRoaXMgZWxlbWVudCwgZGVmYXVsdHMgdG8gdHJ1ZS5cblx0ICovXG5cdGVuYWJsZUdwdTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJWHRlcm1UZXJtaW5hbCBleHRlbmRzIElEaXNwb3NhYmxlIHtcblx0LyoqXG5cdCAqIEFuIG9iamVjdCB0aGF0IHRyYWNrcyB3aGVuIGNvbW1hbmRzIGFyZSBydW4gYW5kIGVuYWJsZXMgbmF2aWdhdGluZyBhbmQgc2VsZWN0aW5nIGJldHdlZW5cblx0ICogdGhlbS5cblx0ICovXG5cdHJlYWRvbmx5IG1hcmtUcmFja2VyOiBJTWFya1RyYWNrZXI7XG5cblx0LyoqXG5cdCAqIFJlcG9ydHMgdGhlIHN0YXR1cyBvZiBzaGVsbCBpbnRlZ3JhdGlvbiBhbmQgZmlyZXMgZXZlbnRzIHJlbGF0aW5nIHRvIGl0LlxuXHQgKi9cblx0cmVhZG9ubHkgc2hlbGxJbnRlZ3JhdGlvbjogSVNoZWxsSW50ZWdyYXRpb247XG5cblx0cmVhZG9ubHkgZGVjb3JhdGlvbkFkZG9uOiBJRGVjb3JhdGlvbkFkZG9uO1xuXG5cdHJlYWRvbmx5IG9uRGlkQ2hhbmdlU2VsZWN0aW9uOiBFdmVudDx2b2lkPjtcblx0cmVhZG9ubHkgb25EaWRDaGFuZ2VGaW5kUmVzdWx0czogRXZlbnQ8eyByZXN1bHRJbmRleDogbnVtYmVyOyByZXN1bHRDb3VudDogbnVtYmVyIH0+O1xuXHRyZWFkb25seSBvbkRpZFJlcXVlc3RSdW5Db21tYW5kOiBFdmVudDx7IGNvbW1hbmQ6IElUZXJtaW5hbENvbW1hbmQ7IG5vTmV3TGluZT86IGJvb2xlYW4gfT47XG5cdHJlYWRvbmx5IG9uRGlkUmVxdWVzdENvcHlBc0h0bWw6IEV2ZW50PHsgY29tbWFuZDogSVRlcm1pbmFsQ29tbWFuZCB9PjtcblxuXHQvKipcblx0ICogRXZlbnQgZmlyZWQgd2hlbiBmb2N1cyBlbnRlcnMgKGZpcmVzIHdpdGggdHJ1ZSkgb3IgbGVhdmVzIChmYWxzZSkgdGhlIHRlcm1pbmFsLlxuXHQgKi9cblx0cmVhZG9ubHkgb25EaWRDaGFuZ2VGb2N1czogRXZlbnQ8Ym9vbGVhbj47XG5cblx0LyoqXG5cdCAqIEdldHMgYSB2aWV3IG9mIHRoZSBjdXJyZW50IHRleHR1cmUgYXRsYXMgdXNlZCBieSB0aGUgcmVuZGVyZXJzLlxuXHQgKi9cblx0cmVhZG9ubHkgdGV4dHVyZUF0bGFzOiBQcm9taXNlPEltYWdlQml0bWFwPiB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogV2hldGhlciB0aGUgYGRpc2FibGVTdGRpbmAgb3B0aW9uIGluIHh0ZXJtLmpzIGlzIHNldC5cblx0ICovXG5cdHJlYWRvbmx5IGlzU3RkaW5EaXNhYmxlZDogYm9vbGVhbjtcblxuXHQvKipcblx0ICogV2hldGhlciB0aGUgdGVybWluYWwgaXMgY3VycmVudGx5IGZvY3VzZWQuXG5cdCAqL1xuXHRyZWFkb25seSBpc0ZvY3VzZWQ6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgYSBjYW52YXMtYmFzZWQgcmVuZGVyZXIgaXMgYmVpbmcgdXNlZC5cblx0ICovXG5cdHJlYWRvbmx5IGlzR3B1QWNjZWxlcmF0ZWQ6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIFRoZSBsYXN0IGBvbkRhdGFgIGlucHV0IGV2ZW50IGZpcmVkIGJ5IHtAbGluayBSYXdYdGVybVRlcm1pbmFsLm9uRGF0YX0uXG5cdCAqL1xuXHRyZWFkb25seSBsYXN0SW5wdXRFdmVudDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBBdHRhY2hlZCB0aGUgdGVybWluYWwgdG8gdGhlIGdpdmVuIGVsZW1lbnRcblx0ICogQHBhcmFtIGNvbnRhaW5lciBDb250YWluZXIgdGhlIHRlcm1pbmFsIHdpbGwgYmUgcmVuZGVyZWQgaW5cblx0ICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBtb3VudGluZyB0aGUgdGVybWluYWwgaW4gYW4gZWxlbWVudFxuXHQgKi9cblx0YXR0YWNoVG9FbGVtZW50KGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBQYXJ0aWFsPElYdGVybUF0dGFjaFRvRWxlbWVudE9wdGlvbnM+KTogdm9pZDtcblxuXHRmaW5kUmVzdWx0PzogeyByZXN1bHRJbmRleDogbnVtYmVyOyByZXN1bHRDb3VudDogbnVtYmVyIH07XG5cblx0LyoqXG5cdCAqIEZpbmQgdGhlIG5leHQgaW5zdGFuY2Ugb2YgdGhlIHRlcm1cblx0Ki9cblx0ZmluZE5leHQodGVybTogc3RyaW5nLCBzZWFyY2hPcHRpb25zOiBJU2VhcmNoT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj47XG5cblx0LyoqXG5cdCAqIEZpbmQgdGhlIHByZXZpb3VzIGluc3RhbmNlIG9mIHRoZSB0ZXJtXG5cdCAqL1xuXHRmaW5kUHJldmlvdXModGVybTogc3RyaW5nLCBzZWFyY2hPcHRpb25zOiBJU2VhcmNoT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj47XG5cblx0LyoqXG5cdCAqIEZvcmNlcyB0aGUgdGVybWluYWwgdG8gcmVkcmF3IGl0cyB2aWV3cG9ydC5cblx0ICovXG5cdGZvcmNlUmVkcmF3KCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGZvbnQgbWV0cmljcyBvZiB0aGlzIHh0ZXJtLmpzIGluc3RhbmNlLlxuXHQgKi9cblx0Z2V0Rm9udCgpOiBJVGVybWluYWxGb250O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHdoZXRoZXIgdGhlcmUncyBhbnkgdGVybWluYWwgc2VsZWN0aW9uLlxuXHQgKi9cblx0aGFzU2VsZWN0aW9uKCk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIENsZWFycyBhbnkgdGVybWluYWwgc2VsZWN0aW9uLlxuXHQgKi9cblx0Y2xlYXJTZWxlY3Rpb24oKTogdm9pZDtcblxuXHQvKipcblx0ICogU2VsZWN0cyBhbGwgdGVybWluYWwgY29udGVudHMvXG5cdCAqL1xuXHRzZWxlY3RBbGwoKTogdm9pZDtcblxuXHQvKipcblx0ICogU2VsZWN0cyB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0d28gbWFya2VycyBieSB0aGVpciBWUyBDb2RlIE9TQyBgU2V0TWFya2VyYFxuXHQgKiBJRC4gSXQncyBhIG5vLW9wIGlmIGVpdGhlciBvZiB0aGUgdHdvIG1hcmtlcnMgYXJlIG5vdCBmb3VuZC5cblx0ICpcblx0ICogQHBhcmFtIGZyb21NYXJrZXJJZCBTdGFydCBtYXJrZXIgSURcblx0ICogQHBhcmFtIHRvTWFya2VySWQgRW5kIG1hcmtlciBJRFxuXHQgKiBAcGFyYW0gc2Nyb2xsSW50b1ZpZXcgV2hldGhlciB0aGUgdGVybWluYWwgc2hvdWxkIHNjcm9sbCB0byB0aGUgc3RhcnQgb2Zcblx0ICogdGhlIHJhbmdlLCBkZWZhdWx0cyB0b2YgYWxzZVxuXHQgKi9cblx0c2VsZWN0TWFya2VkUmFuZ2UoZnJvbU1hcmtlcklkOiBzdHJpbmcsIHRvTWFya2VySWQ6IHN0cmluZywgc2Nyb2xsSW50b1ZpZXc/OiBib29sZWFuKTogdm9pZDtcblxuXHQvKipcblx0ICogQ29waWVzIHRoZSB0ZXJtaW5hbCBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSBjb3B5QXNIdG1sIFdoZXRoZXIgdG8gY29weSBzZWxlY3Rpb24gYXMgSFRNTCwgZGVmYXVsdHMgdG8gZmFsc2UuXG5cdCAqL1xuXHRjb3B5U2VsZWN0aW9uKGNvcHlBc0h0bWw/OiBib29sZWFuLCBjb21tYW5kPzogSVRlcm1pbmFsQ29tbWFuZCk6IHZvaWQ7XG5cdC8qKlxuXHQgKiBGb2N1c2VzIHRoZSB0ZXJtaW5hbC4gV2FybmluZzoge0BsaW5rIElUZXJtaW5hbEluc3RhbmNlLmZvY3VzfSBzaG91bGQgYmVcblx0ICogcHJlZmVycmVkIHdoZW4gZGVhbGluZyB3aXRoIHRlcm1pbmFsIGluc3RhbmNlcyBpbiBvcmRlciB0byBnZXRcblx0ICogYWNjZXNzaWJpbGl0eSB0cmlnZ2Vycy5cblx0ICovXG5cdGZvY3VzKCk6IHZvaWQ7XG5cblx0LyoqIFNjcm9sbCB0aGUgdGVybWluYWwgYnVmZmVyIGRvd24gMSBsaW5lLiAgICovIHNjcm9sbERvd25MaW5lKCk6IHZvaWQ7XG5cdC8qKiBTY3JvbGwgdGhlIHRlcm1pbmFsIGJ1ZmZlciBkb3duIDEgcGFnZS4gICAqLyBzY3JvbGxEb3duUGFnZSgpOiB2b2lkO1xuXHQvKiogU2Nyb2xsIHRoZSB0ZXJtaW5hbCBidWZmZXIgdG8gdGhlIGJvdHRvbS4gKi8gc2Nyb2xsVG9Cb3R0b20oKTogdm9pZDtcblx0LyoqIFNjcm9sbCB0aGUgdGVybWluYWwgYnVmZmVyIHVwIDEgbGluZS4gICAgICovIHNjcm9sbFVwTGluZSgpOiB2b2lkO1xuXHQvKiogU2Nyb2xsIHRoZSB0ZXJtaW5hbCBidWZmZXIgdXAgMSBwYWdlLiAgICAgKi8gc2Nyb2xsVXBQYWdlKCk6IHZvaWQ7XG5cdC8qKiBTY3JvbGwgdGhlIHRlcm1pbmFsIGJ1ZmZlciB0byB0aGUgdG9wLiAgICAqLyBzY3JvbGxUb1RvcCgpOiB2b2lkO1xuXHQvKiogU2Nyb2xsIHRoZSB0ZXJtaW5hbCBidWZmZXIgdG8gYSBzZXQgbGluZSAgKi8gc2Nyb2xsVG9MaW5lKGxpbmU6IG51bWJlciwgcG9zaXRpb24/OiBTY3JvbGxQb3NpdGlvbik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGUgdGVybWluYWwgYnVmZmVyLCBsZWF2aW5nIG9ubHkgdGhlIHByb21wdCBsaW5lIGFuZCBtb3ZpbmcgaXQgdG8gdGhlIHRvcCBvZiB0aGVcblx0ICogdmlld3BvcnQuXG5cdCAqL1xuXHRjbGVhckJ1ZmZlcigpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIHNlYXJjaCByZXN1bHQgZGVjb3JhdGlvbnNcblx0ICovXG5cdGNsZWFyU2VhcmNoRGVjb3JhdGlvbnMoKTogdm9pZDtcblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBhY3RpdmUgc2VhcmNoIHJlc3VsdCBkZWNvcmF0aW9uc1xuXHQgKi9cblx0Y2xlYXJBY3RpdmVTZWFyY2hEZWNvcmF0aW9uKCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSByZXZlcnNlIGl0ZXJhdG9yIG9mIGJ1ZmZlciBsaW5lcyBhcyBzdHJpbmdzXG5cdCAqL1xuXHRnZXRCdWZmZXJSZXZlcnNlSXRlcmF0b3IoKTogSXRlcmFibGVJdGVyYXRvcjxzdHJpbmc+O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjb250ZW50cyBvZiB0aGUgYnVmZmVyIGZyb20gYSBzdGFydCBtYXJrZXIgKG9yIGxpbmUgMCkgdG8gdGhlIGVuZCBtYXJrZXIgKG9yIHRoZVxuXHQgKiBsYXN0IGxpbmUpLlxuXHQgKi9cblx0Z2V0Q29udGVudHNBc1RleHQoc3RhcnRNYXJrZXI/OiBJWHRlcm1NYXJrZXIsIGVuZE1hcmtlcj86IElYdGVybU1hcmtlcik6IHN0cmluZztcblxuXHQvKipcblx0ICogR2V0cyB0aGUgYnVmZmVyIGNvbnRlbnRzIGFzIEhUTUwuXG5cdCAqL1xuXHRnZXRDb250ZW50c0FzSHRtbCgpOiBQcm9taXNlPHN0cmluZz47XG5cblx0LyoqXG5cdCAqIFJlZnJlc2hlcyB0aGUgdGVybWluYWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbW92ZWQuXG5cdCAqL1xuXHRyZWZyZXNoKCk6IHZvaWQ7XG5cblx0Z2V0WHRlcm1UaGVtZSh0aGVtZT86IElDb2xvclRoZW1lKTogSVRoZW1lO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEZXRhY2hlZFh0ZXJtVGVybWluYWwgZXh0ZW5kcyBJWHRlcm1UZXJtaW5hbCB7XG5cdC8qKlxuXHQgKiBXcml0ZXMgZGF0YSB0byB0aGUgdGVybWluYWwuXG5cdCAqIEBwYXJhbSBkYXRhIGRhdGEgdG8gd3JpdGVcblx0ICogQHBhcmFtIGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgZmlyZXMgd2hlbiB0aGUgZGF0YSB3YXMgcHJvY2Vzc2VkXG5cdCAqIGJ5IHRoZSBwYXJzZXIuXG5cdCAqL1xuXHR3cml0ZShkYXRhOiBzdHJpbmcgfCBVaW50OEFycmF5LCBjYWxsYmFjaz86ICgpID0+IHZvaWQpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSZXNpemVzIHRoZSB0ZXJtaW5hbC5cblx0ICovXG5cdHJlc2l6ZShjb2x1bW5zOiBudW1iZXIsIHJvd3M6IG51bWJlcik6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUludGVybmFsWHRlcm1UZXJtaW5hbCB7XG5cdC8qKlxuXHQgKiBXcml0ZXMgdGV4dCBkaXJlY3RseSB0byB0aGUgdGVybWluYWwsIGJ5cGFzc2luZyB0aGUgcHJvY2Vzcy5cblx0ICpcblx0ICogKipXQVJOSU5HOioqIFRoaXMgc2hvdWxkIG5ldmVyIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgdGVybWluYWwgY29tcG9uZW50IGFuZCBvbmx5IGZvclxuXHQgKiBkZXZlbG9wZXIgcHVycG9zZWQgaW5zaWRlIHRoZSB0ZXJtaW5hbCBjb21wb25lbnQuXG5cdCAqL1xuXHRfd3JpdGVUZXh0KGRhdGE6IHN0cmluZyk6IHZvaWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVh0ZXJtQ29sb3JQcm92aWRlciB7XG5cdGdldEJhY2tncm91bmRDb2xvcih0aGVtZTogSUNvbG9yVGhlbWUpOiBDb2xvciB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUmVxdWVzdEFkZEluc3RhbmNlVG9Hcm91cEV2ZW50IHtcblx0dXJpOiBVUkk7XG5cdHNpZGU6ICdiZWZvcmUnIHwgJ2FmdGVyJztcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gTGludXhEaXN0cm8ge1xuXHRVbmtub3duID0gMSxcblx0RmVkb3JhID0gMixcblx0VWJ1bnR1ID0gMyxcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gVGVybWluYWxEYXRhVHJhbnNmZXJzIHtcblx0VGVybWluYWxzID0gJ1Rlcm1pbmFscydcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFtaEJPO0lBQUFBLGNBQUEsWUFBQUEsQ0FBQTtNQUFBLE9BQUFDLGNBQUE7SUFBQTtFQUFBO0VBQUEsT0FBQUEsY0FBQTtBQUFBO0FBQUFELGNBQUE7QUFuaEJQOzs7O0FBWUEsU0FBU0UsZUFBZSxRQUFRLDREQUE0RDtBQTBCNUYsT0FBTyxNQUFNQyxnQkFBZ0I7QUFBQTtBQUFBLENBQUFILGNBQUEsR0FBQUksQ0FBQSxPQUFHRixlQUFlLENBQW1CLGlCQUFpQixDQUFDO0FBQ3BGLE9BQU8sTUFBTUcsNkJBQTZCO0FBQUE7QUFBQSxDQUFBTCxjQUFBLEdBQUFJLENBQUEsT0FBR0YsZUFBZSxDQUFnQyw4QkFBOEIsQ0FBQztBQUMzSCxPQUFPLE1BQU1JLHNCQUFzQjtBQUFBO0FBQUEsQ0FBQU4sY0FBQSxHQUFBSSxDQUFBLE9BQUdGLGVBQWUsQ0FBeUIsdUJBQXVCLENBQUM7QUFDdEcsT0FBTyxNQUFNSyx1QkFBdUI7QUFBQTtBQUFBLENBQUFQLGNBQUEsR0FBQUksQ0FBQSxPQUFHRixlQUFlLENBQTBCLHdCQUF3QixDQUFDO0FBQ3pHLE9BQU8sTUFBTU0scUJBQXFCO0FBQUE7QUFBQSxDQUFBUixjQUFBLEdBQUFJLENBQUEsT0FBR0YsZUFBZSxDQUF3QixzQkFBc0IsQ0FBQztBQUNuRyxPQUFPLE1BQU1PLHdCQUF3QjtBQUFBO0FBQUEsQ0FBQVQsY0FBQSxHQUFBSSxDQUFBLE9BQUdGLGVBQWUsQ0FBMkIseUJBQXlCLENBQUM7QUFDNUcsT0FBTyxNQUFNUSxvQkFBb0I7QUFBQTtBQUFBLENBQUFWLGNBQUEsR0FBQUksQ0FBQSxPQUFHRixlQUFlLENBQXVCLHFCQUFxQixDQUFDO0FBQUM7QUFBQUYsY0FBQSxHQUFBSSxDQUFBO0FBZ1RqRyxPQUFPLE1BQU1PLDBCQUEwQixHQUFJQyxDQUFnRCxJQUFxQztFQUFBO0VBQUFaLGNBQUEsR0FBQWEsQ0FBQTtFQUFBYixjQUFBLEdBQUFJLENBQUE7RUFBQSxjQUFRUSxDQUF1QixDQUFDRSxVQUFVLEtBQUssUUFBUTtBQUFSLENBQVE7QUE2SnZMLE9BQU0sTUFBT0MsMEJBQTJCLFNBQVFDLFVBQVU7QUEwQjFELE9BQU8sTUFBTUMsZ0JBQWdCO0FBQUE7QUFBQSxDQUFBakIsY0FBQSxHQUFBSSxDQUFBLE9BQUcsZ0JBQWdCIiwiaWdub3JlTGlzdCI6W119
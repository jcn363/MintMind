bbe81e668df21350df8134f12c9bab15
/* istanbul ignore next */
function cov_hzkvjpx9s() {
  var path = "/home/user/Desktop/MintMind/src/vs/workbench/contrib/mcp/common/mcpRegistryTypes.ts";
  var hash = "7ee2dc1de6a8c19249194059c2a273a437167d74";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/user/Desktop/MintMind/src/vs/workbench/contrib/mcp/common/mcpRegistryTypes.ts",
    statementMap: {
      "0": {
        start: {
          line: 6,
          column: 28
        },
        end: {
          line: 6,
          column: 58
        }
      }
    },
    fnMap: {},
    branchMap: {},
    s: {
      "0": 0
    },
    f: {},
    b: {},
    inputSourceMap: {
      file: "/home/user/Desktop/MintMind/src/vs/workbench/contrib/mcp/common/mcpRegistryTypes.ts",
      mappings: "AAAA;;;gGAGgG;AAMhG,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AAQ7F,MAAM,CAAC,MAAM,YAAY,GAAG,eAAe,CAAe,aAAa,CAAC,CAAC",
      names: [],
      sources: ["/home/user/Desktop/MintMind/src/vs/workbench/contrib/mcp/common/mcpRegistryTypes.ts"],
      sourcesContent: ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { IObservable } from '../../../../base/common/observable.js';\nimport { ConfigurationTarget } from '../../../../platform/configuration/common/configuration.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogger, LogLevel } from '../../../../platform/log/common/log.js';\nimport { StorageScope } from '../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolderData } from '../../../../platform/workspace/common/workspace.js';\nimport { IResolvedValue } from '../../../services/configurationResolver/common/configurationResolverExpression.js';\nimport { IMcpServerConnection, LazyCollectionState, McpCollectionDefinition, McpCollectionReference, McpConnectionState, McpDefinitionReference, McpServerDefinition, McpServerLaunch, McpStartServerInteraction } from './mcpTypes.js';\nimport { MCP } from './modelContextProtocol.js';\n\nexport const IMcpRegistry = createDecorator<IMcpRegistry>('mcpRegistry');\n\n/** Message transport to a single MCP server. */\nexport interface IMcpMessageTransport extends IDisposable {\n\treadonly state: IObservable<McpConnectionState>;\n\treadonly onDidLog: Event<{ level: LogLevel; message: string }>;\n\treadonly onDidReceiveMessage: Event<MCP.JSONRPCMessage>;\n\tsend(message: MCP.JSONRPCMessage): void;\n\tstop(): void;\n}\n\nexport interface IMcpHostDelegate {\n\t/** Priority for this delegate, delegates are tested in descending priority order */\n\treadonly priority: number;\n\twaitForInitialProviderPromises(): Promise<void>;\n\tcanStart(collectionDefinition: McpCollectionDefinition, serverDefinition: McpServerDefinition): boolean;\n\tsubstituteVariables(serverDefinition: McpServerDefinition, launch: McpServerLaunch): Promise<McpServerLaunch>;\n\tstart(collectionDefinition: McpCollectionDefinition, serverDefinition: McpServerDefinition, resolvedLaunch: McpServerLaunch, options?: { errorOnUserInteraction?: boolean }): IMcpMessageTransport;\n}\n\nexport interface IMcpResolveConnectionOptions {\n\tlogger: ILogger;\n\tinteraction?: McpStartServerInteraction;\n\tcollectionRef: McpCollectionReference;\n\tdefinitionRef: McpDefinitionReference;\n\n\t/** A reference (on the server) to its last nonce where trust was given. */\n\ttrustNonceBearer: { trustedAtNonce: string | undefined };\n\t/**\n\t * When to trigger the trust prompt.\n\t * - only-new: only prompt for servers that are not previously explicitly untrusted (default)\n\t * - all-untrusted: prompt for all servers that are not trusted\n\t * - never: don't prompt, fail silently when trying to start an untrusted server\n\t */\n\tpromptType?: 'only-new' | 'all-untrusted' | 'never';\n\t/**\n\t * Automatically trust if changed. This should ONLY be set for afforances that\n\t * ensure the user sees the config before it gets started (e.g. code lenses)\n\t */\n\tautoTrustChanges?: boolean;\n\n\t/** If set, try to launch with debugging when dev mode is configured */\n\tdebug?: boolean;\n\n\t/** If true, throw an error if any user interaction would be required during startup. */\n\terrorOnUserInteraction?: boolean;\n}\n\nexport interface IMcpRegistry {\n\treadonly _serviceBrand: undefined;\n\n\t/** Fired when the user provides more inputs when creating a connection. */\n\treadonly onDidChangeInputs: Event<void>;\n\n\treadonly collections: IObservable<readonly McpCollectionDefinition[]>;\n\treadonly delegates: IObservable<readonly IMcpHostDelegate[]>;\n\t/** Whether there are new collections that can be resolved with a discover() call */\n\treadonly lazyCollectionState: IObservable<{ state: LazyCollectionState; collections: McpCollectionDefinition[] }>;\n\n\t/** Helper function to observe a definition by its reference. */\n\tgetServerDefinition(collectionRef: McpDefinitionReference, definitionRef: McpDefinitionReference): IObservable<{ server: McpServerDefinition | undefined; collection: McpCollectionDefinition | undefined }>;\n\n\t/** Discover new collections, returning newly-discovered ones. */\n\tdiscoverCollections(): Promise<McpCollectionDefinition[]>;\n\n\tregisterDelegate(delegate: IMcpHostDelegate): IDisposable;\n\tregisterCollection(collection: McpCollectionDefinition): IDisposable;\n\n\t/** Resets any saved inputs for the input, or globally. */\n\tclearSavedInputs(scope: StorageScope, inputId?: string): Promise<void>;\n\t/** Edits a previously-saved input. */\n\teditSavedInput(inputId: string, folderData: IWorkspaceFolderData | undefined, configSection: string, target: ConfigurationTarget): Promise<void>;\n\t/** Updates a saved input. */\n\tsetSavedInput(inputId: string, target: ConfigurationTarget, value: string): Promise<void>;\n\t/** Gets saved inputs from storage. */\n\tgetSavedInputs(scope: StorageScope): Promise<{ [id: string]: IResolvedValue }>;\n\t/** Creates a connection for the collection and definition. */\n\tresolveConnection(options: IMcpResolveConnectionOptions): Promise<IMcpServerConnection | undefined>;\n}\n"],
      version: 3
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "7ee2dc1de6a8c19249194059c2a273a437167d74"
  };
  var coverage = global[gcv] || (global[gcv] = {});
  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }
  var actualCoverage = coverage[path];
  {
    // @ts-ignore
    cov_hzkvjpx9s = function () {
      return actualCoverage;
    };
  }
  return actualCoverage;
}
cov_hzkvjpx9s();
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';
export const IMcpRegistry =
/* istanbul ignore next */
(cov_hzkvjpx9s().s[0]++, createDecorator('mcpRegistry'));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjcmVhdGVEZWNvcmF0b3IiLCJJTWNwUmVnaXN0cnkiLCJjb3ZfaHprdmpweDlzIiwicyJdLCJzb3VyY2VzIjpbIi9ob21lL3VzZXIvRGVza3RvcC9NaW50TWluZC9zcmMvdnMvd29ya2JlbmNoL2NvbnRyaWIvbWNwL2NvbW1vbi9tY3BSZWdpc3RyeVR5cGVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2V2ZW50LmpzJztcbmltcG9ydCB7IElEaXNwb3NhYmxlIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IElPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vb2JzZXJ2YWJsZS5qcyc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uVGFyZ2V0IH0gZnJvbSAnLi4vLi4vLi4vLi4vcGxhdGZvcm0vY29uZmlndXJhdGlvbi9jb21tb24vY29uZmlndXJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVEZWNvcmF0b3IgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS9pbnN0YW50aWF0aW9uL2NvbW1vbi9pbnN0YW50aWF0aW9uLmpzJztcbmltcG9ydCB7IElMb2dnZXIsIExvZ0xldmVsIH0gZnJvbSAnLi4vLi4vLi4vLi4vcGxhdGZvcm0vbG9nL2NvbW1vbi9sb2cuanMnO1xuaW1wb3J0IHsgU3RvcmFnZVNjb3BlIH0gZnJvbSAnLi4vLi4vLi4vLi4vcGxhdGZvcm0vc3RvcmFnZS9jb21tb24vc3RvcmFnZS5qcyc7XG5pbXBvcnQgeyBJV29ya3NwYWNlRm9sZGVyRGF0YSB9IGZyb20gJy4uLy4uLy4uLy4uL3BsYXRmb3JtL3dvcmtzcGFjZS9jb21tb24vd29ya3NwYWNlLmpzJztcbmltcG9ydCB7IElSZXNvbHZlZFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvY29uZmlndXJhdGlvblJlc29sdmVyL2NvbW1vbi9jb25maWd1cmF0aW9uUmVzb2x2ZXJFeHByZXNzaW9uLmpzJztcbmltcG9ydCB7IElNY3BTZXJ2ZXJDb25uZWN0aW9uLCBMYXp5Q29sbGVjdGlvblN0YXRlLCBNY3BDb2xsZWN0aW9uRGVmaW5pdGlvbiwgTWNwQ29sbGVjdGlvblJlZmVyZW5jZSwgTWNwQ29ubmVjdGlvblN0YXRlLCBNY3BEZWZpbml0aW9uUmVmZXJlbmNlLCBNY3BTZXJ2ZXJEZWZpbml0aW9uLCBNY3BTZXJ2ZXJMYXVuY2gsIE1jcFN0YXJ0U2VydmVySW50ZXJhY3Rpb24gfSBmcm9tICcuL21jcFR5cGVzLmpzJztcbmltcG9ydCB7IE1DUCB9IGZyb20gJy4vbW9kZWxDb250ZXh0UHJvdG9jb2wuanMnO1xuXG5leHBvcnQgY29uc3QgSU1jcFJlZ2lzdHJ5ID0gY3JlYXRlRGVjb3JhdG9yPElNY3BSZWdpc3RyeT4oJ21jcFJlZ2lzdHJ5Jyk7XG5cbi8qKiBNZXNzYWdlIHRyYW5zcG9ydCB0byBhIHNpbmdsZSBNQ1Agc2VydmVyLiAqL1xuZXhwb3J0IGludGVyZmFjZSBJTWNwTWVzc2FnZVRyYW5zcG9ydCBleHRlbmRzIElEaXNwb3NhYmxlIHtcblx0cmVhZG9ubHkgc3RhdGU6IElPYnNlcnZhYmxlPE1jcENvbm5lY3Rpb25TdGF0ZT47XG5cdHJlYWRvbmx5IG9uRGlkTG9nOiBFdmVudDx7IGxldmVsOiBMb2dMZXZlbDsgbWVzc2FnZTogc3RyaW5nIH0+O1xuXHRyZWFkb25seSBvbkRpZFJlY2VpdmVNZXNzYWdlOiBFdmVudDxNQ1AuSlNPTlJQQ01lc3NhZ2U+O1xuXHRzZW5kKG1lc3NhZ2U6IE1DUC5KU09OUlBDTWVzc2FnZSk6IHZvaWQ7XG5cdHN0b3AoKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWNwSG9zdERlbGVnYXRlIHtcblx0LyoqIFByaW9yaXR5IGZvciB0aGlzIGRlbGVnYXRlLCBkZWxlZ2F0ZXMgYXJlIHRlc3RlZCBpbiBkZXNjZW5kaW5nIHByaW9yaXR5IG9yZGVyICovXG5cdHJlYWRvbmx5IHByaW9yaXR5OiBudW1iZXI7XG5cdHdhaXRGb3JJbml0aWFsUHJvdmlkZXJQcm9taXNlcygpOiBQcm9taXNlPHZvaWQ+O1xuXHRjYW5TdGFydChjb2xsZWN0aW9uRGVmaW5pdGlvbjogTWNwQ29sbGVjdGlvbkRlZmluaXRpb24sIHNlcnZlckRlZmluaXRpb246IE1jcFNlcnZlckRlZmluaXRpb24pOiBib29sZWFuO1xuXHRzdWJzdGl0dXRlVmFyaWFibGVzKHNlcnZlckRlZmluaXRpb246IE1jcFNlcnZlckRlZmluaXRpb24sIGxhdW5jaDogTWNwU2VydmVyTGF1bmNoKTogUHJvbWlzZTxNY3BTZXJ2ZXJMYXVuY2g+O1xuXHRzdGFydChjb2xsZWN0aW9uRGVmaW5pdGlvbjogTWNwQ29sbGVjdGlvbkRlZmluaXRpb24sIHNlcnZlckRlZmluaXRpb246IE1jcFNlcnZlckRlZmluaXRpb24sIHJlc29sdmVkTGF1bmNoOiBNY3BTZXJ2ZXJMYXVuY2gsIG9wdGlvbnM/OiB7IGVycm9yT25Vc2VySW50ZXJhY3Rpb24/OiBib29sZWFuIH0pOiBJTWNwTWVzc2FnZVRyYW5zcG9ydDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWNwUmVzb2x2ZUNvbm5lY3Rpb25PcHRpb25zIHtcblx0bG9nZ2VyOiBJTG9nZ2VyO1xuXHRpbnRlcmFjdGlvbj86IE1jcFN0YXJ0U2VydmVySW50ZXJhY3Rpb247XG5cdGNvbGxlY3Rpb25SZWY6IE1jcENvbGxlY3Rpb25SZWZlcmVuY2U7XG5cdGRlZmluaXRpb25SZWY6IE1jcERlZmluaXRpb25SZWZlcmVuY2U7XG5cblx0LyoqIEEgcmVmZXJlbmNlIChvbiB0aGUgc2VydmVyKSB0byBpdHMgbGFzdCBub25jZSB3aGVyZSB0cnVzdCB3YXMgZ2l2ZW4uICovXG5cdHRydXN0Tm9uY2VCZWFyZXI6IHsgdHJ1c3RlZEF0Tm9uY2U6IHN0cmluZyB8IHVuZGVmaW5lZCB9O1xuXHQvKipcblx0ICogV2hlbiB0byB0cmlnZ2VyIHRoZSB0cnVzdCBwcm9tcHQuXG5cdCAqIC0gb25seS1uZXc6IG9ubHkgcHJvbXB0IGZvciBzZXJ2ZXJzIHRoYXQgYXJlIG5vdCBwcmV2aW91c2x5IGV4cGxpY2l0bHkgdW50cnVzdGVkIChkZWZhdWx0KVxuXHQgKiAtIGFsbC11bnRydXN0ZWQ6IHByb21wdCBmb3IgYWxsIHNlcnZlcnMgdGhhdCBhcmUgbm90IHRydXN0ZWRcblx0ICogLSBuZXZlcjogZG9uJ3QgcHJvbXB0LCBmYWlsIHNpbGVudGx5IHdoZW4gdHJ5aW5nIHRvIHN0YXJ0IGFuIHVudHJ1c3RlZCBzZXJ2ZXJcblx0ICovXG5cdHByb21wdFR5cGU/OiAnb25seS1uZXcnIHwgJ2FsbC11bnRydXN0ZWQnIHwgJ25ldmVyJztcblx0LyoqXG5cdCAqIEF1dG9tYXRpY2FsbHkgdHJ1c3QgaWYgY2hhbmdlZC4gVGhpcyBzaG91bGQgT05MWSBiZSBzZXQgZm9yIGFmZm9yYW5jZXMgdGhhdFxuXHQgKiBlbnN1cmUgdGhlIHVzZXIgc2VlcyB0aGUgY29uZmlnIGJlZm9yZSBpdCBnZXRzIHN0YXJ0ZWQgKGUuZy4gY29kZSBsZW5zZXMpXG5cdCAqL1xuXHRhdXRvVHJ1c3RDaGFuZ2VzPzogYm9vbGVhbjtcblxuXHQvKiogSWYgc2V0LCB0cnkgdG8gbGF1bmNoIHdpdGggZGVidWdnaW5nIHdoZW4gZGV2IG1vZGUgaXMgY29uZmlndXJlZCAqL1xuXHRkZWJ1Zz86IGJvb2xlYW47XG5cblx0LyoqIElmIHRydWUsIHRocm93IGFuIGVycm9yIGlmIGFueSB1c2VyIGludGVyYWN0aW9uIHdvdWxkIGJlIHJlcXVpcmVkIGR1cmluZyBzdGFydHVwLiAqL1xuXHRlcnJvck9uVXNlckludGVyYWN0aW9uPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWNwUmVnaXN0cnkge1xuXHRyZWFkb25seSBfc2VydmljZUJyYW5kOiB1bmRlZmluZWQ7XG5cblx0LyoqIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJvdmlkZXMgbW9yZSBpbnB1dHMgd2hlbiBjcmVhdGluZyBhIGNvbm5lY3Rpb24uICovXG5cdHJlYWRvbmx5IG9uRGlkQ2hhbmdlSW5wdXRzOiBFdmVudDx2b2lkPjtcblxuXHRyZWFkb25seSBjb2xsZWN0aW9uczogSU9ic2VydmFibGU8cmVhZG9ubHkgTWNwQ29sbGVjdGlvbkRlZmluaXRpb25bXT47XG5cdHJlYWRvbmx5IGRlbGVnYXRlczogSU9ic2VydmFibGU8cmVhZG9ubHkgSU1jcEhvc3REZWxlZ2F0ZVtdPjtcblx0LyoqIFdoZXRoZXIgdGhlcmUgYXJlIG5ldyBjb2xsZWN0aW9ucyB0aGF0IGNhbiBiZSByZXNvbHZlZCB3aXRoIGEgZGlzY292ZXIoKSBjYWxsICovXG5cdHJlYWRvbmx5IGxhenlDb2xsZWN0aW9uU3RhdGU6IElPYnNlcnZhYmxlPHsgc3RhdGU6IExhenlDb2xsZWN0aW9uU3RhdGU7IGNvbGxlY3Rpb25zOiBNY3BDb2xsZWN0aW9uRGVmaW5pdGlvbltdIH0+O1xuXG5cdC8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gb2JzZXJ2ZSBhIGRlZmluaXRpb24gYnkgaXRzIHJlZmVyZW5jZS4gKi9cblx0Z2V0U2VydmVyRGVmaW5pdGlvbihjb2xsZWN0aW9uUmVmOiBNY3BEZWZpbml0aW9uUmVmZXJlbmNlLCBkZWZpbml0aW9uUmVmOiBNY3BEZWZpbml0aW9uUmVmZXJlbmNlKTogSU9ic2VydmFibGU8eyBzZXJ2ZXI6IE1jcFNlcnZlckRlZmluaXRpb24gfCB1bmRlZmluZWQ7IGNvbGxlY3Rpb246IE1jcENvbGxlY3Rpb25EZWZpbml0aW9uIHwgdW5kZWZpbmVkIH0+O1xuXG5cdC8qKiBEaXNjb3ZlciBuZXcgY29sbGVjdGlvbnMsIHJldHVybmluZyBuZXdseS1kaXNjb3ZlcmVkIG9uZXMuICovXG5cdGRpc2NvdmVyQ29sbGVjdGlvbnMoKTogUHJvbWlzZTxNY3BDb2xsZWN0aW9uRGVmaW5pdGlvbltdPjtcblxuXHRyZWdpc3RlckRlbGVnYXRlKGRlbGVnYXRlOiBJTWNwSG9zdERlbGVnYXRlKTogSURpc3Bvc2FibGU7XG5cdHJlZ2lzdGVyQ29sbGVjdGlvbihjb2xsZWN0aW9uOiBNY3BDb2xsZWN0aW9uRGVmaW5pdGlvbik6IElEaXNwb3NhYmxlO1xuXG5cdC8qKiBSZXNldHMgYW55IHNhdmVkIGlucHV0cyBmb3IgdGhlIGlucHV0LCBvciBnbG9iYWxseS4gKi9cblx0Y2xlYXJTYXZlZElucHV0cyhzY29wZTogU3RvcmFnZVNjb3BlLCBpbnB1dElkPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcblx0LyoqIEVkaXRzIGEgcHJldmlvdXNseS1zYXZlZCBpbnB1dC4gKi9cblx0ZWRpdFNhdmVkSW5wdXQoaW5wdXRJZDogc3RyaW5nLCBmb2xkZXJEYXRhOiBJV29ya3NwYWNlRm9sZGVyRGF0YSB8IHVuZGVmaW5lZCwgY29uZmlnU2VjdGlvbjogc3RyaW5nLCB0YXJnZXQ6IENvbmZpZ3VyYXRpb25UYXJnZXQpOiBQcm9taXNlPHZvaWQ+O1xuXHQvKiogVXBkYXRlcyBhIHNhdmVkIGlucHV0LiAqL1xuXHRzZXRTYXZlZElucHV0KGlucHV0SWQ6IHN0cmluZywgdGFyZ2V0OiBDb25maWd1cmF0aW9uVGFyZ2V0LCB2YWx1ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcblx0LyoqIEdldHMgc2F2ZWQgaW5wdXRzIGZyb20gc3RvcmFnZS4gKi9cblx0Z2V0U2F2ZWRJbnB1dHMoc2NvcGU6IFN0b3JhZ2VTY29wZSk6IFByb21pc2U8eyBbaWQ6IHN0cmluZ106IElSZXNvbHZlZFZhbHVlIH0+O1xuXHQvKiogQ3JlYXRlcyBhIGNvbm5lY3Rpb24gZm9yIHRoZSBjb2xsZWN0aW9uIGFuZCBkZWZpbml0aW9uLiAqL1xuXHRyZXNvbHZlQ29ubmVjdGlvbihvcHRpb25zOiBJTWNwUmVzb2x2ZUNvbm5lY3Rpb25PcHRpb25zKTogUHJvbWlzZTxJTWNwU2VydmVyQ29ubmVjdGlvbiB8IHVuZGVmaW5lZD47XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQVNBLFNBQVNBLGVBQWUsUUFBUSw0REFBNEQ7QUFRNUYsT0FBTyxNQUFNQyxZQUFZO0FBQUE7QUFBQSxDQUFBQyxhQUFBLEdBQUFDLENBQUEsT0FBR0gsZUFBZSxDQUFlLGFBQWEsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==
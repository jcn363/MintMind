1b0c504054f1708db5d86c6441861dc7
/* istanbul ignore next */
function cov_ekl39dfio() {
  var path = "/home/user/Desktop/MintMind/src/vs/workbench/services/editor/common/editorGroupsService.ts";
  var hash = "6a772b1770bf6d616b78d8e531d4200dcad0bdab";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/user/Desktop/MintMind/src/vs/workbench/services/editor/common/editorGroupsService.ts",
    statementMap: {
      "0": {
        start: {
          line: 7,
          column: 36
        },
        end: {
          line: 7,
          column: 74
        }
      },
      "1": {
        start: {
          line: 9,
          column: 22
        },
        end: {
          line: 9,
          column: 33
        }
      },
      "2": {
        start: {
          line: 10,
          column: 4
        },
        end: {
          line: 10,
          column: 85
        }
      },
      "3": {
        start: {
          line: 13,
          column: 18
        },
        end: {
          line: 13,
          column: 21
        }
      },
      "4": {
        start: {
          line: 14,
          column: 4
        },
        end: {
          line: 14,
          column: 83
        }
      },
      "5": {
        start: {
          line: 18,
          column: 36
        },
        end: {
          line: 18,
          column: 109
        }
      },
      "6": {
        start: {
          line: 19,
          column: 4
        },
        end: {
          line: 21,
          column: 5
        }
      },
      "7": {
        start: {
          line: 20,
          column: 8
        },
        end: {
          line: 20,
          column: 43
        }
      },
      "8": {
        start: {
          line: 22,
          column: 4
        },
        end: {
          line: 22,
          column: 40
        }
      }
    },
    fnMap: {
      "0": {
        name: "isEditorReplacement",
        decl: {
          start: {
            line: 8,
            column: 16
          },
          end: {
            line: 8,
            column: 35
          }
        },
        loc: {
          start: {
            line: 8,
            column: 49
          },
          end: {
            line: 11,
            column: 1
          }
        },
        line: 8
      },
      "1": {
        name: "isEditorGroup",
        decl: {
          start: {
            line: 12,
            column: 16
          },
          end: {
            line: 12,
            column: 29
          }
        },
        loc: {
          start: {
            line: 12,
            column: 35
          },
          end: {
            line: 15,
            column: 1
          }
        },
        line: 12
      },
      "2": {
        name: "preferredSideBySideGroupDirection",
        decl: {
          start: {
            line: 17,
            column: 16
          },
          end: {
            line: 17,
            column: 49
          }
        },
        loc: {
          start: {
            line: 17,
            column: 72
          },
          end: {
            line: 23,
            column: 1
          }
        },
        line: 17
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 10,
            column: 11
          },
          end: {
            line: 10,
            column: 84
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 10,
            column: 11
          },
          end: {
            line: 10,
            column: 43
          }
        }, {
          start: {
            line: 10,
            column: 47
          },
          end: {
            line: 10,
            column: 84
          }
        }],
        line: 10
      },
      "1": {
        loc: {
          start: {
            line: 14,
            column: 11
          },
          end: {
            line: 14,
            column: 82
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 14,
            column: 11
          },
          end: {
            line: 14,
            column: 18
          }
        }, {
          start: {
            line: 14,
            column: 22
          },
          end: {
            line: 14,
            column: 50
          }
        }, {
          start: {
            line: 14,
            column: 54
          },
          end: {
            line: 14,
            column: 82
          }
        }],
        line: 14
      },
      "2": {
        loc: {
          start: {
            line: 19,
            column: 4
          },
          end: {
            line: 21,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 19,
            column: 4
          },
          end: {
            line: 21,
            column: 5
          }
        }, {
          start: {
            line: undefined,
            column: undefined
          },
          end: {
            line: undefined,
            column: undefined
          }
        }],
        line: 19
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0, 0],
      "2": [0, 0]
    },
    inputSourceMap: {
      file: "/home/user/Desktop/MintMind/src/vs/workbench/services/editor/common/editorGroupsService.ts",
      mappings: "AAAA;;;gGAGgG;AAGhG,OAAO,EAAyB,eAAe,EAAE,MAAM,4DAA4D,CAAC;AACpH,OAAO,EAAqM,aAAa,EAA4G,MAAM,2BAA2B,CAAC;AAavW,MAAM,CAAC,MAAM,oBAAoB,GAAG,eAAe,CAAuB,qBAAqB,CAAC,CAAC;AAwHjG,MAAM,UAAU,mBAAmB,CAAC,WAAoB;IACvD,MAAM,SAAS,GAAG,WAA6C,CAAC;IAEhE,OAAO,aAAa,CAAC,SAAS,EAAE,MAAM,CAAC,IAAI,aAAa,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;AAClF,CAAC;AA4yBD,MAAM,UAAU,aAAa,CAAC,GAAY;IACzC,MAAM,KAAK,GAAG,GAA+B,CAAC;IAE9C,OAAO,CAAC,CAAC,KAAK,IAAI,OAAO,KAAK,CAAC,EAAE,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;AAChF,CAAC;AAED,8BAA8B;AAE9B,MAAM,UAAU,iCAAiC,CAAC,oBAA2C;IAC5F,MAAM,uBAAuB,GAAG,oBAAoB,CAAC,QAAQ,CAAC,0CAA0C,CAAC,CAAC;IAE1G,IAAI,uBAAuB,KAAK,MAAM,EAAE,CAAC;QACxC,mCAA2B;IAC5B,CAAC;IAED,oCAA4B;AAC7B,CAAC;AAED,YAAY",
      names: [],
      sources: ["/home/user/Desktop/MintMind/src/vs/workbench/services/editor/common/editorGroupsService.ts"],
      sourcesContent: ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { IInstantiationService, createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IEditorPane, GroupIdentifier, EditorInputWithOptions, CloseDirection, IEditorPartOptions, IEditorPartOptionsChangeEvent, EditorsOrder, IVisibleEditorPane, IEditorCloseEvent, IUntypedEditorInput, isEditorInput, IEditorWillMoveEvent, IMatchEditorOptions, IActiveEditorChangeEvent, IFindEditorOptions, IToolbarActions } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorOptions } from '../../../../platform/editor/common/editor.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IDimension } from '../../../../editor/common/core/2d/dimension.js';\nimport { DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ContextKeyValue, IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IGroupModelChangeEvent } from '../../../common/editor/editorGroupModel.js';\nimport { IRectangle } from '../../../../platform/window/common/window.js';\nimport { IMenuChangeEvent, MenuId } from '../../../../platform/actions/common/actions.js';\nimport { DeepPartial } from '../../../../base/common/types.js';\n\nexport const IEditorGroupsService = createDecorator<IEditorGroupsService>('editorGroupsService');\n\nexport const enum GroupDirection {\n\tUP,\n\tDOWN,\n\tLEFT,\n\tRIGHT\n}\n\nexport const enum GroupOrientation {\n\tHORIZONTAL,\n\tVERTICAL\n}\n\nexport const enum GroupLocation {\n\tFIRST,\n\tLAST,\n\tNEXT,\n\tPREVIOUS\n}\n\nexport interface IFindGroupScope {\n\treadonly direction?: GroupDirection;\n\treadonly location?: GroupLocation;\n}\n\nexport const enum GroupsArrangement {\n\t/**\n\t * Make the current active group consume the entire\n\t * editor area.\n\t */\n\tMAXIMIZE,\n\n\t/**\n\t * Make the current active group consume the maximum\n\t * amount of space possible.\n\t */\n\tEXPAND,\n\n\t/**\n\t * Size all groups evenly.\n\t */\n\tEVEN\n}\n\nexport interface GroupLayoutArgument {\n\n\t/**\n\t * Only applies when there are multiple groups\n\t * arranged next to each other in a row or column.\n\t * If provided, their sum must be 1 to be applied\n\t * per row or column.\n\t */\n\treadonly size?: number;\n\n\t/**\n\t * Editor groups  will be laid out orthogonal to the\n\t * parent orientation.\n\t */\n\treadonly groups?: GroupLayoutArgument[];\n}\n\nexport interface EditorGroupLayout {\n\n\t/**\n\t * The initial orientation of the editor groups at the root.\n\t */\n\treadonly orientation: GroupOrientation;\n\n\t/**\n\t * The editor groups at the root of the layout.\n\t */\n\treadonly groups: GroupLayoutArgument[];\n}\n\nexport const enum MergeGroupMode {\n\tCOPY_EDITORS,\n\tMOVE_EDITORS\n}\n\nexport interface IMergeGroupOptions {\n\tmode?: MergeGroupMode;\n\treadonly index?: number;\n\n\t/**\n\t * Set this to prevent editors already present in the\n\t * target group from moving to a different index as\n\t * they are in the source group.\n\t */\n\treadonly preserveExistingIndex?: boolean;\n}\n\nexport interface ICloseEditorOptions {\n\treadonly preserveFocus?: boolean;\n}\n\nexport type ICloseEditorsFilter = {\n\treadonly except?: EditorInput;\n\treadonly direction?: CloseDirection;\n\treadonly savedOnly?: boolean;\n\treadonly excludeSticky?: boolean;\n};\n\nexport interface ICloseAllEditorsOptions {\n\treadonly excludeSticky?: boolean;\n\treadonly excludeConfirming?: boolean;\n}\n\nexport interface IEditorReplacement {\n\treadonly editor: EditorInput;\n\treadonly replacement: EditorInput;\n\treadonly options?: IEditorOptions;\n\n\t/**\n\t * Skips asking the user for confirmation and doesn't\n\t * save the document. Only use this if you really need to!\n\t */\n\treadonly forceReplaceDirty?: boolean;\n}\n\nexport function isEditorReplacement(replacement: unknown): replacement is IEditorReplacement {\n\tconst candidate = replacement as IEditorReplacement | undefined;\n\n\treturn isEditorInput(candidate?.editor) && isEditorInput(candidate?.replacement);\n}\n\nexport const enum GroupsOrder {\n\n\t/**\n\t * Groups sorted by creation order (oldest one first)\n\t */\n\tCREATION_TIME,\n\n\t/**\n\t * Groups sorted by most recent activity (most recent active first)\n\t */\n\tMOST_RECENTLY_ACTIVE,\n\n\t/**\n\t * Groups sorted by grid widget order\n\t */\n\tGRID_APPEARANCE\n}\n\nexport interface IEditorSideGroup {\n\n\t/**\n\t * Open an editor in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor.\n\t */\n\topenEditor(editor: EditorInput, options?: IEditorOptions): Promise<IEditorPane | undefined>;\n}\n\nexport interface IEditorDropTargetDelegate {\n\n\t/**\n\t * A helper to figure out if the drop target contains the provided group.\n\t */\n\tcontainsGroup?(groupView: IEditorGroup): boolean;\n}\n\n/**\n * The basic primitive to work with editor groups. This interface is both implemented\n * by editor part component as well as the editor groups service that operates across\n * all opened editor parts.\n */\nexport interface IEditorGroupsContainer {\n\n\t/**\n\t * An event for when the active editor group changes. The active editor\n\t * group is the default location for new editors to open.\n\t */\n\treadonly onDidChangeActiveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a new group was added.\n\t */\n\treadonly onDidAddGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group was removed.\n\t */\n\treadonly onDidRemoveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group was moved.\n\t */\n\treadonly onDidMoveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group gets activated.\n\t */\n\treadonly onDidActivateGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when the index of a group changes.\n\t */\n\treadonly onDidChangeGroupIndex: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when the locked state of a group changes.\n\t */\n\treadonly onDidChangeGroupLocked: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when the maximized state of a group changes.\n\t */\n\treadonly onDidChangeGroupMaximized: Event<boolean>;\n\n\t/**\n\t * An event that notifies when container options change.\n\t */\n\treadonly onDidChangeEditorPartOptions: Event<IEditorPartOptionsChangeEvent>;\n\n\t/**\n\t * A property that indicates when groups have been created\n\t * and are ready to be used in the container.\n\t */\n\treadonly isReady: boolean;\n\n\t/**\n\t * A promise that resolves when groups have been created\n\t * and are ready to be used in the container.\n\t *\n\t * Await this promise to safely work on the editor groups model\n\t * (for example, install editor group listeners).\n\t *\n\t * Use the `whenRestored` property to await visible editors\n\t * having fully resolved.\n\t */\n\treadonly whenReady: Promise<void>;\n\n\t/**\n\t * A promise that resolves when groups have been restored in\n\t * the container.\n\t *\n\t * For groups with active editor, the promise will resolve\n\t * when the visible editor has finished to resolve.\n\t *\n\t * Use the `whenReady` property to not await editors to\n\t * resolve.\n\t */\n\treadonly whenRestored: Promise<void>;\n\n\t/**\n\t * Find out if the container has UI state to restore\n\t * from a previous session.\n\t */\n\treadonly hasRestorableState: boolean;\n\n\t/**\n\t * An active group is the default location for new editors to open.\n\t */\n\treadonly activeGroup: IEditorGroup;\n\n\t/**\n\t * A side group allows a subset of methods on a group that is either\n\t * created to the side or picked if already there.\n\t */\n\treadonly sideGroup: IEditorSideGroup;\n\n\t/**\n\t * All groups that are currently visible in the container in the order\n\t * of their creation (oldest first).\n\t */\n\treadonly groups: readonly IEditorGroup[];\n\n\t/**\n\t * The number of editor groups that are currently opened in the\n\t * container.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * The current layout orientation of the root group.\n\t */\n\treadonly orientation: GroupOrientation;\n\n\t/**\n\t * Access the options of the container.\n\t */\n\treadonly partOptions: IEditorPartOptions;\n\n\t/**\n\t * Enforce container options temporarily.\n\t */\n\tenforcePartOptions(options: DeepPartial<IEditorPartOptions>): IDisposable;\n\n\t/**\n\t * Get all groups that are currently visible in the container.\n\t *\n\t * @param order the order of the editors to use\n\t */\n\tgetGroups(order: GroupsOrder): readonly IEditorGroup[];\n\n\t/**\n\t * Allows to convert a group identifier to a group.\n\t */\n\tgetGroup(identifier: GroupIdentifier): IEditorGroup | undefined;\n\n\t/**\n\t * Set a group as active. An active group is the default location for new editors to open.\n\t */\n\tactivateGroup(group: IEditorGroup | GroupIdentifier): IEditorGroup;\n\n\t/**\n\t * Returns the size of a group.\n\t */\n\tgetSize(group: IEditorGroup | GroupIdentifier): { width: number; height: number };\n\n\t/**\n\t * Sets the size of a group.\n\t */\n\tsetSize(group: IEditorGroup | GroupIdentifier, size: { width: number; height: number }): void;\n\n\t/**\n\t * Arrange all groups in the container according to the provided arrangement.\n\t */\n\tarrangeGroups(arrangement: GroupsArrangement, target?: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Toggles the target goup size to maximize/unmaximize.\n\t */\n\ttoggleMaximizeGroup(group?: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Toggles the target goup size to expand/distribute even.\n\t */\n\ttoggleExpandGroup(group?: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Applies the provided layout by either moving existing groups or creating new groups.\n\t */\n\tapplyLayout(layout: EditorGroupLayout): void;\n\n\t/**\n\t * Returns an editor layout of the container.\n\t */\n\tgetLayout(): EditorGroupLayout;\n\n\t/**\n\t * Sets the orientation of the root group to be either vertical or horizontal.\n\t */\n\tsetGroupOrientation(orientation: GroupOrientation): void;\n\n\t/**\n\t * Find a group in a specific scope:\n\t * * `GroupLocation.FIRST`: the first group\n\t * * `GroupLocation.LAST`: the last group\n\t * * `GroupLocation.NEXT`: the next group from either the active one or `source`\n\t * * `GroupLocation.PREVIOUS`: the previous group from either the active one or `source`\n\t * * `GroupDirection.UP`: the next group above the active one or `source`\n\t * * `GroupDirection.DOWN`: the next group below the active one or `source`\n\t * * `GroupDirection.LEFT`: the next group to the left of the active one or `source`\n\t * * `GroupDirection.RIGHT`: the next group to the right of the active one or `source`\n\t *\n\t * @param scope the scope of the group to search in\n\t * @param source optional source to search from\n\t * @param wrap optionally wrap around if reaching the edge of groups\n\t */\n\tfindGroup(scope: IFindGroupScope, source?: IEditorGroup | GroupIdentifier, wrap?: boolean): IEditorGroup | undefined;\n\n\t/**\n\t * Add a new group to the container. A new group is added by splitting a provided one in\n\t * one of the four directions.\n\t *\n\t * @param location the group from which to split to add a new group\n\t * @param direction the direction of where to split to\n\t */\n\taddGroup(location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Remove a group from the container.\n\t */\n\tremoveGroup(group: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Move a group to a new group in the container.\n\t *\n\t * @param group the group to move\n\t * @param location the group from which to split to add the moved group\n\t * @param direction the direction of where to split to\n\t */\n\tmoveGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Merge the editors of a group into a target group. By default, all editors will\n\t * move and the source group will close. This behaviour can be configured via the\n\t * `IMergeGroupOptions` options.\n\t *\n\t * @param group the group to merge\n\t * @param target the target group to merge into\n\t * @param options controls how the merge should be performed. by default all editors\n\t * will be moved over to the target and the source group will close. Configure to\n\t * `MOVE_EDITORS_KEEP_GROUP` to prevent the source group from closing. Set to\n\t * `COPY_EDITORS` to copy the editors into the target instead of moding them.\n\t *\n\t * @returns if merging was successful\n\t */\n\tmergeGroup(group: IEditorGroup | GroupIdentifier, target: IEditorGroup | GroupIdentifier, options?: IMergeGroupOptions): boolean;\n\n\t/**\n\t * Merge all editor groups into the target one.\n\t *\n\t * @returns if merging was successful\n\t */\n\tmergeAllGroups(target: IEditorGroup | GroupIdentifier): boolean;\n\n\t/**\n\t * Copy a group to a new group in the container.\n\t *\n\t * @param group the group to copy\n\t * @param location the group from which to split to add the copied group\n\t * @param direction the direction of where to split to\n\t */\n\tcopyGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Allows to register a drag and drop target for editors\n\t * on the provided `container`.\n\t */\n\tcreateEditorDropTarget(container: unknown /* HTMLElement */, delegate: IEditorDropTargetDelegate): IDisposable;\n}\n\n/**\n * An editor part is a viewer of editor groups. There can be multiple editor\n * parts opened in multiple windows.\n */\nexport interface IEditorPart extends IEditorGroupsContainer {\n\n\t/**\n\t * An event for when the editor part is layed out.\n\t */\n\treadonly onDidLayout: Event<IDimension>;\n\n\t/**\n\t * An event for when the editor part is scrolled.\n\t */\n\treadonly onDidScroll: Event<void>;\n\n\t/**\n\t * An event for when the editor part is disposed.\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * The identifier of the window the editor part is contained in.\n\t */\n\treadonly windowId: number;\n\n\t/**\n\t * The size of the editor part.\n\t */\n\treadonly contentDimension: IDimension;\n\n\t/**\n\t * Find out if an editor group is currently maximized.\n\t */\n\thasMaximizedGroup(): boolean;\n\n\t/**\n\t * Enable or disable centered editor layout.\n\t */\n\tcenterLayout(active: boolean): void;\n\n\t/**\n\t * Find out if the editor layout is currently centered.\n\t */\n\tisLayoutCentered(): boolean;\n}\n\nexport interface IAuxiliaryEditorPart extends IEditorPart {\n\n\t/**\n\t * Close this auxiliary editor part after moving all\n\t * editors of all groups back to the main editor part.\n\t *\n\t * @returns `false` if an editor could not be moved back.\n\t */\n\tclose(): boolean;\n}\n\nexport interface IEditorWorkingSet {\n\treadonly id: string;\n\treadonly name: string;\n}\n\nexport interface IEditorWorkingSetOptions {\n\treadonly preserveFocus?: boolean;\n}\n\nexport interface IEditorGroupContextKeyProvider<T extends ContextKeyValue> {\n\n\t/**\n\t * The context key that needs to be set for each editor group context and the global context.\n\t */\n\treadonly contextKey: RawContextKey<T>;\n\n\t/**\n\t * Retrieves the context key value for the given editor group.\n\t */\n\treadonly getGroupContextKeyValue: (group: IEditorGroup) => T;\n\n\t/**\n\t * An event that is fired when there was a change leading to the context key value to be re-evaluated.\n\t */\n\treadonly onDidChange?: Event<void>;\n}\n\n/**\n * The main service to interact with editor groups across all opened editor parts.\n */\nexport interface IEditorGroupsService extends IEditorGroupsContainer {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event for when a new auxiliary editor part is created.\n\t */\n\treadonly onDidCreateAuxiliaryEditorPart: Event<IAuxiliaryEditorPart>;\n\n\t/**\n\t * Provides access to the main window editor part.\n\t */\n\treadonly mainPart: IEditorPart;\n\n\t/**\n\t * Provides access to all editor parts.\n\t */\n\treadonly parts: ReadonlyArray<IEditorPart>;\n\n\t/**\n\t * Get the editor part that contains the group with the provided identifier.\n\t */\n\tgetPart(group: IEditorGroup | GroupIdentifier): IEditorPart;\n\n\t/**\n\t * Get the editor part that is rooted in the provided container.\n\t */\n\tgetPart(container: unknown /* HTMLElement */): IEditorPart;\n\n\t/**\n\t * Opens a new window with a full editor part instantiated\n\t * in there at the optional position and size on screen.\n\t */\n\tcreateAuxiliaryEditorPart(options?: { bounds?: Partial<IRectangle>; compact?: boolean; alwaysOnTop?: boolean }): Promise<IAuxiliaryEditorPart>;\n\n\t/**\n\t * Returns the instantiation service that is scoped to the\n\t * provided editor part. Use this method when building UI\n\t * that contributes to auxiliary editor parts to ensure the\n\t * UI is scoped to that part.\n\t */\n\tgetScopedInstantiationService(part: IEditorPart): IInstantiationService;\n\n\t/**\n\t * Save a new editor working set from the currently opened\n\t * editors and group layout.\n\t */\n\tsaveWorkingSet(name: string): IEditorWorkingSet;\n\n\t/**\n\t * Returns all known editor working sets.\n\t */\n\tgetWorkingSets(): IEditorWorkingSet[];\n\n\t/**\n\t * Applies the working set. Use `empty` to apply an empty working set.\n\t *\n\t * @returns `true` when the working set as applied.\n\t */\n\tapplyWorkingSet(workingSet: IEditorWorkingSet | 'empty', options?: IEditorWorkingSetOptions): Promise<boolean>;\n\n\t/**\n\t * Deletes a working set.\n\t */\n\tdeleteWorkingSet(workingSet: IEditorWorkingSet): void;\n\n\t/**\n\t * Registers a context key provider. This provider sets a context key for each scoped editor group context and the global context.\n\t *\n\t * @param provider - The context key provider to be registered.\n\t * @returns - A disposable object to unregister the provider.\n\t */\n\tregisterContextKeyProvider<T extends ContextKeyValue>(provider: IEditorGroupContextKeyProvider<T>): IDisposable;\n}\n\nexport const enum OpenEditorContext {\n\tNEW_EDITOR = 1,\n\tMOVE_EDITOR = 2,\n\tCOPY_EDITOR = 3\n}\n\nexport interface IActiveEditorActions {\n\treadonly actions: IToolbarActions;\n\treadonly onDidChange: Event<IMenuChangeEvent | void>;\n}\n\nexport interface IEditorGroup {\n\n\t/**\n\t * An event which fires whenever the underlying group model changes.\n\t */\n\treadonly onDidModelChange: Event<IGroupModelChangeEvent>;\n\n\t/**\n\t * An event that is fired when the group gets disposed.\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * An event that is fired when the active editor in the group changed.\n\t */\n\treadonly onDidActiveEditorChange: Event<IActiveEditorChangeEvent>;\n\n\t/**\n\t * An event that is fired when an editor is about to close.\n\t */\n\treadonly onWillCloseEditor: Event<IEditorCloseEvent>;\n\n\t/**\n\t * An event that is fired when an editor is closed.\n\t */\n\treadonly onDidCloseEditor: Event<IEditorCloseEvent>;\n\n\t/**\n\t * An event that is fired when an editor is about to move to\n\t * a different group.\n\t */\n\treadonly onWillMoveEditor: Event<IEditorWillMoveEvent>;\n\n\t/**\n\t * A unique identifier of this group that remains identical even if the\n\t * group is moved to different locations.\n\t */\n\treadonly id: GroupIdentifier;\n\n\t/**\n\t * The identifier of the window this editor group is part of.\n\t */\n\treadonly windowId: number;\n\n\t/**\n\t * A number that indicates the position of this group in the visual\n\t * order of groups from left to right and top to bottom. The lowest\n\t * index will likely be top-left while the largest index in most\n\t * cases should be bottom-right, but that depends on the grid.\n\t */\n\treadonly index: number;\n\n\t/**\n\t * A human readable label for the group. This label can change depending\n\t * on the layout of all editor groups. Clients should listen on the\n\t * `onDidGroupModelChange` event to react to that.\n\t */\n\treadonly label: string;\n\n\t/**\n\t * A human readable label for the group to be used by screen readers.\n\t */\n\treadonly ariaLabel: string;\n\n\t/**\n\t * The active editor pane is the currently visible editor pane of the group.\n\t */\n\treadonly activeEditorPane: IVisibleEditorPane | undefined;\n\n\t/**\n\t * The active editor is the currently visible editor of the group\n\t * within the current active editor pane.\n\t */\n\treadonly activeEditor: EditorInput | null;\n\n\t/**\n\t * All selected editor in this group in sequential order.\n\t * The active editor is always part of the selection.\n\t */\n\treadonly selectedEditors: EditorInput[];\n\n\t/**\n\t * The editor in the group that is in preview mode if any. There can\n\t * only ever be one editor in preview mode.\n\t */\n\treadonly previewEditor: EditorInput | null;\n\n\t/**\n\t * The number of opened editors in this group.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * Whether the group has editors or not.\n\t */\n\treadonly isEmpty: boolean;\n\n\t/**\n\t * Whether this editor group is locked or not. Locked editor groups\n\t * will only be considered for editors to open in when the group is\n\t * explicitly provided for the editor.\n\t *\n\t * Note: editor group locking only applies when more than one group\n\t * is opened.\n\t */\n\treadonly isLocked: boolean;\n\n\t/**\n\t * The number of sticky editors in this group.\n\t */\n\treadonly stickyCount: number;\n\n\t/**\n\t * All opened editors in the group in sequential order of their appearance.\n\t */\n\treadonly editors: readonly EditorInput[];\n\n\t/**\n\t * The scoped context key service for this group.\n\t */\n\treadonly scopedContextKeyService: IContextKeyService;\n\n\t/**\n\t * Get all editors that are currently opened in the group.\n\t *\n\t * @param order the order of the editors to use\n\t * @param options options to select only specific editors as instructed\n\t */\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): readonly EditorInput[];\n\n\t/**\n\t * Finds all editors for the given resource that are currently\n\t * opened in the group. This method will return an entry for\n\t * each editor that reports a `resource` that matches the\n\t * provided one.\n\t *\n\t * @param resource the resource of the editor to find\n\t * @param options whether to support side by side editors or not\n\t */\n\tfindEditors(resource: URI, options?: IFindEditorOptions): readonly EditorInput[];\n\n\t/**\n\t * Returns the editor at a specific index of the group.\n\t */\n\tgetEditorByIndex(index: number): EditorInput | undefined;\n\n\t/**\n\t * Returns the index of the editor in the group or -1 if not opened.\n\t */\n\tgetIndexOfEditor(editor: EditorInput): number;\n\n\t/**\n\t * Whether the editor is the first in the group.\n\t */\n\tisFirst(editor: EditorInput): boolean;\n\n\t/**\n\t * Whether the editor is the last in the group.\n\t */\n\tisLast(editor: EditorInput): boolean;\n\n\t/**\n\t * Open an editor in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor.\n\t */\n\topenEditor(editor: EditorInput, options?: IEditorOptions): Promise<IEditorPane | undefined>;\n\n\t/**\n\t * Opens editors in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor. Since\n\t * a group can only ever have one active editor, even if many editors are\n\t * opened, the result will only be one editor.\n\t */\n\topenEditors(editors: EditorInputWithOptions[]): Promise<IEditorPane | undefined>;\n\n\t/**\n\t * Find out if the provided editor is pinned in the group.\n\t */\n\tisPinned(editorOrIndex: EditorInput | number): boolean;\n\n\t/**\n\t * Find out if the provided editor or index of editor is sticky in the group.\n\t */\n\tisSticky(editorOrIndex: EditorInput | number): boolean;\n\n\t/**\n\t * Find out if the provided editor or index of editor is transient in the group.\n\t */\n\tisTransient(editorOrIndex: EditorInput | number): boolean;\n\n\t/**\n\t * Find out if the provided editor is active in the group.\n\t */\n\tisActive(editor: EditorInput | IUntypedEditorInput): boolean;\n\n\t/**\n\t * Whether the editor is selected in the group.\n\t */\n\tisSelected(editor: EditorInput): boolean;\n\n\t/**\n\t * Set a new selection for this group. This will replace the current\n\t * selection with the new selection.\n\t *\n\t * @param activeSelectedEditor the editor to set as active selected editor\n\t * @param inactiveSelectedEditors the inactive editors to set as selected\n\t */\n\tsetSelection(activeSelectedEditor: EditorInput, inactiveSelectedEditors: EditorInput[]): Promise<void>;\n\n\t/**\n\t * Find out if a certain editor is included in the group.\n\t *\n\t * @param candidate the editor to find\n\t * @param options fine tune how to match editors\n\t */\n\tcontains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean;\n\n\t/**\n\t * Move an editor from this group either within this group or to another group.\n\t *\n\t * @returns whether the editor was moved or not.\n\t */\n\tmoveEditor(editor: EditorInput, target: IEditorGroup, options?: IEditorOptions): boolean;\n\n\t/**\n\t * Move editors from this group either within this group or to another group.\n\t *\n\t * @returns whether all editors were moved or not.\n\t */\n\tmoveEditors(editors: EditorInputWithOptions[], target: IEditorGroup): boolean;\n\n\t/**\n\t * Copy an editor from this group to another group.\n\t *\n\t * Note: It is currently not supported to show the same editor more than once in the same group.\n\t */\n\tcopyEditor(editor: EditorInput, target: IEditorGroup, options?: IEditorOptions): void;\n\n\t/**\n\t * Copy editors from this group to another group.\n\t *\n\t * Note: It is currently not supported to show the same editor more than once in the same group.\n\t */\n\tcopyEditors(editors: EditorInputWithOptions[], target: IEditorGroup): void;\n\n\t/**\n\t * Close an editor from the group. This may trigger a confirmation dialog if\n\t * the editor is dirty and thus returns a promise as value.\n\t *\n\t * @param editor the editor to close, or the currently active editor\n\t * if unspecified.\n\t *\n\t * @returns a promise when the editor is closed or not. If `true`, the editor\n\t * is closed and if `false` there was a veto closing the editor, e.g. when it\n\t * is dirty.\n\t */\n\tcloseEditor(editor?: EditorInput, options?: ICloseEditorOptions): Promise<boolean>;\n\n\t/**\n\t * Closes specific editors in this group. This may trigger a confirmation dialog if\n\t * there are dirty editors and thus returns a promise as value.\n\t *\n\t * @returns a promise whether the editors were closed or not. If `true`, the editors\n\t * were closed and if `false` there was a veto closing the editors, e.g. when one\n\t * is dirty.\n\t */\n\tcloseEditors(editors: EditorInput[] | ICloseEditorsFilter, options?: ICloseEditorOptions): Promise<boolean>;\n\n\t/**\n\t * Closes all editors from the group. This may trigger a confirmation dialog if\n\t * there are dirty editors and thus returns a promise as value.\n\t *\n\t * @returns a promise if confirmation is needed when all editors are closed.\n\t */\n\tcloseAllEditors(options: { excludeConfirming: true }): boolean;\n\tcloseAllEditors(options?: ICloseAllEditorsOptions): Promise<boolean>;\n\n\t/**\n\t * Replaces editors in this group with the provided replacement.\n\t *\n\t * @param editors the editors to replace\n\t *\n\t * @returns a promise that is resolved when the replaced active\n\t * editor (if any) has finished loading.\n\t */\n\treplaceEditors(editors: IEditorReplacement[]): Promise<void>;\n\n\t/**\n\t * Set an editor to be pinned. A pinned editor is not replaced\n\t * when another editor opens at the same location.\n\t *\n\t * @param editor the editor to pin, or the currently active editor\n\t * if unspecified.\n\t */\n\tpinEditor(editor?: EditorInput): void;\n\n\t/**\n\t * Set an editor to be sticky. A sticky editor is showing in the beginning\n\t * of the tab stripe and will not be impacted by close operations.\n\t *\n\t * @param editor the editor to make sticky, or the currently active editor\n\t * if unspecified.\n\t */\n\tstickEditor(editor?: EditorInput): void;\n\n\t/**\n\t * Set an editor to be non-sticky and thus moves back to a location after\n\t * sticky editors and can be closed normally.\n\t *\n\t * @param editor the editor to make unsticky, or the currently active editor\n\t * if unspecified.\n\t */\n\tunstickEditor(editor?: EditorInput): void;\n\n\t/**\n\t * Whether this editor group should be locked or not.\n\t *\n\t * See {@linkcode IEditorGroup.isLocked `isLocked`}\n\t */\n\tlock(locked: boolean): void;\n\n\t/**\n\t * Move keyboard focus into the group.\n\t */\n\tfocus(): void;\n\n\t/**\n\t * Create the editor actions for the current active editor.\n\t */\n\tcreateEditorActions(disposables: DisposableStore, menuId?: MenuId): IActiveEditorActions;\n}\n\nexport function isEditorGroup(obj: unknown): obj is IEditorGroup {\n\tconst group = obj as IEditorGroup | undefined;\n\n\treturn !!group && typeof group.id === 'number' && Array.isArray(group.editors);\n}\n\n//#region Editor Group Helpers\n\nexport function preferredSideBySideGroupDirection(configurationService: IConfigurationService): GroupDirection.DOWN | GroupDirection.RIGHT {\n\tconst openSideBySideDirection = configurationService.getValue('workbench.editor.openSideBySideDirection');\n\n\tif (openSideBySideDirection === 'down') {\n\t\treturn GroupDirection.DOWN;\n\t}\n\n\treturn GroupDirection.RIGHT;\n}\n\n//#endregion\n"],
      version: 3
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "6a772b1770bf6d616b78d8e531d4200dcad0bdab"
  };
  var coverage = global[gcv] || (global[gcv] = {});
  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }
  var actualCoverage = coverage[path];
  {
    // @ts-ignore
    cov_ekl39dfio = function () {
      return actualCoverage;
    };
  }
  return actualCoverage;
}
cov_ekl39dfio();
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';
import { isEditorInput } from '../../../common/editor.js';
export const IEditorGroupsService =
/* istanbul ignore next */
(cov_ekl39dfio().s[0]++, createDecorator('editorGroupsService'));
export function isEditorReplacement(replacement) {
  /* istanbul ignore next */
  cov_ekl39dfio().f[0]++;
  const candidate =
  /* istanbul ignore next */
  (cov_ekl39dfio().s[1]++, replacement);
  /* istanbul ignore next */
  cov_ekl39dfio().s[2]++;
  return /* istanbul ignore next */(cov_ekl39dfio().b[0][0]++, isEditorInput(candidate?.editor)) &&
  /* istanbul ignore next */
  (cov_ekl39dfio().b[0][1]++, isEditorInput(candidate?.replacement));
}
export function isEditorGroup(obj) {
  /* istanbul ignore next */
  cov_ekl39dfio().f[1]++;
  const group =
  /* istanbul ignore next */
  (cov_ekl39dfio().s[3]++, obj);
  /* istanbul ignore next */
  cov_ekl39dfio().s[4]++;
  return /* istanbul ignore next */(cov_ekl39dfio().b[1][0]++, !!group) &&
  /* istanbul ignore next */
  (cov_ekl39dfio().b[1][1]++, typeof group.id === 'number') &&
  /* istanbul ignore next */
  (cov_ekl39dfio().b[1][2]++, Array.isArray(group.editors));
}
//#region Editor Group Helpers
export function preferredSideBySideGroupDirection(configurationService) {
  /* istanbul ignore next */
  cov_ekl39dfio().f[2]++;
  const openSideBySideDirection =
  /* istanbul ignore next */
  (cov_ekl39dfio().s[5]++, configurationService.getValue('workbench.editor.openSideBySideDirection'));
  /* istanbul ignore next */
  cov_ekl39dfio().s[6]++;
  if (openSideBySideDirection === 'down') {
    /* istanbul ignore next */
    cov_ekl39dfio().b[2][0]++;
    cov_ekl39dfio().s[7]++;
    return 1 /* GroupDirection.DOWN */;
  } else
  /* istanbul ignore next */
  {
    cov_ekl39dfio().b[2][1]++;
  }
  cov_ekl39dfio().s[8]++;
  return 3 /* GroupDirection.RIGHT */;
}
//#endregion
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb3ZfZWtsMzlkZmlvIiwiYWN0dWFsQ292ZXJhZ2UiLCJjcmVhdGVEZWNvcmF0b3IiLCJpc0VkaXRvcklucHV0IiwiSUVkaXRvckdyb3Vwc1NlcnZpY2UiLCJzIiwiaXNFZGl0b3JSZXBsYWNlbWVudCIsInJlcGxhY2VtZW50IiwiZiIsImNhbmRpZGF0ZSIsImIiLCJlZGl0b3IiLCJpc0VkaXRvckdyb3VwIiwib2JqIiwiZ3JvdXAiLCJpZCIsIkFycmF5IiwiaXNBcnJheSIsImVkaXRvcnMiLCJwcmVmZXJyZWRTaWRlQnlTaWRlR3JvdXBEaXJlY3Rpb24iLCJjb25maWd1cmF0aW9uU2VydmljZSIsIm9wZW5TaWRlQnlTaWRlRGlyZWN0aW9uIiwiZ2V0VmFsdWUiXSwic291cmNlcyI6WyIvaG9tZS91c2VyL0Rlc2t0b3AvTWludE1pbmQvc3JjL3ZzL3dvcmtiZW5jaC9zZXJ2aWNlcy9lZGl0b3IvY29tbW9uL2VkaXRvckdyb3Vwc1NlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vZXZlbnQuanMnO1xuaW1wb3J0IHsgSUluc3RhbnRpYXRpb25TZXJ2aWNlLCBjcmVhdGVEZWNvcmF0b3IgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS9pbnN0YW50aWF0aW9uL2NvbW1vbi9pbnN0YW50aWF0aW9uLmpzJztcbmltcG9ydCB7IElFZGl0b3JQYW5lLCBHcm91cElkZW50aWZpZXIsIEVkaXRvcklucHV0V2l0aE9wdGlvbnMsIENsb3NlRGlyZWN0aW9uLCBJRWRpdG9yUGFydE9wdGlvbnMsIElFZGl0b3JQYXJ0T3B0aW9uc0NoYW5nZUV2ZW50LCBFZGl0b3JzT3JkZXIsIElWaXNpYmxlRWRpdG9yUGFuZSwgSUVkaXRvckNsb3NlRXZlbnQsIElVbnR5cGVkRWRpdG9ySW5wdXQsIGlzRWRpdG9ySW5wdXQsIElFZGl0b3JXaWxsTW92ZUV2ZW50LCBJTWF0Y2hFZGl0b3JPcHRpb25zLCBJQWN0aXZlRWRpdG9yQ2hhbmdlRXZlbnQsIElGaW5kRWRpdG9yT3B0aW9ucywgSVRvb2xiYXJBY3Rpb25zIH0gZnJvbSAnLi4vLi4vLi4vY29tbW9uL2VkaXRvci5qcyc7XG5pbXBvcnQgeyBFZGl0b3JJbnB1dCB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9lZGl0b3IvZWRpdG9ySW5wdXQuanMnO1xuaW1wb3J0IHsgSUVkaXRvck9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS9lZGl0b3IvY29tbW9uL2VkaXRvci5qcyc7XG5pbXBvcnQgeyBJQ29uZmlndXJhdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS9jb25maWd1cmF0aW9uL2NvbW1vbi9jb25maWd1cmF0aW9uLmpzJztcbmltcG9ydCB7IElEaW1lbnNpb24gfSBmcm9tICcuLi8uLi8uLi8uLi9lZGl0b3IvY29tbW9uL2NvcmUvMmQvZGltZW5zaW9uLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGVTdG9yZSwgSURpc3Bvc2FibGUgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgQ29udGV4dEtleVZhbHVlLCBJQ29udGV4dEtleVNlcnZpY2UsIFJhd0NvbnRleHRLZXkgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS9jb250ZXh0a2V5L2NvbW1vbi9jb250ZXh0a2V5LmpzJztcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL3VyaS5qcyc7XG5pbXBvcnQgeyBJR3JvdXBNb2RlbENoYW5nZUV2ZW50IH0gZnJvbSAnLi4vLi4vLi4vY29tbW9uL2VkaXRvci9lZGl0b3JHcm91cE1vZGVsLmpzJztcbmltcG9ydCB7IElSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS93aW5kb3cvY29tbW9uL3dpbmRvdy5qcyc7XG5pbXBvcnQgeyBJTWVudUNoYW5nZUV2ZW50LCBNZW51SWQgfSBmcm9tICcuLi8uLi8uLi8uLi9wbGF0Zm9ybS9hY3Rpb25zL2NvbW1vbi9hY3Rpb25zLmpzJztcbmltcG9ydCB7IERlZXBQYXJ0aWFsIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vdHlwZXMuanMnO1xuXG5leHBvcnQgY29uc3QgSUVkaXRvckdyb3Vwc1NlcnZpY2UgPSBjcmVhdGVEZWNvcmF0b3I8SUVkaXRvckdyb3Vwc1NlcnZpY2U+KCdlZGl0b3JHcm91cHNTZXJ2aWNlJyk7XG5cbmV4cG9ydCBjb25zdCBlbnVtIEdyb3VwRGlyZWN0aW9uIHtcblx0VVAsXG5cdERPV04sXG5cdExFRlQsXG5cdFJJR0hUXG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIEdyb3VwT3JpZW50YXRpb24ge1xuXHRIT1JJWk9OVEFMLFxuXHRWRVJUSUNBTFxufVxuXG5leHBvcnQgY29uc3QgZW51bSBHcm91cExvY2F0aW9uIHtcblx0RklSU1QsXG5cdExBU1QsXG5cdE5FWFQsXG5cdFBSRVZJT1VTXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZpbmRHcm91cFNjb3BlIHtcblx0cmVhZG9ubHkgZGlyZWN0aW9uPzogR3JvdXBEaXJlY3Rpb247XG5cdHJlYWRvbmx5IGxvY2F0aW9uPzogR3JvdXBMb2NhdGlvbjtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gR3JvdXBzQXJyYW5nZW1lbnQge1xuXHQvKipcblx0ICogTWFrZSB0aGUgY3VycmVudCBhY3RpdmUgZ3JvdXAgY29uc3VtZSB0aGUgZW50aXJlXG5cdCAqIGVkaXRvciBhcmVhLlxuXHQgKi9cblx0TUFYSU1JWkUsXG5cblx0LyoqXG5cdCAqIE1ha2UgdGhlIGN1cnJlbnQgYWN0aXZlIGdyb3VwIGNvbnN1bWUgdGhlIG1heGltdW1cblx0ICogYW1vdW50IG9mIHNwYWNlIHBvc3NpYmxlLlxuXHQgKi9cblx0RVhQQU5ELFxuXG5cdC8qKlxuXHQgKiBTaXplIGFsbCBncm91cHMgZXZlbmx5LlxuXHQgKi9cblx0RVZFTlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwTGF5b3V0QXJndW1lbnQge1xuXG5cdC8qKlxuXHQgKiBPbmx5IGFwcGxpZXMgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgZ3JvdXBzXG5cdCAqIGFycmFuZ2VkIG5leHQgdG8gZWFjaCBvdGhlciBpbiBhIHJvdyBvciBjb2x1bW4uXG5cdCAqIElmIHByb3ZpZGVkLCB0aGVpciBzdW0gbXVzdCBiZSAxIHRvIGJlIGFwcGxpZWRcblx0ICogcGVyIHJvdyBvciBjb2x1bW4uXG5cdCAqL1xuXHRyZWFkb25seSBzaXplPzogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBFZGl0b3IgZ3JvdXBzICB3aWxsIGJlIGxhaWQgb3V0IG9ydGhvZ29uYWwgdG8gdGhlXG5cdCAqIHBhcmVudCBvcmllbnRhdGlvbi5cblx0ICovXG5cdHJlYWRvbmx5IGdyb3Vwcz86IEdyb3VwTGF5b3V0QXJndW1lbnRbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFZGl0b3JHcm91cExheW91dCB7XG5cblx0LyoqXG5cdCAqIFRoZSBpbml0aWFsIG9yaWVudGF0aW9uIG9mIHRoZSBlZGl0b3IgZ3JvdXBzIGF0IHRoZSByb290LlxuXHQgKi9cblx0cmVhZG9ubHkgb3JpZW50YXRpb246IEdyb3VwT3JpZW50YXRpb247XG5cblx0LyoqXG5cdCAqIFRoZSBlZGl0b3IgZ3JvdXBzIGF0IHRoZSByb290IG9mIHRoZSBsYXlvdXQuXG5cdCAqL1xuXHRyZWFkb25seSBncm91cHM6IEdyb3VwTGF5b3V0QXJndW1lbnRbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gTWVyZ2VHcm91cE1vZGUge1xuXHRDT1BZX0VESVRPUlMsXG5cdE1PVkVfRURJVE9SU1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElNZXJnZUdyb3VwT3B0aW9ucyB7XG5cdG1vZGU/OiBNZXJnZUdyb3VwTW9kZTtcblx0cmVhZG9ubHkgaW5kZXg/OiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIFNldCB0aGlzIHRvIHByZXZlbnQgZWRpdG9ycyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlXG5cdCAqIHRhcmdldCBncm91cCBmcm9tIG1vdmluZyB0byBhIGRpZmZlcmVudCBpbmRleCBhc1xuXHQgKiB0aGV5IGFyZSBpbiB0aGUgc291cmNlIGdyb3VwLlxuXHQgKi9cblx0cmVhZG9ubHkgcHJlc2VydmVFeGlzdGluZ0luZGV4PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQ2xvc2VFZGl0b3JPcHRpb25zIHtcblx0cmVhZG9ubHkgcHJlc2VydmVGb2N1cz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIElDbG9zZUVkaXRvcnNGaWx0ZXIgPSB7XG5cdHJlYWRvbmx5IGV4Y2VwdD86IEVkaXRvcklucHV0O1xuXHRyZWFkb25seSBkaXJlY3Rpb24/OiBDbG9zZURpcmVjdGlvbjtcblx0cmVhZG9ubHkgc2F2ZWRPbmx5PzogYm9vbGVhbjtcblx0cmVhZG9ubHkgZXhjbHVkZVN0aWNreT86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIElDbG9zZUFsbEVkaXRvcnNPcHRpb25zIHtcblx0cmVhZG9ubHkgZXhjbHVkZVN0aWNreT86IGJvb2xlYW47XG5cdHJlYWRvbmx5IGV4Y2x1ZGVDb25maXJtaW5nPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRWRpdG9yUmVwbGFjZW1lbnQge1xuXHRyZWFkb25seSBlZGl0b3I6IEVkaXRvcklucHV0O1xuXHRyZWFkb25seSByZXBsYWNlbWVudDogRWRpdG9ySW5wdXQ7XG5cdHJlYWRvbmx5IG9wdGlvbnM/OiBJRWRpdG9yT3B0aW9ucztcblxuXHQvKipcblx0ICogU2tpcHMgYXNraW5nIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb24gYW5kIGRvZXNuJ3Rcblx0ICogc2F2ZSB0aGUgZG9jdW1lbnQuIE9ubHkgdXNlIHRoaXMgaWYgeW91IHJlYWxseSBuZWVkIHRvIVxuXHQgKi9cblx0cmVhZG9ubHkgZm9yY2VSZXBsYWNlRGlydHk/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFZGl0b3JSZXBsYWNlbWVudChyZXBsYWNlbWVudDogdW5rbm93bik6IHJlcGxhY2VtZW50IGlzIElFZGl0b3JSZXBsYWNlbWVudCB7XG5cdGNvbnN0IGNhbmRpZGF0ZSA9IHJlcGxhY2VtZW50IGFzIElFZGl0b3JSZXBsYWNlbWVudCB8IHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gaXNFZGl0b3JJbnB1dChjYW5kaWRhdGU/LmVkaXRvcikgJiYgaXNFZGl0b3JJbnB1dChjYW5kaWRhdGU/LnJlcGxhY2VtZW50KTtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gR3JvdXBzT3JkZXIge1xuXG5cdC8qKlxuXHQgKiBHcm91cHMgc29ydGVkIGJ5IGNyZWF0aW9uIG9yZGVyIChvbGRlc3Qgb25lIGZpcnN0KVxuXHQgKi9cblx0Q1JFQVRJT05fVElNRSxcblxuXHQvKipcblx0ICogR3JvdXBzIHNvcnRlZCBieSBtb3N0IHJlY2VudCBhY3Rpdml0eSAobW9zdCByZWNlbnQgYWN0aXZlIGZpcnN0KVxuXHQgKi9cblx0TU9TVF9SRUNFTlRMWV9BQ1RJVkUsXG5cblx0LyoqXG5cdCAqIEdyb3VwcyBzb3J0ZWQgYnkgZ3JpZCB3aWRnZXQgb3JkZXJcblx0ICovXG5cdEdSSURfQVBQRUFSQU5DRVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElFZGl0b3JTaWRlR3JvdXAge1xuXG5cdC8qKlxuXHQgKiBPcGVuIGFuIGVkaXRvciBpbiB0aGlzIGdyb3VwLlxuXHQgKlxuXHQgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhcm91bmQgYW4gSUVkaXRvciBpbnN0YW5jZSB1bmxlc3Ncblx0ICogdGhlIGNhbGwgZmFpbGVkLCBvciB0aGUgZWRpdG9yIHdhcyBub3Qgb3BlbmVkIGFzIGFjdGl2ZSBlZGl0b3IuXG5cdCAqL1xuXHRvcGVuRWRpdG9yKGVkaXRvcjogRWRpdG9ySW5wdXQsIG9wdGlvbnM/OiBJRWRpdG9yT3B0aW9ucyk6IFByb21pc2U8SUVkaXRvclBhbmUgfCB1bmRlZmluZWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElFZGl0b3JEcm9wVGFyZ2V0RGVsZWdhdGUge1xuXG5cdC8qKlxuXHQgKiBBIGhlbHBlciB0byBmaWd1cmUgb3V0IGlmIHRoZSBkcm9wIHRhcmdldCBjb250YWlucyB0aGUgcHJvdmlkZWQgZ3JvdXAuXG5cdCAqL1xuXHRjb250YWluc0dyb3VwPyhncm91cFZpZXc6IElFZGl0b3JHcm91cCk6IGJvb2xlYW47XG59XG5cbi8qKlxuICogVGhlIGJhc2ljIHByaW1pdGl2ZSB0byB3b3JrIHdpdGggZWRpdG9yIGdyb3Vwcy4gVGhpcyBpbnRlcmZhY2UgaXMgYm90aCBpbXBsZW1lbnRlZFxuICogYnkgZWRpdG9yIHBhcnQgY29tcG9uZW50IGFzIHdlbGwgYXMgdGhlIGVkaXRvciBncm91cHMgc2VydmljZSB0aGF0IG9wZXJhdGVzIGFjcm9zc1xuICogYWxsIG9wZW5lZCBlZGl0b3IgcGFydHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUVkaXRvckdyb3Vwc0NvbnRhaW5lciB7XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IGZvciB3aGVuIHRoZSBhY3RpdmUgZWRpdG9yIGdyb3VwIGNoYW5nZXMuIFRoZSBhY3RpdmUgZWRpdG9yXG5cdCAqIGdyb3VwIGlzIHRoZSBkZWZhdWx0IGxvY2F0aW9uIGZvciBuZXcgZWRpdG9ycyB0byBvcGVuLlxuXHQgKi9cblx0cmVhZG9ubHkgb25EaWRDaGFuZ2VBY3RpdmVHcm91cDogRXZlbnQ8SUVkaXRvckdyb3VwPjtcblxuXHQvKipcblx0ICogQW4gZXZlbnQgZm9yIHdoZW4gYSBuZXcgZ3JvdXAgd2FzIGFkZGVkLlxuXHQgKi9cblx0cmVhZG9ubHkgb25EaWRBZGRHcm91cDogRXZlbnQ8SUVkaXRvckdyb3VwPjtcblxuXHQvKipcblx0ICogQW4gZXZlbnQgZm9yIHdoZW4gYSBncm91cCB3YXMgcmVtb3ZlZC5cblx0ICovXG5cdHJlYWRvbmx5IG9uRGlkUmVtb3ZlR3JvdXA6IEV2ZW50PElFZGl0b3JHcm91cD47XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IGZvciB3aGVuIGEgZ3JvdXAgd2FzIG1vdmVkLlxuXHQgKi9cblx0cmVhZG9ubHkgb25EaWRNb3ZlR3JvdXA6IEV2ZW50PElFZGl0b3JHcm91cD47XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IGZvciB3aGVuIGEgZ3JvdXAgZ2V0cyBhY3RpdmF0ZWQuXG5cdCAqL1xuXHRyZWFkb25seSBvbkRpZEFjdGl2YXRlR3JvdXA6IEV2ZW50PElFZGl0b3JHcm91cD47XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IGZvciB3aGVuIHRoZSBpbmRleCBvZiBhIGdyb3VwIGNoYW5nZXMuXG5cdCAqL1xuXHRyZWFkb25seSBvbkRpZENoYW5nZUdyb3VwSW5kZXg6IEV2ZW50PElFZGl0b3JHcm91cD47XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IGZvciB3aGVuIHRoZSBsb2NrZWQgc3RhdGUgb2YgYSBncm91cCBjaGFuZ2VzLlxuXHQgKi9cblx0cmVhZG9ubHkgb25EaWRDaGFuZ2VHcm91cExvY2tlZDogRXZlbnQ8SUVkaXRvckdyb3VwPjtcblxuXHQvKipcblx0ICogQW4gZXZlbnQgZm9yIHdoZW4gdGhlIG1heGltaXplZCBzdGF0ZSBvZiBhIGdyb3VwIGNoYW5nZXMuXG5cdCAqL1xuXHRyZWFkb25seSBvbkRpZENoYW5nZUdyb3VwTWF4aW1pemVkOiBFdmVudDxib29sZWFuPjtcblxuXHQvKipcblx0ICogQW4gZXZlbnQgdGhhdCBub3RpZmllcyB3aGVuIGNvbnRhaW5lciBvcHRpb25zIGNoYW5nZS5cblx0ICovXG5cdHJlYWRvbmx5IG9uRGlkQ2hhbmdlRWRpdG9yUGFydE9wdGlvbnM6IEV2ZW50PElFZGl0b3JQYXJ0T3B0aW9uc0NoYW5nZUV2ZW50PjtcblxuXHQvKipcblx0ICogQSBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyB3aGVuIGdyb3VwcyBoYXZlIGJlZW4gY3JlYXRlZFxuXHQgKiBhbmQgYXJlIHJlYWR5IHRvIGJlIHVzZWQgaW4gdGhlIGNvbnRhaW5lci5cblx0ICovXG5cdHJlYWRvbmx5IGlzUmVhZHk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gZ3JvdXBzIGhhdmUgYmVlbiBjcmVhdGVkXG5cdCAqIGFuZCBhcmUgcmVhZHkgdG8gYmUgdXNlZCBpbiB0aGUgY29udGFpbmVyLlxuXHQgKlxuXHQgKiBBd2FpdCB0aGlzIHByb21pc2UgdG8gc2FmZWx5IHdvcmsgb24gdGhlIGVkaXRvciBncm91cHMgbW9kZWxcblx0ICogKGZvciBleGFtcGxlLCBpbnN0YWxsIGVkaXRvciBncm91cCBsaXN0ZW5lcnMpLlxuXHQgKlxuXHQgKiBVc2UgdGhlIGB3aGVuUmVzdG9yZWRgIHByb3BlcnR5IHRvIGF3YWl0IHZpc2libGUgZWRpdG9yc1xuXHQgKiBoYXZpbmcgZnVsbHkgcmVzb2x2ZWQuXG5cdCAqL1xuXHRyZWFkb25seSB3aGVuUmVhZHk6IFByb21pc2U8dm9pZD47XG5cblx0LyoqXG5cdCAqIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gZ3JvdXBzIGhhdmUgYmVlbiByZXN0b3JlZCBpblxuXHQgKiB0aGUgY29udGFpbmVyLlxuXHQgKlxuXHQgKiBGb3IgZ3JvdXBzIHdpdGggYWN0aXZlIGVkaXRvciwgdGhlIHByb21pc2Ugd2lsbCByZXNvbHZlXG5cdCAqIHdoZW4gdGhlIHZpc2libGUgZWRpdG9yIGhhcyBmaW5pc2hlZCB0byByZXNvbHZlLlxuXHQgKlxuXHQgKiBVc2UgdGhlIGB3aGVuUmVhZHlgIHByb3BlcnR5IHRvIG5vdCBhd2FpdCBlZGl0b3JzIHRvXG5cdCAqIHJlc29sdmUuXG5cdCAqL1xuXHRyZWFkb25seSB3aGVuUmVzdG9yZWQ6IFByb21pc2U8dm9pZD47XG5cblx0LyoqXG5cdCAqIEZpbmQgb3V0IGlmIHRoZSBjb250YWluZXIgaGFzIFVJIHN0YXRlIHRvIHJlc3RvcmVcblx0ICogZnJvbSBhIHByZXZpb3VzIHNlc3Npb24uXG5cdCAqL1xuXHRyZWFkb25seSBoYXNSZXN0b3JhYmxlU3RhdGU6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIEFuIGFjdGl2ZSBncm91cCBpcyB0aGUgZGVmYXVsdCBsb2NhdGlvbiBmb3IgbmV3IGVkaXRvcnMgdG8gb3Blbi5cblx0ICovXG5cdHJlYWRvbmx5IGFjdGl2ZUdyb3VwOiBJRWRpdG9yR3JvdXA7XG5cblx0LyoqXG5cdCAqIEEgc2lkZSBncm91cCBhbGxvd3MgYSBzdWJzZXQgb2YgbWV0aG9kcyBvbiBhIGdyb3VwIHRoYXQgaXMgZWl0aGVyXG5cdCAqIGNyZWF0ZWQgdG8gdGhlIHNpZGUgb3IgcGlja2VkIGlmIGFscmVhZHkgdGhlcmUuXG5cdCAqL1xuXHRyZWFkb25seSBzaWRlR3JvdXA6IElFZGl0b3JTaWRlR3JvdXA7XG5cblx0LyoqXG5cdCAqIEFsbCBncm91cHMgdGhhdCBhcmUgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIGNvbnRhaW5lciBpbiB0aGUgb3JkZXJcblx0ICogb2YgdGhlaXIgY3JlYXRpb24gKG9sZGVzdCBmaXJzdCkuXG5cdCAqL1xuXHRyZWFkb25seSBncm91cHM6IHJlYWRvbmx5IElFZGl0b3JHcm91cFtdO1xuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIGVkaXRvciBncm91cHMgdGhhdCBhcmUgY3VycmVudGx5IG9wZW5lZCBpbiB0aGVcblx0ICogY29udGFpbmVyLlxuXHQgKi9cblx0cmVhZG9ubHkgY291bnQ6IG51bWJlcjtcblxuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgbGF5b3V0IG9yaWVudGF0aW9uIG9mIHRoZSByb290IGdyb3VwLlxuXHQgKi9cblx0cmVhZG9ubHkgb3JpZW50YXRpb246IEdyb3VwT3JpZW50YXRpb247XG5cblx0LyoqXG5cdCAqIEFjY2VzcyB0aGUgb3B0aW9ucyBvZiB0aGUgY29udGFpbmVyLlxuXHQgKi9cblx0cmVhZG9ubHkgcGFydE9wdGlvbnM6IElFZGl0b3JQYXJ0T3B0aW9ucztcblxuXHQvKipcblx0ICogRW5mb3JjZSBjb250YWluZXIgb3B0aW9ucyB0ZW1wb3JhcmlseS5cblx0ICovXG5cdGVuZm9yY2VQYXJ0T3B0aW9ucyhvcHRpb25zOiBEZWVwUGFydGlhbDxJRWRpdG9yUGFydE9wdGlvbnM+KTogSURpc3Bvc2FibGU7XG5cblx0LyoqXG5cdCAqIEdldCBhbGwgZ3JvdXBzIHRoYXQgYXJlIGN1cnJlbnRseSB2aXNpYmxlIGluIHRoZSBjb250YWluZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSBvcmRlciB0aGUgb3JkZXIgb2YgdGhlIGVkaXRvcnMgdG8gdXNlXG5cdCAqL1xuXHRnZXRHcm91cHMob3JkZXI6IEdyb3Vwc09yZGVyKTogcmVhZG9ubHkgSUVkaXRvckdyb3VwW107XG5cblx0LyoqXG5cdCAqIEFsbG93cyB0byBjb252ZXJ0IGEgZ3JvdXAgaWRlbnRpZmllciB0byBhIGdyb3VwLlxuXHQgKi9cblx0Z2V0R3JvdXAoaWRlbnRpZmllcjogR3JvdXBJZGVudGlmaWVyKTogSUVkaXRvckdyb3VwIHwgdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBTZXQgYSBncm91cCBhcyBhY3RpdmUuIEFuIGFjdGl2ZSBncm91cCBpcyB0aGUgZGVmYXVsdCBsb2NhdGlvbiBmb3IgbmV3IGVkaXRvcnMgdG8gb3Blbi5cblx0ICovXG5cdGFjdGl2YXRlR3JvdXAoZ3JvdXA6IElFZGl0b3JHcm91cCB8IEdyb3VwSWRlbnRpZmllcik6IElFZGl0b3JHcm91cDtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc2l6ZSBvZiBhIGdyb3VwLlxuXHQgKi9cblx0Z2V0U2l6ZShncm91cDogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyKTogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzaXplIG9mIGEgZ3JvdXAuXG5cdCAqL1xuXHRzZXRTaXplKGdyb3VwOiBJRWRpdG9yR3JvdXAgfCBHcm91cElkZW50aWZpZXIsIHNpemU6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIEFycmFuZ2UgYWxsIGdyb3VwcyBpbiB0aGUgY29udGFpbmVyIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgYXJyYW5nZW1lbnQuXG5cdCAqL1xuXHRhcnJhbmdlR3JvdXBzKGFycmFuZ2VtZW50OiBHcm91cHNBcnJhbmdlbWVudCwgdGFyZ2V0PzogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyKTogdm9pZDtcblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgdGFyZ2V0IGdvdXAgc2l6ZSB0byBtYXhpbWl6ZS91bm1heGltaXplLlxuXHQgKi9cblx0dG9nZ2xlTWF4aW1pemVHcm91cChncm91cD86IElFZGl0b3JHcm91cCB8IEdyb3VwSWRlbnRpZmllcik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFRvZ2dsZXMgdGhlIHRhcmdldCBnb3VwIHNpemUgdG8gZXhwYW5kL2Rpc3RyaWJ1dGUgZXZlbi5cblx0ICovXG5cdHRvZ2dsZUV4cGFuZEdyb3VwKGdyb3VwPzogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyKTogdm9pZDtcblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgcHJvdmlkZWQgbGF5b3V0IGJ5IGVpdGhlciBtb3ZpbmcgZXhpc3RpbmcgZ3JvdXBzIG9yIGNyZWF0aW5nIG5ldyBncm91cHMuXG5cdCAqL1xuXHRhcHBseUxheW91dChsYXlvdXQ6IEVkaXRvckdyb3VwTGF5b3V0KTogdm9pZDtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBlZGl0b3IgbGF5b3V0IG9mIHRoZSBjb250YWluZXIuXG5cdCAqL1xuXHRnZXRMYXlvdXQoKTogRWRpdG9yR3JvdXBMYXlvdXQ7XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSByb290IGdyb3VwIHRvIGJlIGVpdGhlciB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLlxuXHQgKi9cblx0c2V0R3JvdXBPcmllbnRhdGlvbihvcmllbnRhdGlvbjogR3JvdXBPcmllbnRhdGlvbik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIEZpbmQgYSBncm91cCBpbiBhIHNwZWNpZmljIHNjb3BlOlxuXHQgKiAqIGBHcm91cExvY2F0aW9uLkZJUlNUYDogdGhlIGZpcnN0IGdyb3VwXG5cdCAqICogYEdyb3VwTG9jYXRpb24uTEFTVGA6IHRoZSBsYXN0IGdyb3VwXG5cdCAqICogYEdyb3VwTG9jYXRpb24uTkVYVGA6IHRoZSBuZXh0IGdyb3VwIGZyb20gZWl0aGVyIHRoZSBhY3RpdmUgb25lIG9yIGBzb3VyY2VgXG5cdCAqICogYEdyb3VwTG9jYXRpb24uUFJFVklPVVNgOiB0aGUgcHJldmlvdXMgZ3JvdXAgZnJvbSBlaXRoZXIgdGhlIGFjdGl2ZSBvbmUgb3IgYHNvdXJjZWBcblx0ICogKiBgR3JvdXBEaXJlY3Rpb24uVVBgOiB0aGUgbmV4dCBncm91cCBhYm92ZSB0aGUgYWN0aXZlIG9uZSBvciBgc291cmNlYFxuXHQgKiAqIGBHcm91cERpcmVjdGlvbi5ET1dOYDogdGhlIG5leHQgZ3JvdXAgYmVsb3cgdGhlIGFjdGl2ZSBvbmUgb3IgYHNvdXJjZWBcblx0ICogKiBgR3JvdXBEaXJlY3Rpb24uTEVGVGA6IHRoZSBuZXh0IGdyb3VwIHRvIHRoZSBsZWZ0IG9mIHRoZSBhY3RpdmUgb25lIG9yIGBzb3VyY2VgXG5cdCAqICogYEdyb3VwRGlyZWN0aW9uLlJJR0hUYDogdGhlIG5leHQgZ3JvdXAgdG8gdGhlIHJpZ2h0IG9mIHRoZSBhY3RpdmUgb25lIG9yIGBzb3VyY2VgXG5cdCAqXG5cdCAqIEBwYXJhbSBzY29wZSB0aGUgc2NvcGUgb2YgdGhlIGdyb3VwIHRvIHNlYXJjaCBpblxuXHQgKiBAcGFyYW0gc291cmNlIG9wdGlvbmFsIHNvdXJjZSB0byBzZWFyY2ggZnJvbVxuXHQgKiBAcGFyYW0gd3JhcCBvcHRpb25hbGx5IHdyYXAgYXJvdW5kIGlmIHJlYWNoaW5nIHRoZSBlZGdlIG9mIGdyb3Vwc1xuXHQgKi9cblx0ZmluZEdyb3VwKHNjb3BlOiBJRmluZEdyb3VwU2NvcGUsIHNvdXJjZT86IElFZGl0b3JHcm91cCB8IEdyb3VwSWRlbnRpZmllciwgd3JhcD86IGJvb2xlYW4pOiBJRWRpdG9yR3JvdXAgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEFkZCBhIG5ldyBncm91cCB0byB0aGUgY29udGFpbmVyLiBBIG5ldyBncm91cCBpcyBhZGRlZCBieSBzcGxpdHRpbmcgYSBwcm92aWRlZCBvbmUgaW5cblx0ICogb25lIG9mIHRoZSBmb3VyIGRpcmVjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSBsb2NhdGlvbiB0aGUgZ3JvdXAgZnJvbSB3aGljaCB0byBzcGxpdCB0byBhZGQgYSBuZXcgZ3JvdXBcblx0ICogQHBhcmFtIGRpcmVjdGlvbiB0aGUgZGlyZWN0aW9uIG9mIHdoZXJlIHRvIHNwbGl0IHRvXG5cdCAqL1xuXHRhZGRHcm91cChsb2NhdGlvbjogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyLCBkaXJlY3Rpb246IEdyb3VwRGlyZWN0aW9uKTogSUVkaXRvckdyb3VwO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBncm91cCBmcm9tIHRoZSBjb250YWluZXIuXG5cdCAqL1xuXHRyZW1vdmVHcm91cChncm91cDogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyKTogdm9pZDtcblxuXHQvKipcblx0ICogTW92ZSBhIGdyb3VwIHRvIGEgbmV3IGdyb3VwIGluIHRoZSBjb250YWluZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSBncm91cCB0aGUgZ3JvdXAgdG8gbW92ZVxuXHQgKiBAcGFyYW0gbG9jYXRpb24gdGhlIGdyb3VwIGZyb20gd2hpY2ggdG8gc3BsaXQgdG8gYWRkIHRoZSBtb3ZlZCBncm91cFxuXHQgKiBAcGFyYW0gZGlyZWN0aW9uIHRoZSBkaXJlY3Rpb24gb2Ygd2hlcmUgdG8gc3BsaXQgdG9cblx0ICovXG5cdG1vdmVHcm91cChncm91cDogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyLCBsb2NhdGlvbjogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyLCBkaXJlY3Rpb246IEdyb3VwRGlyZWN0aW9uKTogSUVkaXRvckdyb3VwO1xuXG5cdC8qKlxuXHQgKiBNZXJnZSB0aGUgZWRpdG9ycyBvZiBhIGdyb3VwIGludG8gYSB0YXJnZXQgZ3JvdXAuIEJ5IGRlZmF1bHQsIGFsbCBlZGl0b3JzIHdpbGxcblx0ICogbW92ZSBhbmQgdGhlIHNvdXJjZSBncm91cCB3aWxsIGNsb3NlLiBUaGlzIGJlaGF2aW91ciBjYW4gYmUgY29uZmlndXJlZCB2aWEgdGhlXG5cdCAqIGBJTWVyZ2VHcm91cE9wdGlvbnNgIG9wdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSBncm91cCB0aGUgZ3JvdXAgdG8gbWVyZ2Vcblx0ICogQHBhcmFtIHRhcmdldCB0aGUgdGFyZ2V0IGdyb3VwIHRvIG1lcmdlIGludG9cblx0ICogQHBhcmFtIG9wdGlvbnMgY29udHJvbHMgaG93IHRoZSBtZXJnZSBzaG91bGQgYmUgcGVyZm9ybWVkLiBieSBkZWZhdWx0IGFsbCBlZGl0b3JzXG5cdCAqIHdpbGwgYmUgbW92ZWQgb3ZlciB0byB0aGUgdGFyZ2V0IGFuZCB0aGUgc291cmNlIGdyb3VwIHdpbGwgY2xvc2UuIENvbmZpZ3VyZSB0b1xuXHQgKiBgTU9WRV9FRElUT1JTX0tFRVBfR1JPVVBgIHRvIHByZXZlbnQgdGhlIHNvdXJjZSBncm91cCBmcm9tIGNsb3NpbmcuIFNldCB0b1xuXHQgKiBgQ09QWV9FRElUT1JTYCB0byBjb3B5IHRoZSBlZGl0b3JzIGludG8gdGhlIHRhcmdldCBpbnN0ZWFkIG9mIG1vZGluZyB0aGVtLlxuXHQgKlxuXHQgKiBAcmV0dXJucyBpZiBtZXJnaW5nIHdhcyBzdWNjZXNzZnVsXG5cdCAqL1xuXHRtZXJnZUdyb3VwKGdyb3VwOiBJRWRpdG9yR3JvdXAgfCBHcm91cElkZW50aWZpZXIsIHRhcmdldDogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyLCBvcHRpb25zPzogSU1lcmdlR3JvdXBPcHRpb25zKTogYm9vbGVhbjtcblxuXHQvKipcblx0ICogTWVyZ2UgYWxsIGVkaXRvciBncm91cHMgaW50byB0aGUgdGFyZ2V0IG9uZS5cblx0ICpcblx0ICogQHJldHVybnMgaWYgbWVyZ2luZyB3YXMgc3VjY2Vzc2Z1bFxuXHQgKi9cblx0bWVyZ2VBbGxHcm91cHModGFyZ2V0OiBJRWRpdG9yR3JvdXAgfCBHcm91cElkZW50aWZpZXIpOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBDb3B5IGEgZ3JvdXAgdG8gYSBuZXcgZ3JvdXAgaW4gdGhlIGNvbnRhaW5lci5cblx0ICpcblx0ICogQHBhcmFtIGdyb3VwIHRoZSBncm91cCB0byBjb3B5XG5cdCAqIEBwYXJhbSBsb2NhdGlvbiB0aGUgZ3JvdXAgZnJvbSB3aGljaCB0byBzcGxpdCB0byBhZGQgdGhlIGNvcGllZCBncm91cFxuXHQgKiBAcGFyYW0gZGlyZWN0aW9uIHRoZSBkaXJlY3Rpb24gb2Ygd2hlcmUgdG8gc3BsaXQgdG9cblx0ICovXG5cdGNvcHlHcm91cChncm91cDogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyLCBsb2NhdGlvbjogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyLCBkaXJlY3Rpb246IEdyb3VwRGlyZWN0aW9uKTogSUVkaXRvckdyb3VwO1xuXG5cdC8qKlxuXHQgKiBBbGxvd3MgdG8gcmVnaXN0ZXIgYSBkcmFnIGFuZCBkcm9wIHRhcmdldCBmb3IgZWRpdG9yc1xuXHQgKiBvbiB0aGUgcHJvdmlkZWQgYGNvbnRhaW5lcmAuXG5cdCAqL1xuXHRjcmVhdGVFZGl0b3JEcm9wVGFyZ2V0KGNvbnRhaW5lcjogdW5rbm93biAvKiBIVE1MRWxlbWVudCAqLywgZGVsZWdhdGU6IElFZGl0b3JEcm9wVGFyZ2V0RGVsZWdhdGUpOiBJRGlzcG9zYWJsZTtcbn1cblxuLyoqXG4gKiBBbiBlZGl0b3IgcGFydCBpcyBhIHZpZXdlciBvZiBlZGl0b3IgZ3JvdXBzLiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgZWRpdG9yXG4gKiBwYXJ0cyBvcGVuZWQgaW4gbXVsdGlwbGUgd2luZG93cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJRWRpdG9yUGFydCBleHRlbmRzIElFZGl0b3JHcm91cHNDb250YWluZXIge1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCBmb3Igd2hlbiB0aGUgZWRpdG9yIHBhcnQgaXMgbGF5ZWQgb3V0LlxuXHQgKi9cblx0cmVhZG9ubHkgb25EaWRMYXlvdXQ6IEV2ZW50PElEaW1lbnNpb24+O1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCBmb3Igd2hlbiB0aGUgZWRpdG9yIHBhcnQgaXMgc2Nyb2xsZWQuXG5cdCAqL1xuXHRyZWFkb25seSBvbkRpZFNjcm9sbDogRXZlbnQ8dm9pZD47XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IGZvciB3aGVuIHRoZSBlZGl0b3IgcGFydCBpcyBkaXNwb3NlZC5cblx0ICovXG5cdHJlYWRvbmx5IG9uV2lsbERpc3Bvc2U6IEV2ZW50PHZvaWQ+O1xuXG5cdC8qKlxuXHQgKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgd2luZG93IHRoZSBlZGl0b3IgcGFydCBpcyBjb250YWluZWQgaW4uXG5cdCAqL1xuXHRyZWFkb25seSB3aW5kb3dJZDogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBUaGUgc2l6ZSBvZiB0aGUgZWRpdG9yIHBhcnQuXG5cdCAqL1xuXHRyZWFkb25seSBjb250ZW50RGltZW5zaW9uOiBJRGltZW5zaW9uO1xuXG5cdC8qKlxuXHQgKiBGaW5kIG91dCBpZiBhbiBlZGl0b3IgZ3JvdXAgaXMgY3VycmVudGx5IG1heGltaXplZC5cblx0ICovXG5cdGhhc01heGltaXplZEdyb3VwKCk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIGNlbnRlcmVkIGVkaXRvciBsYXlvdXQuXG5cdCAqL1xuXHRjZW50ZXJMYXlvdXQoYWN0aXZlOiBib29sZWFuKTogdm9pZDtcblxuXHQvKipcblx0ICogRmluZCBvdXQgaWYgdGhlIGVkaXRvciBsYXlvdXQgaXMgY3VycmVudGx5IGNlbnRlcmVkLlxuXHQgKi9cblx0aXNMYXlvdXRDZW50ZXJlZCgpOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElBdXhpbGlhcnlFZGl0b3JQYXJ0IGV4dGVuZHMgSUVkaXRvclBhcnQge1xuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGlzIGF1eGlsaWFyeSBlZGl0b3IgcGFydCBhZnRlciBtb3ZpbmcgYWxsXG5cdCAqIGVkaXRvcnMgb2YgYWxsIGdyb3VwcyBiYWNrIHRvIHRoZSBtYWluIGVkaXRvciBwYXJ0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyBgZmFsc2VgIGlmIGFuIGVkaXRvciBjb3VsZCBub3QgYmUgbW92ZWQgYmFjay5cblx0ICovXG5cdGNsb3NlKCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUVkaXRvcldvcmtpbmdTZXQge1xuXHRyZWFkb25seSBpZDogc3RyaW5nO1xuXHRyZWFkb25seSBuYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUVkaXRvcldvcmtpbmdTZXRPcHRpb25zIHtcblx0cmVhZG9ubHkgcHJlc2VydmVGb2N1cz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUVkaXRvckdyb3VwQ29udGV4dEtleVByb3ZpZGVyPFQgZXh0ZW5kcyBDb250ZXh0S2V5VmFsdWU+IHtcblxuXHQvKipcblx0ICogVGhlIGNvbnRleHQga2V5IHRoYXQgbmVlZHMgdG8gYmUgc2V0IGZvciBlYWNoIGVkaXRvciBncm91cCBjb250ZXh0IGFuZCB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdCAqL1xuXHRyZWFkb25seSBjb250ZXh0S2V5OiBSYXdDb250ZXh0S2V5PFQ+O1xuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIGNvbnRleHQga2V5IHZhbHVlIGZvciB0aGUgZ2l2ZW4gZWRpdG9yIGdyb3VwLlxuXHQgKi9cblx0cmVhZG9ubHkgZ2V0R3JvdXBDb250ZXh0S2V5VmFsdWU6IChncm91cDogSUVkaXRvckdyb3VwKSA9PiBUO1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlcmUgd2FzIGEgY2hhbmdlIGxlYWRpbmcgdG8gdGhlIGNvbnRleHQga2V5IHZhbHVlIHRvIGJlIHJlLWV2YWx1YXRlZC5cblx0ICovXG5cdHJlYWRvbmx5IG9uRGlkQ2hhbmdlPzogRXZlbnQ8dm9pZD47XG59XG5cbi8qKlxuICogVGhlIG1haW4gc2VydmljZSB0byBpbnRlcmFjdCB3aXRoIGVkaXRvciBncm91cHMgYWNyb3NzIGFsbCBvcGVuZWQgZWRpdG9yIHBhcnRzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElFZGl0b3JHcm91cHNTZXJ2aWNlIGV4dGVuZHMgSUVkaXRvckdyb3Vwc0NvbnRhaW5lciB7XG5cblx0cmVhZG9ubHkgX3NlcnZpY2VCcmFuZDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCBmb3Igd2hlbiBhIG5ldyBhdXhpbGlhcnkgZWRpdG9yIHBhcnQgaXMgY3JlYXRlZC5cblx0ICovXG5cdHJlYWRvbmx5IG9uRGlkQ3JlYXRlQXV4aWxpYXJ5RWRpdG9yUGFydDogRXZlbnQ8SUF1eGlsaWFyeUVkaXRvclBhcnQ+O1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIG1haW4gd2luZG93IGVkaXRvciBwYXJ0LlxuXHQgKi9cblx0cmVhZG9ubHkgbWFpblBhcnQ6IElFZGl0b3JQYXJ0O1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhY2Nlc3MgdG8gYWxsIGVkaXRvciBwYXJ0cy5cblx0ICovXG5cdHJlYWRvbmx5IHBhcnRzOiBSZWFkb25seUFycmF5PElFZGl0b3JQYXJ0PjtcblxuXHQvKipcblx0ICogR2V0IHRoZSBlZGl0b3IgcGFydCB0aGF0IGNvbnRhaW5zIHRoZSBncm91cCB3aXRoIHRoZSBwcm92aWRlZCBpZGVudGlmaWVyLlxuXHQgKi9cblx0Z2V0UGFydChncm91cDogSUVkaXRvckdyb3VwIHwgR3JvdXBJZGVudGlmaWVyKTogSUVkaXRvclBhcnQ7XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgZWRpdG9yIHBhcnQgdGhhdCBpcyByb290ZWQgaW4gdGhlIHByb3ZpZGVkIGNvbnRhaW5lci5cblx0ICovXG5cdGdldFBhcnQoY29udGFpbmVyOiB1bmtub3duIC8qIEhUTUxFbGVtZW50ICovKTogSUVkaXRvclBhcnQ7XG5cblx0LyoqXG5cdCAqIE9wZW5zIGEgbmV3IHdpbmRvdyB3aXRoIGEgZnVsbCBlZGl0b3IgcGFydCBpbnN0YW50aWF0ZWRcblx0ICogaW4gdGhlcmUgYXQgdGhlIG9wdGlvbmFsIHBvc2l0aW9uIGFuZCBzaXplIG9uIHNjcmVlbi5cblx0ICovXG5cdGNyZWF0ZUF1eGlsaWFyeUVkaXRvclBhcnQob3B0aW9ucz86IHsgYm91bmRzPzogUGFydGlhbDxJUmVjdGFuZ2xlPjsgY29tcGFjdD86IGJvb2xlYW47IGFsd2F5c09uVG9wPzogYm9vbGVhbiB9KTogUHJvbWlzZTxJQXV4aWxpYXJ5RWRpdG9yUGFydD47XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGluc3RhbnRpYXRpb24gc2VydmljZSB0aGF0IGlzIHNjb3BlZCB0byB0aGVcblx0ICogcHJvdmlkZWQgZWRpdG9yIHBhcnQuIFVzZSB0aGlzIG1ldGhvZCB3aGVuIGJ1aWxkaW5nIFVJXG5cdCAqIHRoYXQgY29udHJpYnV0ZXMgdG8gYXV4aWxpYXJ5IGVkaXRvciBwYXJ0cyB0byBlbnN1cmUgdGhlXG5cdCAqIFVJIGlzIHNjb3BlZCB0byB0aGF0IHBhcnQuXG5cdCAqL1xuXHRnZXRTY29wZWRJbnN0YW50aWF0aW9uU2VydmljZShwYXJ0OiBJRWRpdG9yUGFydCk6IElJbnN0YW50aWF0aW9uU2VydmljZTtcblxuXHQvKipcblx0ICogU2F2ZSBhIG5ldyBlZGl0b3Igd29ya2luZyBzZXQgZnJvbSB0aGUgY3VycmVudGx5IG9wZW5lZFxuXHQgKiBlZGl0b3JzIGFuZCBncm91cCBsYXlvdXQuXG5cdCAqL1xuXHRzYXZlV29ya2luZ1NldChuYW1lOiBzdHJpbmcpOiBJRWRpdG9yV29ya2luZ1NldDtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbGwga25vd24gZWRpdG9yIHdvcmtpbmcgc2V0cy5cblx0ICovXG5cdGdldFdvcmtpbmdTZXRzKCk6IElFZGl0b3JXb3JraW5nU2V0W107XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIHdvcmtpbmcgc2V0LiBVc2UgYGVtcHR5YCB0byBhcHBseSBhbiBlbXB0eSB3b3JraW5nIHNldC5cblx0ICpcblx0ICogQHJldHVybnMgYHRydWVgIHdoZW4gdGhlIHdvcmtpbmcgc2V0IGFzIGFwcGxpZWQuXG5cdCAqL1xuXHRhcHBseVdvcmtpbmdTZXQod29ya2luZ1NldDogSUVkaXRvcldvcmtpbmdTZXQgfCAnZW1wdHknLCBvcHRpb25zPzogSUVkaXRvcldvcmtpbmdTZXRPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPjtcblxuXHQvKipcblx0ICogRGVsZXRlcyBhIHdvcmtpbmcgc2V0LlxuXHQgKi9cblx0ZGVsZXRlV29ya2luZ1NldCh3b3JraW5nU2V0OiBJRWRpdG9yV29ya2luZ1NldCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIGNvbnRleHQga2V5IHByb3ZpZGVyLiBUaGlzIHByb3ZpZGVyIHNldHMgYSBjb250ZXh0IGtleSBmb3IgZWFjaCBzY29wZWQgZWRpdG9yIGdyb3VwIGNvbnRleHQgYW5kIHRoZSBnbG9iYWwgY29udGV4dC5cblx0ICpcblx0ICogQHBhcmFtIHByb3ZpZGVyIC0gVGhlIGNvbnRleHQga2V5IHByb3ZpZGVyIHRvIGJlIHJlZ2lzdGVyZWQuXG5cdCAqIEByZXR1cm5zIC0gQSBkaXNwb3NhYmxlIG9iamVjdCB0byB1bnJlZ2lzdGVyIHRoZSBwcm92aWRlci5cblx0ICovXG5cdHJlZ2lzdGVyQ29udGV4dEtleVByb3ZpZGVyPFQgZXh0ZW5kcyBDb250ZXh0S2V5VmFsdWU+KHByb3ZpZGVyOiBJRWRpdG9yR3JvdXBDb250ZXh0S2V5UHJvdmlkZXI8VD4pOiBJRGlzcG9zYWJsZTtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gT3BlbkVkaXRvckNvbnRleHQge1xuXHRORVdfRURJVE9SID0gMSxcblx0TU9WRV9FRElUT1IgPSAyLFxuXHRDT1BZX0VESVRPUiA9IDNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQWN0aXZlRWRpdG9yQWN0aW9ucyB7XG5cdHJlYWRvbmx5IGFjdGlvbnM6IElUb29sYmFyQWN0aW9ucztcblx0cmVhZG9ubHkgb25EaWRDaGFuZ2U6IEV2ZW50PElNZW51Q2hhbmdlRXZlbnQgfCB2b2lkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRWRpdG9yR3JvdXAge1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCB3aGljaCBmaXJlcyB3aGVuZXZlciB0aGUgdW5kZXJseWluZyBncm91cCBtb2RlbCBjaGFuZ2VzLlxuXHQgKi9cblx0cmVhZG9ubHkgb25EaWRNb2RlbENoYW5nZTogRXZlbnQ8SUdyb3VwTW9kZWxDaGFuZ2VFdmVudD47XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgZ3JvdXAgZ2V0cyBkaXNwb3NlZC5cblx0ICovXG5cdHJlYWRvbmx5IG9uV2lsbERpc3Bvc2U6IEV2ZW50PHZvaWQ+O1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIGFjdGl2ZSBlZGl0b3IgaW4gdGhlIGdyb3VwIGNoYW5nZWQuXG5cdCAqL1xuXHRyZWFkb25seSBvbkRpZEFjdGl2ZUVkaXRvckNoYW5nZTogRXZlbnQ8SUFjdGl2ZUVkaXRvckNoYW5nZUV2ZW50PjtcblxuXHQvKipcblx0ICogQW4gZXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIGFuIGVkaXRvciBpcyBhYm91dCB0byBjbG9zZS5cblx0ICovXG5cdHJlYWRvbmx5IG9uV2lsbENsb3NlRWRpdG9yOiBFdmVudDxJRWRpdG9yQ2xvc2VFdmVudD47XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBhbiBlZGl0b3IgaXMgY2xvc2VkLlxuXHQgKi9cblx0cmVhZG9ubHkgb25EaWRDbG9zZUVkaXRvcjogRXZlbnQ8SUVkaXRvckNsb3NlRXZlbnQ+O1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gYW4gZWRpdG9yIGlzIGFib3V0IHRvIG1vdmUgdG9cblx0ICogYSBkaWZmZXJlbnQgZ3JvdXAuXG5cdCAqL1xuXHRyZWFkb25seSBvbldpbGxNb3ZlRWRpdG9yOiBFdmVudDxJRWRpdG9yV2lsbE1vdmVFdmVudD47XG5cblx0LyoqXG5cdCAqIEEgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhpcyBncm91cCB0aGF0IHJlbWFpbnMgaWRlbnRpY2FsIGV2ZW4gaWYgdGhlXG5cdCAqIGdyb3VwIGlzIG1vdmVkIHRvIGRpZmZlcmVudCBsb2NhdGlvbnMuXG5cdCAqL1xuXHRyZWFkb25seSBpZDogR3JvdXBJZGVudGlmaWVyO1xuXG5cdC8qKlxuXHQgKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgd2luZG93IHRoaXMgZWRpdG9yIGdyb3VwIGlzIHBhcnQgb2YuXG5cdCAqL1xuXHRyZWFkb25seSB3aW5kb3dJZDogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBBIG51bWJlciB0aGF0IGluZGljYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhpcyBncm91cCBpbiB0aGUgdmlzdWFsXG5cdCAqIG9yZGVyIG9mIGdyb3VwcyBmcm9tIGxlZnQgdG8gcmlnaHQgYW5kIHRvcCB0byBib3R0b20uIFRoZSBsb3dlc3Rcblx0ICogaW5kZXggd2lsbCBsaWtlbHkgYmUgdG9wLWxlZnQgd2hpbGUgdGhlIGxhcmdlc3QgaW5kZXggaW4gbW9zdFxuXHQgKiBjYXNlcyBzaG91bGQgYmUgYm90dG9tLXJpZ2h0LCBidXQgdGhhdCBkZXBlbmRzIG9uIHRoZSBncmlkLlxuXHQgKi9cblx0cmVhZG9ubHkgaW5kZXg6IG51bWJlcjtcblxuXHQvKipcblx0ICogQSBodW1hbiByZWFkYWJsZSBsYWJlbCBmb3IgdGhlIGdyb3VwLiBUaGlzIGxhYmVsIGNhbiBjaGFuZ2UgZGVwZW5kaW5nXG5cdCAqIG9uIHRoZSBsYXlvdXQgb2YgYWxsIGVkaXRvciBncm91cHMuIENsaWVudHMgc2hvdWxkIGxpc3RlbiBvbiB0aGVcblx0ICogYG9uRGlkR3JvdXBNb2RlbENoYW5nZWAgZXZlbnQgdG8gcmVhY3QgdG8gdGhhdC5cblx0ICovXG5cdHJlYWRvbmx5IGxhYmVsOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIEEgaHVtYW4gcmVhZGFibGUgbGFiZWwgZm9yIHRoZSBncm91cCB0byBiZSB1c2VkIGJ5IHNjcmVlbiByZWFkZXJzLlxuXHQgKi9cblx0cmVhZG9ubHkgYXJpYUxhYmVsOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIFRoZSBhY3RpdmUgZWRpdG9yIHBhbmUgaXMgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGVkaXRvciBwYW5lIG9mIHRoZSBncm91cC5cblx0ICovXG5cdHJlYWRvbmx5IGFjdGl2ZUVkaXRvclBhbmU6IElWaXNpYmxlRWRpdG9yUGFuZSB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogVGhlIGFjdGl2ZSBlZGl0b3IgaXMgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGVkaXRvciBvZiB0aGUgZ3JvdXBcblx0ICogd2l0aGluIHRoZSBjdXJyZW50IGFjdGl2ZSBlZGl0b3IgcGFuZS5cblx0ICovXG5cdHJlYWRvbmx5IGFjdGl2ZUVkaXRvcjogRWRpdG9ySW5wdXQgfCBudWxsO1xuXG5cdC8qKlxuXHQgKiBBbGwgc2VsZWN0ZWQgZWRpdG9yIGluIHRoaXMgZ3JvdXAgaW4gc2VxdWVudGlhbCBvcmRlci5cblx0ICogVGhlIGFjdGl2ZSBlZGl0b3IgaXMgYWx3YXlzIHBhcnQgb2YgdGhlIHNlbGVjdGlvbi5cblx0ICovXG5cdHJlYWRvbmx5IHNlbGVjdGVkRWRpdG9yczogRWRpdG9ySW5wdXRbXTtcblxuXHQvKipcblx0ICogVGhlIGVkaXRvciBpbiB0aGUgZ3JvdXAgdGhhdCBpcyBpbiBwcmV2aWV3IG1vZGUgaWYgYW55LiBUaGVyZSBjYW5cblx0ICogb25seSBldmVyIGJlIG9uZSBlZGl0b3IgaW4gcHJldmlldyBtb2RlLlxuXHQgKi9cblx0cmVhZG9ubHkgcHJldmlld0VkaXRvcjogRWRpdG9ySW5wdXQgfCBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIG9wZW5lZCBlZGl0b3JzIGluIHRoaXMgZ3JvdXAuXG5cdCAqL1xuXHRyZWFkb25seSBjb3VudDogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRoZSBncm91cCBoYXMgZWRpdG9ycyBvciBub3QuXG5cdCAqL1xuXHRyZWFkb25seSBpc0VtcHR5OiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRoaXMgZWRpdG9yIGdyb3VwIGlzIGxvY2tlZCBvciBub3QuIExvY2tlZCBlZGl0b3IgZ3JvdXBzXG5cdCAqIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBlZGl0b3JzIHRvIG9wZW4gaW4gd2hlbiB0aGUgZ3JvdXAgaXNcblx0ICogZXhwbGljaXRseSBwcm92aWRlZCBmb3IgdGhlIGVkaXRvci5cblx0ICpcblx0ICogTm90ZTogZWRpdG9yIGdyb3VwIGxvY2tpbmcgb25seSBhcHBsaWVzIHdoZW4gbW9yZSB0aGFuIG9uZSBncm91cFxuXHQgKiBpcyBvcGVuZWQuXG5cdCAqL1xuXHRyZWFkb25seSBpc0xvY2tlZDogYm9vbGVhbjtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiBzdGlja3kgZWRpdG9ycyBpbiB0aGlzIGdyb3VwLlxuXHQgKi9cblx0cmVhZG9ubHkgc3RpY2t5Q291bnQ6IG51bWJlcjtcblxuXHQvKipcblx0ICogQWxsIG9wZW5lZCBlZGl0b3JzIGluIHRoZSBncm91cCBpbiBzZXF1ZW50aWFsIG9yZGVyIG9mIHRoZWlyIGFwcGVhcmFuY2UuXG5cdCAqL1xuXHRyZWFkb25seSBlZGl0b3JzOiByZWFkb25seSBFZGl0b3JJbnB1dFtdO1xuXG5cdC8qKlxuXHQgKiBUaGUgc2NvcGVkIGNvbnRleHQga2V5IHNlcnZpY2UgZm9yIHRoaXMgZ3JvdXAuXG5cdCAqL1xuXHRyZWFkb25seSBzY29wZWRDb250ZXh0S2V5U2VydmljZTogSUNvbnRleHRLZXlTZXJ2aWNlO1xuXG5cdC8qKlxuXHQgKiBHZXQgYWxsIGVkaXRvcnMgdGhhdCBhcmUgY3VycmVudGx5IG9wZW5lZCBpbiB0aGUgZ3JvdXAuXG5cdCAqXG5cdCAqIEBwYXJhbSBvcmRlciB0aGUgb3JkZXIgb2YgdGhlIGVkaXRvcnMgdG8gdXNlXG5cdCAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgdG8gc2VsZWN0IG9ubHkgc3BlY2lmaWMgZWRpdG9ycyBhcyBpbnN0cnVjdGVkXG5cdCAqL1xuXHRnZXRFZGl0b3JzKG9yZGVyOiBFZGl0b3JzT3JkZXIsIG9wdGlvbnM/OiB7IGV4Y2x1ZGVTdGlja3k/OiBib29sZWFuIH0pOiByZWFkb25seSBFZGl0b3JJbnB1dFtdO1xuXG5cdC8qKlxuXHQgKiBGaW5kcyBhbGwgZWRpdG9ycyBmb3IgdGhlIGdpdmVuIHJlc291cmNlIHRoYXQgYXJlIGN1cnJlbnRseVxuXHQgKiBvcGVuZWQgaW4gdGhlIGdyb3VwLiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBhbiBlbnRyeSBmb3Jcblx0ICogZWFjaCBlZGl0b3IgdGhhdCByZXBvcnRzIGEgYHJlc291cmNlYCB0aGF0IG1hdGNoZXMgdGhlXG5cdCAqIHByb3ZpZGVkIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHJlc291cmNlIHRoZSByZXNvdXJjZSBvZiB0aGUgZWRpdG9yIHRvIGZpbmRcblx0ICogQHBhcmFtIG9wdGlvbnMgd2hldGhlciB0byBzdXBwb3J0IHNpZGUgYnkgc2lkZSBlZGl0b3JzIG9yIG5vdFxuXHQgKi9cblx0ZmluZEVkaXRvcnMocmVzb3VyY2U6IFVSSSwgb3B0aW9ucz86IElGaW5kRWRpdG9yT3B0aW9ucyk6IHJlYWRvbmx5IEVkaXRvcklucHV0W107XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGVkaXRvciBhdCBhIHNwZWNpZmljIGluZGV4IG9mIHRoZSBncm91cC5cblx0ICovXG5cdGdldEVkaXRvckJ5SW5kZXgoaW5kZXg6IG51bWJlcik6IEVkaXRvcklucHV0IHwgdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWRpdG9yIGluIHRoZSBncm91cCBvciAtMSBpZiBub3Qgb3BlbmVkLlxuXHQgKi9cblx0Z2V0SW5kZXhPZkVkaXRvcihlZGl0b3I6IEVkaXRvcklucHV0KTogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRoZSBlZGl0b3IgaXMgdGhlIGZpcnN0IGluIHRoZSBncm91cC5cblx0ICovXG5cdGlzRmlyc3QoZWRpdG9yOiBFZGl0b3JJbnB1dCk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhlIGVkaXRvciBpcyB0aGUgbGFzdCBpbiB0aGUgZ3JvdXAuXG5cdCAqL1xuXHRpc0xhc3QoZWRpdG9yOiBFZGl0b3JJbnB1dCk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIE9wZW4gYW4gZWRpdG9yIGluIHRoaXMgZ3JvdXAuXG5cdCAqXG5cdCAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFyb3VuZCBhbiBJRWRpdG9yIGluc3RhbmNlIHVubGVzc1xuXHQgKiB0aGUgY2FsbCBmYWlsZWQsIG9yIHRoZSBlZGl0b3Igd2FzIG5vdCBvcGVuZWQgYXMgYWN0aXZlIGVkaXRvci5cblx0ICovXG5cdG9wZW5FZGl0b3IoZWRpdG9yOiBFZGl0b3JJbnB1dCwgb3B0aW9ucz86IElFZGl0b3JPcHRpb25zKTogUHJvbWlzZTxJRWRpdG9yUGFuZSB8IHVuZGVmaW5lZD47XG5cblx0LyoqXG5cdCAqIE9wZW5zIGVkaXRvcnMgaW4gdGhpcyBncm91cC5cblx0ICpcblx0ICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYXJvdW5kIGFuIElFZGl0b3IgaW5zdGFuY2UgdW5sZXNzXG5cdCAqIHRoZSBjYWxsIGZhaWxlZCwgb3IgdGhlIGVkaXRvciB3YXMgbm90IG9wZW5lZCBhcyBhY3RpdmUgZWRpdG9yLiBTaW5jZVxuXHQgKiBhIGdyb3VwIGNhbiBvbmx5IGV2ZXIgaGF2ZSBvbmUgYWN0aXZlIGVkaXRvciwgZXZlbiBpZiBtYW55IGVkaXRvcnMgYXJlXG5cdCAqIG9wZW5lZCwgdGhlIHJlc3VsdCB3aWxsIG9ubHkgYmUgb25lIGVkaXRvci5cblx0ICovXG5cdG9wZW5FZGl0b3JzKGVkaXRvcnM6IEVkaXRvcklucHV0V2l0aE9wdGlvbnNbXSk6IFByb21pc2U8SUVkaXRvclBhbmUgfCB1bmRlZmluZWQ+O1xuXG5cdC8qKlxuXHQgKiBGaW5kIG91dCBpZiB0aGUgcHJvdmlkZWQgZWRpdG9yIGlzIHBpbm5lZCBpbiB0aGUgZ3JvdXAuXG5cdCAqL1xuXHRpc1Bpbm5lZChlZGl0b3JPckluZGV4OiBFZGl0b3JJbnB1dCB8IG51bWJlcik6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIEZpbmQgb3V0IGlmIHRoZSBwcm92aWRlZCBlZGl0b3Igb3IgaW5kZXggb2YgZWRpdG9yIGlzIHN0aWNreSBpbiB0aGUgZ3JvdXAuXG5cdCAqL1xuXHRpc1N0aWNreShlZGl0b3JPckluZGV4OiBFZGl0b3JJbnB1dCB8IG51bWJlcik6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIEZpbmQgb3V0IGlmIHRoZSBwcm92aWRlZCBlZGl0b3Igb3IgaW5kZXggb2YgZWRpdG9yIGlzIHRyYW5zaWVudCBpbiB0aGUgZ3JvdXAuXG5cdCAqL1xuXHRpc1RyYW5zaWVudChlZGl0b3JPckluZGV4OiBFZGl0b3JJbnB1dCB8IG51bWJlcik6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIEZpbmQgb3V0IGlmIHRoZSBwcm92aWRlZCBlZGl0b3IgaXMgYWN0aXZlIGluIHRoZSBncm91cC5cblx0ICovXG5cdGlzQWN0aXZlKGVkaXRvcjogRWRpdG9ySW5wdXQgfCBJVW50eXBlZEVkaXRvcklucHV0KTogYm9vbGVhbjtcblxuXHQvKipcblx0ICogV2hldGhlciB0aGUgZWRpdG9yIGlzIHNlbGVjdGVkIGluIHRoZSBncm91cC5cblx0ICovXG5cdGlzU2VsZWN0ZWQoZWRpdG9yOiBFZGl0b3JJbnB1dCk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIFNldCBhIG5ldyBzZWxlY3Rpb24gZm9yIHRoaXMgZ3JvdXAuIFRoaXMgd2lsbCByZXBsYWNlIHRoZSBjdXJyZW50XG5cdCAqIHNlbGVjdGlvbiB3aXRoIHRoZSBuZXcgc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0gYWN0aXZlU2VsZWN0ZWRFZGl0b3IgdGhlIGVkaXRvciB0byBzZXQgYXMgYWN0aXZlIHNlbGVjdGVkIGVkaXRvclxuXHQgKiBAcGFyYW0gaW5hY3RpdmVTZWxlY3RlZEVkaXRvcnMgdGhlIGluYWN0aXZlIGVkaXRvcnMgdG8gc2V0IGFzIHNlbGVjdGVkXG5cdCAqL1xuXHRzZXRTZWxlY3Rpb24oYWN0aXZlU2VsZWN0ZWRFZGl0b3I6IEVkaXRvcklucHV0LCBpbmFjdGl2ZVNlbGVjdGVkRWRpdG9yczogRWRpdG9ySW5wdXRbXSk6IFByb21pc2U8dm9pZD47XG5cblx0LyoqXG5cdCAqIEZpbmQgb3V0IGlmIGEgY2VydGFpbiBlZGl0b3IgaXMgaW5jbHVkZWQgaW4gdGhlIGdyb3VwLlxuXHQgKlxuXHQgKiBAcGFyYW0gY2FuZGlkYXRlIHRoZSBlZGl0b3IgdG8gZmluZFxuXHQgKiBAcGFyYW0gb3B0aW9ucyBmaW5lIHR1bmUgaG93IHRvIG1hdGNoIGVkaXRvcnNcblx0ICovXG5cdGNvbnRhaW5zKGNhbmRpZGF0ZTogRWRpdG9ySW5wdXQgfCBJVW50eXBlZEVkaXRvcklucHV0LCBvcHRpb25zPzogSU1hdGNoRWRpdG9yT3B0aW9ucyk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIE1vdmUgYW4gZWRpdG9yIGZyb20gdGhpcyBncm91cCBlaXRoZXIgd2l0aGluIHRoaXMgZ3JvdXAgb3IgdG8gYW5vdGhlciBncm91cC5cblx0ICpcblx0ICogQHJldHVybnMgd2hldGhlciB0aGUgZWRpdG9yIHdhcyBtb3ZlZCBvciBub3QuXG5cdCAqL1xuXHRtb3ZlRWRpdG9yKGVkaXRvcjogRWRpdG9ySW5wdXQsIHRhcmdldDogSUVkaXRvckdyb3VwLCBvcHRpb25zPzogSUVkaXRvck9wdGlvbnMpOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBNb3ZlIGVkaXRvcnMgZnJvbSB0aGlzIGdyb3VwIGVpdGhlciB3aXRoaW4gdGhpcyBncm91cCBvciB0byBhbm90aGVyIGdyb3VwLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB3aGV0aGVyIGFsbCBlZGl0b3JzIHdlcmUgbW92ZWQgb3Igbm90LlxuXHQgKi9cblx0bW92ZUVkaXRvcnMoZWRpdG9yczogRWRpdG9ySW5wdXRXaXRoT3B0aW9uc1tdLCB0YXJnZXQ6IElFZGl0b3JHcm91cCk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIENvcHkgYW4gZWRpdG9yIGZyb20gdGhpcyBncm91cCB0byBhbm90aGVyIGdyb3VwLlxuXHQgKlxuXHQgKiBOb3RlOiBJdCBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB0byBzaG93IHRoZSBzYW1lIGVkaXRvciBtb3JlIHRoYW4gb25jZSBpbiB0aGUgc2FtZSBncm91cC5cblx0ICovXG5cdGNvcHlFZGl0b3IoZWRpdG9yOiBFZGl0b3JJbnB1dCwgdGFyZ2V0OiBJRWRpdG9yR3JvdXAsIG9wdGlvbnM/OiBJRWRpdG9yT3B0aW9ucyk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIENvcHkgZWRpdG9ycyBmcm9tIHRoaXMgZ3JvdXAgdG8gYW5vdGhlciBncm91cC5cblx0ICpcblx0ICogTm90ZTogSXQgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdG8gc2hvdyB0aGUgc2FtZSBlZGl0b3IgbW9yZSB0aGFuIG9uY2UgaW4gdGhlIHNhbWUgZ3JvdXAuXG5cdCAqL1xuXHRjb3B5RWRpdG9ycyhlZGl0b3JzOiBFZGl0b3JJbnB1dFdpdGhPcHRpb25zW10sIHRhcmdldDogSUVkaXRvckdyb3VwKTogdm9pZDtcblxuXHQvKipcblx0ICogQ2xvc2UgYW4gZWRpdG9yIGZyb20gdGhlIGdyb3VwLiBUaGlzIG1heSB0cmlnZ2VyIGEgY29uZmlybWF0aW9uIGRpYWxvZyBpZlxuXHQgKiB0aGUgZWRpdG9yIGlzIGRpcnR5IGFuZCB0aHVzIHJldHVybnMgYSBwcm9taXNlIGFzIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0gZWRpdG9yIHRoZSBlZGl0b3IgdG8gY2xvc2UsIG9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVkaXRvclxuXHQgKiBpZiB1bnNwZWNpZmllZC5cblx0ICpcblx0ICogQHJldHVybnMgYSBwcm9taXNlIHdoZW4gdGhlIGVkaXRvciBpcyBjbG9zZWQgb3Igbm90LiBJZiBgdHJ1ZWAsIHRoZSBlZGl0b3Jcblx0ICogaXMgY2xvc2VkIGFuZCBpZiBgZmFsc2VgIHRoZXJlIHdhcyBhIHZldG8gY2xvc2luZyB0aGUgZWRpdG9yLCBlLmcuIHdoZW4gaXRcblx0ICogaXMgZGlydHkuXG5cdCAqL1xuXHRjbG9zZUVkaXRvcihlZGl0b3I/OiBFZGl0b3JJbnB1dCwgb3B0aW9ucz86IElDbG9zZUVkaXRvck9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgc3BlY2lmaWMgZWRpdG9ycyBpbiB0aGlzIGdyb3VwLiBUaGlzIG1heSB0cmlnZ2VyIGEgY29uZmlybWF0aW9uIGRpYWxvZyBpZlxuXHQgKiB0aGVyZSBhcmUgZGlydHkgZWRpdG9ycyBhbmQgdGh1cyByZXR1cm5zIGEgcHJvbWlzZSBhcyB2YWx1ZS5cblx0ICpcblx0ICogQHJldHVybnMgYSBwcm9taXNlIHdoZXRoZXIgdGhlIGVkaXRvcnMgd2VyZSBjbG9zZWQgb3Igbm90LiBJZiBgdHJ1ZWAsIHRoZSBlZGl0b3JzXG5cdCAqIHdlcmUgY2xvc2VkIGFuZCBpZiBgZmFsc2VgIHRoZXJlIHdhcyBhIHZldG8gY2xvc2luZyB0aGUgZWRpdG9ycywgZS5nLiB3aGVuIG9uZVxuXHQgKiBpcyBkaXJ0eS5cblx0ICovXG5cdGNsb3NlRWRpdG9ycyhlZGl0b3JzOiBFZGl0b3JJbnB1dFtdIHwgSUNsb3NlRWRpdG9yc0ZpbHRlciwgb3B0aW9ucz86IElDbG9zZUVkaXRvck9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgYWxsIGVkaXRvcnMgZnJvbSB0aGUgZ3JvdXAuIFRoaXMgbWF5IHRyaWdnZXIgYSBjb25maXJtYXRpb24gZGlhbG9nIGlmXG5cdCAqIHRoZXJlIGFyZSBkaXJ0eSBlZGl0b3JzIGFuZCB0aHVzIHJldHVybnMgYSBwcm9taXNlIGFzIHZhbHVlLlxuXHQgKlxuXHQgKiBAcmV0dXJucyBhIHByb21pc2UgaWYgY29uZmlybWF0aW9uIGlzIG5lZWRlZCB3aGVuIGFsbCBlZGl0b3JzIGFyZSBjbG9zZWQuXG5cdCAqL1xuXHRjbG9zZUFsbEVkaXRvcnMob3B0aW9uczogeyBleGNsdWRlQ29uZmlybWluZzogdHJ1ZSB9KTogYm9vbGVhbjtcblx0Y2xvc2VBbGxFZGl0b3JzKG9wdGlvbnM/OiBJQ2xvc2VBbGxFZGl0b3JzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj47XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIGVkaXRvcnMgaW4gdGhpcyBncm91cCB3aXRoIHRoZSBwcm92aWRlZCByZXBsYWNlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIGVkaXRvcnMgdGhlIGVkaXRvcnMgdG8gcmVwbGFjZVxuXHQgKlxuXHQgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSByZXBsYWNlZCBhY3RpdmVcblx0ICogZWRpdG9yIChpZiBhbnkpIGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuXHQgKi9cblx0cmVwbGFjZUVkaXRvcnMoZWRpdG9yczogSUVkaXRvclJlcGxhY2VtZW50W10pOiBQcm9taXNlPHZvaWQ+O1xuXG5cdC8qKlxuXHQgKiBTZXQgYW4gZWRpdG9yIHRvIGJlIHBpbm5lZC4gQSBwaW5uZWQgZWRpdG9yIGlzIG5vdCByZXBsYWNlZFxuXHQgKiB3aGVuIGFub3RoZXIgZWRpdG9yIG9wZW5zIGF0IHRoZSBzYW1lIGxvY2F0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0gZWRpdG9yIHRoZSBlZGl0b3IgdG8gcGluLCBvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZGl0b3Jcblx0ICogaWYgdW5zcGVjaWZpZWQuXG5cdCAqL1xuXHRwaW5FZGl0b3IoZWRpdG9yPzogRWRpdG9ySW5wdXQpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBTZXQgYW4gZWRpdG9yIHRvIGJlIHN0aWNreS4gQSBzdGlja3kgZWRpdG9yIGlzIHNob3dpbmcgaW4gdGhlIGJlZ2lubmluZ1xuXHQgKiBvZiB0aGUgdGFiIHN0cmlwZSBhbmQgd2lsbCBub3QgYmUgaW1wYWN0ZWQgYnkgY2xvc2Ugb3BlcmF0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIGVkaXRvciB0aGUgZWRpdG9yIHRvIG1ha2Ugc3RpY2t5LCBvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZGl0b3Jcblx0ICogaWYgdW5zcGVjaWZpZWQuXG5cdCAqL1xuXHRzdGlja0VkaXRvcihlZGl0b3I/OiBFZGl0b3JJbnB1dCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFNldCBhbiBlZGl0b3IgdG8gYmUgbm9uLXN0aWNreSBhbmQgdGh1cyBtb3ZlcyBiYWNrIHRvIGEgbG9jYXRpb24gYWZ0ZXJcblx0ICogc3RpY2t5IGVkaXRvcnMgYW5kIGNhbiBiZSBjbG9zZWQgbm9ybWFsbHkuXG5cdCAqXG5cdCAqIEBwYXJhbSBlZGl0b3IgdGhlIGVkaXRvciB0byBtYWtlIHVuc3RpY2t5LCBvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZGl0b3Jcblx0ICogaWYgdW5zcGVjaWZpZWQuXG5cdCAqL1xuXHR1bnN0aWNrRWRpdG9yKGVkaXRvcj86IEVkaXRvcklucHV0KTogdm9pZDtcblxuXHQvKipcblx0ICogV2hldGhlciB0aGlzIGVkaXRvciBncm91cCBzaG91bGQgYmUgbG9ja2VkIG9yIG5vdC5cblx0ICpcblx0ICogU2VlIHtAbGlua2NvZGUgSUVkaXRvckdyb3VwLmlzTG9ja2VkIGBpc0xvY2tlZGB9XG5cdCAqL1xuXHRsb2NrKGxvY2tlZDogYm9vbGVhbik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIE1vdmUga2V5Ym9hcmQgZm9jdXMgaW50byB0aGUgZ3JvdXAuXG5cdCAqL1xuXHRmb2N1cygpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgdGhlIGVkaXRvciBhY3Rpb25zIGZvciB0aGUgY3VycmVudCBhY3RpdmUgZWRpdG9yLlxuXHQgKi9cblx0Y3JlYXRlRWRpdG9yQWN0aW9ucyhkaXNwb3NhYmxlczogRGlzcG9zYWJsZVN0b3JlLCBtZW51SWQ/OiBNZW51SWQpOiBJQWN0aXZlRWRpdG9yQWN0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRWRpdG9yR3JvdXAob2JqOiB1bmtub3duKTogb2JqIGlzIElFZGl0b3JHcm91cCB7XG5cdGNvbnN0IGdyb3VwID0gb2JqIGFzIElFZGl0b3JHcm91cCB8IHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gISFncm91cCAmJiB0eXBlb2YgZ3JvdXAuaWQgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoZ3JvdXAuZWRpdG9ycyk7XG59XG5cbi8vI3JlZ2lvbiBFZGl0b3IgR3JvdXAgSGVscGVyc1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlZmVycmVkU2lkZUJ5U2lkZUdyb3VwRGlyZWN0aW9uKGNvbmZpZ3VyYXRpb25TZXJ2aWNlOiBJQ29uZmlndXJhdGlvblNlcnZpY2UpOiBHcm91cERpcmVjdGlvbi5ET1dOIHwgR3JvdXBEaXJlY3Rpb24uUklHSFQge1xuXHRjb25zdCBvcGVuU2lkZUJ5U2lkZURpcmVjdGlvbiA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlLmdldFZhbHVlKCd3b3JrYmVuY2guZWRpdG9yLm9wZW5TaWRlQnlTaWRlRGlyZWN0aW9uJyk7XG5cblx0aWYgKG9wZW5TaWRlQnlTaWRlRGlyZWN0aW9uID09PSAnZG93bicpIHtcblx0XHRyZXR1cm4gR3JvdXBEaXJlY3Rpb24uRE9XTjtcblx0fVxuXG5cdHJldHVybiBHcm91cERpcmVjdGlvbi5SSUdIVDtcbn1cblxuLy8jZW5kcmVnaW9uXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrOEJBO0lBQUFBLGFBQUEsWUFBQUEsQ0FBQTtNQUFBLE9BQUFDLGNBQUE7SUFBQTtFQUFBO0VBQUEsT0FBQUEsY0FBQTtBQUFBO0FBQUFELGFBQUE7QUFsOEJBOzs7O0FBTUEsU0FBZ0NFLGVBQWUsUUFBUSw0REFBNEQ7QUFDbkgsU0FBNE1DLGFBQWEsUUFBa0gsMkJBQTJCO0FBYXRXLE9BQU8sTUFBTUMsb0JBQW9CO0FBQUE7QUFBQSxDQUFBSixhQUFBLEdBQUFLLENBQUEsT0FBR0gsZUFBZSxDQUF1QixxQkFBcUIsQ0FBQztBQXdIaEcsT0FBTSxTQUFVSSxtQkFBbUJBLENBQUNDLFdBQW9CO0VBQUE7RUFBQVAsYUFBQSxHQUFBUSxDQUFBO0VBQ3ZELE1BQU1DLFNBQVM7RUFBQTtFQUFBLENBQUFULGFBQUEsR0FBQUssQ0FBQSxPQUFHRSxXQUE2QztFQUFDO0VBQUFQLGFBQUEsR0FBQUssQ0FBQTtFQUVoRSxPQUFPLDJCQUFBTCxhQUFBLEdBQUFVLENBQUEsVUFBQVAsYUFBYSxDQUFDTSxTQUFTLEVBQUVFLE1BQU0sQ0FBQztFQUFBO0VBQUEsQ0FBQVgsYUFBQSxHQUFBVSxDQUFBLFVBQUlQLGFBQWEsQ0FBQ00sU0FBUyxFQUFFRixXQUFXLENBQUM7QUFDakY7QUE0eUJBLE9BQU0sU0FBVUssYUFBYUEsQ0FBQ0MsR0FBWTtFQUFBO0VBQUFiLGFBQUEsR0FBQVEsQ0FBQTtFQUN6QyxNQUFNTSxLQUFLO0VBQUE7RUFBQSxDQUFBZCxhQUFBLEdBQUFLLENBQUEsT0FBR1EsR0FBK0I7RUFBQztFQUFBYixhQUFBLEdBQUFLLENBQUE7RUFFOUMsT0FBTywyQkFBQUwsYUFBQSxHQUFBVSxDQUFBLFdBQUMsQ0FBQ0ksS0FBSztFQUFBO0VBQUEsQ0FBQWQsYUFBQSxHQUFBVSxDQUFBLFVBQUksT0FBT0ksS0FBSyxDQUFDQyxFQUFFLEtBQUssUUFBUTtFQUFBO0VBQUEsQ0FBQWYsYUFBQSxHQUFBVSxDQUFBLFVBQUlNLEtBQUssQ0FBQ0MsT0FBTyxDQUFDSCxLQUFLLENBQUNJLE9BQU8sQ0FBQztBQUMvRTtBQUVBO0FBRUEsT0FBTSxTQUFVQyxpQ0FBaUNBLENBQUNDLG9CQUEyQztFQUFBO0VBQUFwQixhQUFBLEdBQUFRLENBQUE7RUFDNUYsTUFBTWEsdUJBQXVCO0VBQUE7RUFBQSxDQUFBckIsYUFBQSxHQUFBSyxDQUFBLE9BQUdlLG9CQUFvQixDQUFDRSxRQUFRLENBQUMsMENBQTBDLENBQUM7RUFBQztFQUFBdEIsYUFBQSxHQUFBSyxDQUFBO0VBRTFHLElBQUlnQix1QkFBdUIsS0FBSyxNQUFNLEVBQUU7SUFBQTtJQUFBckIsYUFBQSxHQUFBVSxDQUFBO0lBQUFWLGFBQUEsR0FBQUssQ0FBQTtJQUN2QztFQUNELENBQUM7RUFBQTtFQUFBO0lBQUFMLGFBQUEsR0FBQVUsQ0FBQTtFQUFBO0VBQUFWLGFBQUEsR0FBQUssQ0FBQTtFQUVEO0FBQ0Q7QUFFQSIsImlnbm9yZUxpc3QiOltdfQ==
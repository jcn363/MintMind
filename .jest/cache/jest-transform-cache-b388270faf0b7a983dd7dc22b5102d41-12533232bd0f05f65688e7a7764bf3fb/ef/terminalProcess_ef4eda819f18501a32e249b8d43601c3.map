{"version":3,"names":["cov_igsf89pkv","actualCoverage","chunkInput","data","f","chunks","s","nextChunkStartIndex","i","length","b","push","substring"],"sources":["/home/user/Desktop/MintMind/src/vs/platform/terminal/common/terminalProcess.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { UriComponents } from '../../../base/common/uri.js';\nimport { ISerializableEnvironmentVariableCollection, ISerializableEnvironmentVariableCollections } from './environmentVariable.js';\nimport { IFixedTerminalDimensions, IRawTerminalTabLayoutInfo, IReconnectionProperties, ITerminalEnvironment, ITerminalTabAction, ITerminalTabLayoutInfoById, TerminalIcon, TerminalType, TitleEventSource, WaitOnExitValue } from './terminal.js';\n\nexport interface ISingleTerminalConfiguration<T> {\n\tuserValue: T | undefined;\n\tvalue: T | undefined;\n\tdefaultValue: T | undefined;\n}\n\nexport interface ICompleteTerminalConfiguration {\n\t'terminal.integrated.env.windows': ISingleTerminalConfiguration<ITerminalEnvironment>;\n\t'terminal.integrated.env.osx': ISingleTerminalConfiguration<ITerminalEnvironment>;\n\t'terminal.integrated.env.linux': ISingleTerminalConfiguration<ITerminalEnvironment>;\n\t'terminal.integrated.cwd': string;\n\t'terminal.integrated.detectLocale': 'auto' | 'off' | 'on';\n}\n\nexport type ITerminalEnvironmentVariableCollections = [string, ISerializableEnvironmentVariableCollection][];\n\nexport interface IWorkspaceFolderData {\n\turi: UriComponents;\n\tname: string;\n\tindex: number;\n}\n\nexport interface ISetTerminalLayoutInfoArgs {\n\tworkspaceId: string;\n\ttabs: ITerminalTabLayoutInfoById[];\n\tbackground: number[] | null;\n}\n\nexport interface IGetTerminalLayoutInfoArgs {\n\tworkspaceId: string;\n}\n\nexport interface IProcessDetails {\n\tid: number;\n\tpid: number;\n\ttitle: string;\n\ttitleSource: TitleEventSource;\n\tcwd: string;\n\tworkspaceId: string;\n\tworkspaceName: string;\n\tisOrphan: boolean;\n\ticon: TerminalIcon | undefined;\n\tcolor: string | undefined;\n\tfixedDimensions: IFixedTerminalDimensions | undefined;\n\tenvironmentVariableCollections: ISerializableEnvironmentVariableCollections | undefined;\n\treconnectionProperties?: IReconnectionProperties;\n\twaitOnExit?: WaitOnExitValue;\n\thideFromUser?: boolean;\n\tisFeatureTerminal?: boolean;\n\ttype?: TerminalType;\n\thasChildProcesses: boolean;\n\tshellIntegrationNonce: string;\n\ttabActions?: ITerminalTabAction[];\n}\n\nexport type ITerminalTabLayoutInfoDto = IRawTerminalTabLayoutInfo<IProcessDetails>;\n\nexport interface ReplayEntry {\n\tcols: number;\n\trows: number;\n\tdata: string;\n}\n\nconst enum Constants {\n\t/**\n\t * Writing large amounts of data can be corrupted for some reason, after looking into this is\n\t * appears to be a race condition around writing to the FD which may be based on how powerful\n\t * the hardware is. The workaround for this is to space out when large amounts of data is being\n\t * written to the terminal. See https://github.com/microsoft/vscode/issues/38137\n\t */\n\tWriteMaxChunkSize = 50,\n}\n\n/**\n * Splits incoming pty data into chunks to try prevent data corruption that could occur when pasting\n * large amounts of data.\n */\nexport function chunkInput(data: string): string[] {\n\tconst chunks: string[] = [];\n\tlet nextChunkStartIndex = 0;\n\tfor (let i = 0; i < data.length - 1; i++) {\n\t\tif (\n\t\t\t// If the max chunk size is reached\n\t\t\ti - nextChunkStartIndex + 1 >= Constants.WriteMaxChunkSize ||\n\t\t\t// If the next character is ESC, send the pending data to avoid splitting the escape\n\t\t\t// sequence.\n\t\t\tdata[i + 1] === '\\x1b'\n\t\t) {\n\t\t\tchunks.push(data.substring(nextChunkStartIndex, i + 1));\n\t\t\tnextChunkStartIndex = i + 1;\n\t\t\t// Skip the next character as the chunk would be a single character\n\t\t\ti++;\n\t\t}\n\t}\n\t// Push final chunk\n\tif (nextChunkStartIndex !== data.length) {\n\t\tchunks.push(data.substring(nextChunkStartIndex));\n\t}\n\treturn chunks;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA6FG;IAAAA,aAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,aAAA;AA7FH;;;;AAkFA;;;;AAIA,OAAM,SAAUE,UAAUA,CAACC,IAAY;EAAA;EAAAH,aAAA,GAAAI,CAAA;EACtC,MAAMC,MAAM;EAAA;EAAA,CAAAL,aAAA,GAAAM,CAAA,OAAa,EAAE;EAC3B,IAAIC,mBAAmB;EAAA;EAAA,CAAAP,aAAA,GAAAM,CAAA,OAAG,CAAC;EAAC;EAAAN,aAAA,GAAAM,CAAA;EAC5B,KAAK,IAAIE,CAAC;EAAA;EAAA,CAAAR,aAAA,GAAAM,CAAA,OAAG,CAAC,GAAEE,CAAC,GAAGL,IAAI,CAACM,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;IAAA;IAAAR,aAAA,GAAAM,CAAA;IACzC;IACC;IACA;IAAA,CAAAN,aAAA,GAAAU,CAAA,UAAAF,CAAC,GAAGD,mBAAmB,GAAG,CAAC;IAAA;IAAA,CAAAP,aAAA,GAAAU,CAAA;IAC3B;IACA;IACAP,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC,KAAK,MAAM,GACrB;MAAA;MAAAR,aAAA,GAAAU,CAAA;MAAAV,aAAA,GAAAM,CAAA;MACDD,MAAM,CAACM,IAAI,CAACR,IAAI,CAACS,SAAS,CAACL,mBAAmB,EAAEC,CAAC,GAAG,CAAC,CAAC,CAAC;MAAC;MAAAR,aAAA,GAAAM,CAAA;MACxDC,mBAAmB,GAAGC,CAAC,GAAG,CAAC;MAC3B;MAAA;MAAAR,aAAA,GAAAM,CAAA;MACAE,CAAC,EAAE;IACJ,CAAC;IAAA;IAAA;MAAAR,aAAA,GAAAU,CAAA;IAAA;EACF;EACA;EAAA;EAAAV,aAAA,GAAAM,CAAA;EACA,IAAIC,mBAAmB,KAAKJ,IAAI,CAACM,MAAM,EAAE;IAAA;IAAAT,aAAA,GAAAU,CAAA;IAAAV,aAAA,GAAAM,CAAA;IACxCD,MAAM,CAACM,IAAI,CAACR,IAAI,CAACS,SAAS,CAACL,mBAAmB,CAAC,CAAC;EACjD,CAAC;EAAA;EAAA;IAAAP,aAAA,GAAAU,CAAA;EAAA;EAAAV,aAAA,GAAAM,CAAA;EACD,OAAOD,MAAM;AACd","ignoreList":[]}
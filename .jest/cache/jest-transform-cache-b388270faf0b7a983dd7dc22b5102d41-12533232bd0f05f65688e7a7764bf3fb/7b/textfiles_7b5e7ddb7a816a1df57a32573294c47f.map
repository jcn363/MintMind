{"version":3,"names":["cov_2obitm3srd","actualCoverage","FileOperationError","createDecorator","VSBuffer","areFunctions","isUndefinedOrNull","ITextFileService","s","TextFileOperationError","textFileOperationResult","isTextFileOperationError","obj","f","b","Error","options","constructor","message","isTextFileEditorModel","model","candidate","setEncoding","getEncoding","save","revert","isDirty","getLanguageId","snapshotToString","snapshot","chunks","chunk","read","push","join","stringToSnapshot","value","done","toBufferOrReadable","undefined","fromString"],"sources":["/home/user/Desktop/MintMind/src/vs/workbench/services/textfile/common/textfiles.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ISaveOptions, IRevertOptions, SaveReason } from '../../../common/editor.js';\nimport { ReadableStream } from '../../../../base/common/stream.js';\nimport { IBaseFileStatWithMetadata, IFileStatWithMetadata, IWriteFileOptions, FileOperationError, FileOperationResult, IReadFileStreamOptions, IFileReadLimits } from '../../../../platform/files/common/files.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITextEditorModel } from '../../../../editor/common/services/resolverService.js';\nimport { ITextBufferFactory, ITextModel, ITextSnapshot } from '../../../../editor/common/model.js';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { areFunctions, isUndefinedOrNull } from '../../../../base/common/types.js';\nimport { IWorkingCopy, IWorkingCopySaveEvent } from '../../workingCopy/common/workingCopy.js';\nimport { IUntitledTextEditorModelManager } from '../../untitled/common/untitledTextEditorService.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IProgress, IProgressStep } from '../../../../platform/progress/common/progress.js';\nimport { IFileOperationUndoRedoInfo } from '../../workingCopy/common/workingCopyFileService.js';\n\nexport const ITextFileService = createDecorator<ITextFileService>('textFileService');\n\nexport interface ITextFileService extends IDisposable {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Access to the manager of text file editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly files: ITextFileEditorModelManager;\n\n\t/**\n\t * Access to the manager of untitled text editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly untitled: IUntitledTextEditorModelManager;\n\n\t/**\n\t * Helper to determine encoding for resources.\n\t */\n\treadonly encoding: IResourceEncodings;\n\n\t/**\n\t * A resource is dirty if it has unsaved changes or is an untitled file not yet saved.\n\t *\n\t * @param resource the resource to check for being dirty\n\t */\n\tisDirty(resource: URI): boolean;\n\n\t/**\n\t * Saves the resource.\n\t *\n\t * @param resource the resource to save\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsave(resource: URI, options?: ITextFileSaveOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Saves the provided resource asking the user for a file name or using the provided one.\n\t *\n\t * @param resource the resource to save as.\n\t * @param targetResource the optional target to save to.\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsaveAs(resource: URI, targetResource?: URI, options?: ITextFileSaveAsOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Reverts the provided resource.\n\t *\n\t * @param resource the resource of the file to revert.\n\t * @param force to force revert even when the file is not dirty\n\t */\n\trevert(resource: URI, options?: IRevertOptions): Promise<void>;\n\n\t/**\n\t * Read the contents of a file identified by the resource.\n\t */\n\tread(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileContent>;\n\n\t/**\n\t * Read the contents of a file identified by the resource as stream.\n\t */\n\treadStream(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileStreamContent>;\n\n\t/**\n\t * Update a file with given contents.\n\t */\n\twrite(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Create files. If the file exists it will be overwritten with the contents if\n\t * the options enable to overwrite.\n\t */\n\tcreate(operations: { resource: URI; value?: string | ITextSnapshot; options?: { overwrite?: boolean } }[], undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Returns the readable that uses the appropriate encoding. This method should\n\t * be used whenever a `string` or `ITextSnapshot` is being persisted to the\n\t * file system.\n\t */\n\tgetEncodedReadable(resource: URI | undefined, value: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable>;\n\tgetEncodedReadable(resource: URI | undefined, value: string, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable>;\n\tgetEncodedReadable(resource: URI | undefined, value?: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable | undefined>;\n\tgetEncodedReadable(resource: URI | undefined, value?: string, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable | undefined>;\n\tgetEncodedReadable(resource: URI | undefined, value?: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable | undefined>;\n\n\t/**\n\t * Returns a stream of strings that uses the appropriate encoding. This method should\n\t * be used whenever a `VSBufferReadableStream` is being loaded from the file system.\n\t *\n\t * Will throw an error if `acceptTextOnly: true` for resources that seem to be binary.\n\t */\n\tgetDecodedStream(resource: URI | undefined, value: VSBufferReadableStream, options?: IReadTextFileEncodingOptions): Promise<ReadableStream<string>>;\n\n\t/**\n\t * Get the encoding for the provided `resource`. Will try to determine the encoding\n\t * from any existing model for that `resource` and fallback to the configured defaults.\n\t */\n\tgetEncoding(resource: URI): string;\n\n\t/**\n\t * Get the properties for decoding the provided `resource` based on configuration.\n\t */\n\tresolveDecoding(resource: URI | undefined, options?: IReadTextFileEncodingOptions): Promise<{ preferredEncoding: string; guessEncoding: boolean; candidateGuessEncodings: string[] }>;\n\n\t/**\n\t * Get the properties for encoding the provided `resource` based on configuration.\n\t */\n\tresolveEncoding(resource: URI | undefined, options?: IWriteTextFileOptions): Promise<{ encoding: string; addBOM: boolean }>;\n\n\t/**\n\t * Given a detected encoding, validate it against the configured encoding options.\n\t */\n\tvalidateDetectedEncoding(resource: URI | undefined, detectedEncoding: string, options?: IReadTextFileEncodingOptions): Promise<string>;\n}\n\nexport interface IReadTextFileEncodingOptions {\n\n\t/**\n\t * The optional encoding parameter allows to specify the desired encoding when resolving\n\t * the contents of the file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * The optional guessEncoding parameter allows to guess encoding from content of the file.\n\t */\n\treadonly autoGuessEncoding?: boolean;\n\n\t/**\n\t * The optional candidateGuessEncodings parameter limits the allowed encodings to guess from.\n\t */\n\treadonly candidateGuessEncodings?: string[];\n\n\t/**\n\t * The optional acceptTextOnly parameter allows to fail this request early if the file\n\t * contents are not textual.\n\t */\n\treadonly acceptTextOnly?: boolean;\n}\n\nexport interface IReadTextFileOptions extends IReadTextFileEncodingOptions, IReadFileStreamOptions { }\n\nexport interface IWriteTextFileOptions extends IWriteFileOptions {\n\n\t/**\n\t * The encoding to use when updating a file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * Whether to write to the file as elevated (admin) user. When setting this option a prompt will\n\t * ask the user to authenticate as super user.\n\t */\n\treadonly writeElevated?: boolean;\n}\n\nexport const enum TextFileOperationResult {\n\tFILE_IS_BINARY\n}\n\nexport class TextFileOperationError extends FileOperationError {\n\n\tstatic isTextFileOperationError(obj: unknown): obj is TextFileOperationError {\n\t\treturn obj instanceof Error && !isUndefinedOrNull((obj as TextFileOperationError).textFileOperationResult);\n\t}\n\n\toverride readonly options?: IReadTextFileOptions & IWriteTextFileOptions;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic textFileOperationResult: TextFileOperationResult,\n\t\toptions?: IReadTextFileOptions & IWriteTextFileOptions\n\t) {\n\t\tsuper(message, FileOperationResult.FILE_OTHER_ERROR);\n\n\t\tthis.options = options;\n\t}\n}\n\nexport interface IResourceEncodings {\n\tgetPreferredReadEncoding(resource: URI): Promise<IResourceEncoding>;\n\tgetPreferredWriteEncoding(resource: URI, preferredEncoding?: string): Promise<IResourceEncoding>;\n}\n\nexport interface IResourceEncoding {\n\treadonly encoding: string;\n\treadonly hasBOM: boolean;\n}\n\n/**\n * The save error handler can be installed on the text file editor model to install code that executes when save errors occur.\n */\nexport interface ISaveErrorHandler {\n\n\t/**\n\t * Called whenever a save fails.\n\t */\n\tonSaveError(error: Error, model: ITextFileEditorModel, options: ITextFileSaveAsOptions): void;\n}\n\n/**\n * States the text file editor model can be in.\n */\nexport const enum TextFileEditorModelState {\n\n\t/**\n\t * A model is saved.\n\t */\n\tSAVED,\n\n\t/**\n\t * A model is dirty.\n\t */\n\tDIRTY,\n\n\t/**\n\t * A model is currently being saved but this operation has not completed yet.\n\t */\n\tPENDING_SAVE,\n\n\t/**\n\t * A model is in conflict mode when changes cannot be saved because the\n\t * underlying file has changed. Models in conflict mode are always dirty.\n\t */\n\tCONFLICT,\n\n\t/**\n\t * A model is in orphan state when the underlying file has been deleted.\n\t */\n\tORPHAN,\n\n\t/**\n\t * Any error that happens during a save that is not causing the CONFLICT state.\n\t * Models in error mode are always dirty.\n\t */\n\tERROR\n}\n\nexport const enum TextFileResolveReason {\n\tEDITOR = 1,\n\tREFERENCE = 2,\n\tOTHER = 3\n}\n\ninterface IBaseTextFileContent extends IBaseFileStatWithMetadata {\n\n\t/**\n\t * The encoding of the content if known.\n\t */\n\treadonly encoding: string;\n}\n\nexport interface ITextFileContent extends IBaseTextFileContent {\n\n\t/**\n\t * The content of a text file.\n\t */\n\treadonly value: string;\n}\n\nexport interface ITextFileStreamContent extends IBaseTextFileContent {\n\n\t/**\n\t * The line grouped content of a text file.\n\t */\n\treadonly value: ITextBufferFactory;\n}\n\nexport interface ITextFileEditorModelResolveOrCreateOptions extends ITextFileResolveOptions {\n\n\t/**\n\t * The language id to use for the model text content.\n\t */\n\treadonly languageId?: string;\n\n\t/**\n\t * The encoding to use when resolving the model text content.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * If the model was already resolved before, allows to trigger\n\t * a reload of it to fetch the latest contents.\n\t */\n\treadonly reload?: {\n\n\t\t/**\n\t\t * Controls whether the reload happens in the background\n\t\t * or whether `resolve` will await the reload to happen.\n\t\t */\n\t\treadonly async: boolean;\n\t};\n}\n\nexport interface ITextFileSaveEvent extends ITextFileEditorModelSaveEvent {\n\n\t/**\n\t * The model that was saved.\n\t */\n\treadonly model: ITextFileEditorModel;\n}\n\nexport interface ITextFileResolveEvent {\n\n\t/**\n\t * The model that was resolved.\n\t */\n\treadonly model: ITextFileEditorModel;\n\n\t/**\n\t * The reason why the model was resolved.\n\t */\n\treadonly reason: TextFileResolveReason;\n}\n\nexport interface ITextFileSaveParticipantContext {\n\n\t/**\n\t * The reason why the save was triggered.\n\t */\n\treadonly reason: SaveReason;\n\n\t/**\n\t * Only applies to when a text file was saved as, for\n\t * example when starting with untitled and saving. This\n\t * provides access to the initial resource the text\n\t * file had before.\n\t */\n\treadonly savedFrom?: URI;\n}\n\nexport interface ITextFileSaveParticipant {\n\n\t/**\n\t * The ordinal number which determines the order of participation.\n\t * Lower values mean to participant sooner\n\t */\n\treadonly ordinal?: number;\n\n\t/**\n\t * Participate in a save of a model. Allows to change the model\n\t * before it is being saved to disk.\n\t */\n\tparticipate(\n\t\tmodel: ITextFileEditorModel,\n\t\tcontext: ITextFileSaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface ITextFileEditorModelManager {\n\n\treadonly onDidCreate: Event<ITextFileEditorModel>;\n\treadonly onDidResolve: Event<ITextFileResolveEvent>;\n\treadonly onDidChangeDirty: Event<ITextFileEditorModel>;\n\treadonly onDidChangeReadonly: Event<ITextFileEditorModel>;\n\treadonly onDidRemove: Event<URI>;\n\treadonly onDidChangeOrphaned: Event<ITextFileEditorModel>;\n\treadonly onDidChangeEncoding: Event<ITextFileEditorModel>;\n\treadonly onDidSaveError: Event<ITextFileEditorModel>;\n\treadonly onDidSave: Event<ITextFileSaveEvent>;\n\treadonly onDidRevert: Event<ITextFileEditorModel>;\n\n\t/**\n\t * Access to all text file editor models in memory.\n\t */\n\treadonly models: ITextFileEditorModel[];\n\n\t/**\n\t * Allows to configure the error handler that is called on save errors.\n\t */\n\tsaveErrorHandler: ISaveErrorHandler;\n\n\t/**\n\t * Returns the text file editor model for the provided resource\n\t * or undefined if none.\n\t */\n\tget(resource: URI): ITextFileEditorModel | undefined;\n\n\t/**\n\t * Allows to resolve a text file model from disk.\n\t */\n\tresolve(resource: URI, options?: ITextFileEditorModelResolveOrCreateOptions): Promise<ITextFileEditorModel>;\n\n\t/**\n\t * Adds a participant for saving text file models.\n\t */\n\taddSaveParticipant(participant: ITextFileSaveParticipant): IDisposable;\n\n\t/**\n\t * Runs the registered save participants on the provided model.\n\t */\n\trunSaveParticipants(model: ITextFileEditorModel, context: ITextFileSaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;\n\n\t/**\n\t * Waits for the model to be ready to be disposed. There may be conditions\n\t * under which the model cannot be disposed, e.g. when it is dirty. Once the\n\t * promise is settled, it is safe to dispose the model.\n\t */\n\tcanDispose(model: ITextFileEditorModel): true | Promise<true>;\n}\n\nexport interface ITextFileSaveOptions extends ISaveOptions {\n\n\t/**\n\t * Save the file with an attempt to unlock it.\n\t */\n\treadonly writeUnlock?: boolean;\n\n\t/**\n\t * Save the file with elevated privileges.\n\t *\n\t * Note: This may not be supported in all environments.\n\t */\n\treadonly writeElevated?: boolean;\n\n\t/**\n\t * Allows to write to a file even if it has been modified on disk.\n\t */\n\treadonly ignoreModifiedSince?: boolean;\n\n\t/**\n\t * If set, will bubble up the error to the caller instead of handling it.\n\t */\n\treadonly ignoreErrorHandler?: boolean;\n}\n\nexport interface ITextFileSaveAsOptions extends ITextFileSaveOptions {\n\n\t/**\n\t * Optional URI of the resource the text file is saved from if known.\n\t */\n\treadonly from?: URI;\n\n\t/**\n\t * Optional URI to use as suggested file path to save as.\n\t */\n\treadonly suggestedTarget?: URI;\n}\n\nexport interface ITextFileResolveOptions {\n\n\t/**\n\t * The contents to use for the model if known. If not\n\t * provided, the contents will be retrieved from the\n\t * underlying resource or backup if present.\n\t */\n\treadonly contents?: ITextBufferFactory;\n\n\t/**\n\t * Go to file bypassing any cache of the model if any.\n\t */\n\treadonly forceReadFromFile?: boolean;\n\n\t/**\n\t * Allow to resolve a model even if we think it is a binary file.\n\t */\n\treadonly allowBinary?: boolean;\n\n\t/**\n\t * Context why the model is being resolved.\n\t */\n\treadonly reason?: TextFileResolveReason;\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits\n\t * and an error will be thrown if any limit is exceeded.\n\t */\n\treadonly limits?: IFileReadLimits;\n}\n\nexport const enum EncodingMode {\n\n\t/**\n\t * Instructs the encoding support to encode the object with the provided encoding\n\t */\n\tEncode,\n\n\t/**\n\t * Instructs the encoding support to decode the object with the provided encoding\n\t */\n\tDecode\n}\n\nexport interface IEncodingSupport {\n\n\t/**\n\t * Gets the encoding of the object if known.\n\t */\n\tgetEncoding(): string | undefined;\n\n\t/**\n\t * Sets the encoding for the object for saving.\n\t */\n\tsetEncoding(encoding: string, mode: EncodingMode): Promise<void>;\n}\n\nexport interface ILanguageSupport {\n\n\t/**\n\t * Sets the language id of the object.\n\t */\n\tsetLanguageId(languageId: string, source?: string): void;\n}\n\nexport interface ITextFileEditorModelSaveEvent extends IWorkingCopySaveEvent {\n\n\t/**\n\t * The resolved stat from the save operation.\n\t */\n\treadonly stat: IFileStatWithMetadata;\n}\n\nexport interface ITextFileEditorModel extends ITextEditorModel, IEncodingSupport, ILanguageSupport, IWorkingCopy {\n\n\treadonly onDidSave: Event<ITextFileEditorModelSaveEvent>;\n\treadonly onDidSaveError: Event<void>;\n\treadonly onDidChangeOrphaned: Event<void>;\n\treadonly onDidChangeReadonly: Event<void>;\n\treadonly onDidChangeEncoding: Event<void>;\n\n\thasState(state: TextFileEditorModelState): boolean;\n\tjoinState(state: TextFileEditorModelState.PENDING_SAVE): Promise<void>;\n\n\tupdatePreferredEncoding(encoding: string | undefined): void;\n\n\tsave(options?: ITextFileSaveAsOptions): Promise<boolean>;\n\trevert(options?: IRevertOptions): Promise<void>;\n\n\tresolve(options?: ITextFileResolveOptions): Promise<void>;\n\n\tisDirty(): this is IResolvedTextFileEditorModel;\n\n\tgetLanguageId(): string | undefined;\n\n\tisResolved(): this is IResolvedTextFileEditorModel;\n}\n\nexport function isTextFileEditorModel(model: ITextEditorModel): model is ITextFileEditorModel {\n\tconst candidate = model as ITextFileEditorModel;\n\n\treturn areFunctions(candidate.setEncoding, candidate.getEncoding, candidate.save, candidate.revert, candidate.isDirty, candidate.getLanguageId);\n}\n\nexport interface IResolvedTextFileEditorModel extends ITextFileEditorModel {\n\n\treadonly textEditorModel: ITextModel;\n\n\tcreateSnapshot(): ITextSnapshot;\n}\n\nexport function snapshotToString(snapshot: ITextSnapshot): string {\n\tconst chunks: string[] = [];\n\n\tlet chunk: string | null;\n\twhile (typeof (chunk = snapshot.read()) === 'string') {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn chunks.join('');\n}\n\nexport function stringToSnapshot(value: string): ITextSnapshot {\n\tlet done = false;\n\n\treturn {\n\t\tread(): string | null {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\nexport function toBufferOrReadable(value: string): VSBuffer;\nexport function toBufferOrReadable(value: ITextSnapshot): VSBufferReadable;\nexport function toBufferOrReadable(value: string | ITextSnapshot): VSBuffer | VSBufferReadable;\nexport function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined;\nexport function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined {\n\tif (typeof value === 'undefined') {\n\t\treturn undefined;\n\t}\n\n\tif (typeof value === 'string') {\n\t\treturn VSBuffer.fromString(value);\n\t}\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = value.read();\n\t\t\tif (typeof chunk === 'string') {\n\t\t\t\treturn VSBuffer.fromString(chunk);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n"],"mappings":"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","ignoreList":[]}
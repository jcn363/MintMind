9d8d49631fe4bf7fed69d1f54cbdf927
/* istanbul ignore next */
function cov_18qiupa7fo() {
  var path = "/home/user/Desktop/MintMind/src/vs/base/parts/sandbox/electron-browser/electronTypes.ts";
  var hash = "6c6a394173c609283271a96022d3e5daf91d262b";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/user/Desktop/MintMind/src/vs/base/parts/sandbox/electron-browser/electronTypes.ts",
    statementMap: {},
    fnMap: {},
    branchMap: {},
    s: {},
    f: {},
    b: {},
    inputSourceMap: {
      file: "/home/user/Desktop/MintMind/src/vs/base/parts/sandbox/electron-browser/electronTypes.ts",
      mappings: "AAAA;;;gGAGgG",
      names: [],
      sources: ["/home/user/Desktop/MintMind/src/vs/base/parts/sandbox/electron-browser/electronTypes.ts"],
      sourcesContent: ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n// #######################################################################\n// ###                                                                 ###\n// ###      electron.d.ts types we expose from electron-browser        ###\n// ###                    (copied from Electron 29.x)                  ###\n// ###                                                                 ###\n// #######################################################################\n\ntype Event<Params extends object = {}> = {\n\tpreventDefault: () => void;\n\treadonly defaultPrevented: boolean;\n} & Params;\n\nexport interface IpcRendererEvent extends Event {\n\n\t// Docs: https://electronjs.org/docs/api/structures/ipc-renderer-event\n\n\t// Note: API with `Transferable` intentionally commented out because you\n\t// cannot transfer these when `contextIsolation: true`.\n\t// /**\n\t//  * A list of MessagePorts that were transferred with this message\n\t//  */\n\t// ports: MessagePort[];\n\t/**\n\t * The `IpcRenderer` instance that emitted the event originally\n\t */\n\tsender: IpcRenderer;\n}\n\nexport interface IpcRenderer {\n\n\t// Docs: https://electronjs.org/docs/api/ipc-renderer\n\n\t/**\n\t * Resolves with the response from the main process.\n\t *\n\t * Send a message to the main process via `channel` and expect a result\n\t * asynchronously. Arguments will be serialized with the Structured Clone\n\t * Algorithm, just like `window.postMessage`, so prototype chains will not be\n\t * included. Sending Functions, Promises, Symbols, WeakMaps, or WeakSets will throw\n\t * an exception.\n\t *\n\t * The main process should listen for `channel` with `ipcMain.handle()`.\n\t *\n\t * For example:\n\t *\n\t * If you need to transfer a `MessagePort` to the main process, use\n\t * `ipcRenderer.postMessage`.\n\t *\n\t * If you do not need a response to the message, consider using `ipcRenderer.send`.\n\t *\n\t * > **Note** Sending non-standard JavaScript types such as DOM objects or special\n\t * Electron objects will throw an exception.\n\t *\n\t * Since the main process does not have support for DOM objects such as\n\t * `ImageBitmap`, `File`, `DOMMatrix` and so on, such objects cannot be sent over\n\t * Electron's IPC to the main process, as the main process would have no way to\n\t * decode them. Attempting to send such objects over IPC will result in an error.\n\t *\n\t * > **Note** If the handler in the main process throws an error, the promise\n\t * returned by `invoke` will reject. However, the `Error` object in the renderer\n\t * process will not be the same as the one thrown in the main process.\n\t */\n\tinvoke(channel: string, ...args: unknown[]): Promise<unknown>;\n\t/**\n\t * Listens to `channel`, when a new message arrives `listener` would be called with\n\t * `listener(event, args...)`.\n\t */\n\ton(channel: string, listener: (event: IpcRendererEvent, ...args: unknown[]) => void): this;\n\t/**\n\t * Adds a one time `listener` function for the event. This `listener` is invoked\n\t * only the next time a message is sent to `channel`, after which it is removed.\n\t */\n\tonce(channel: string, listener: (event: IpcRendererEvent, ...args: unknown[]) => void): this;\n\t// Note: API with `Transferable` intentionally commented out because you\n\t// cannot transfer these when `contextIsolation: true`.\n\t// /**\n\t//  * Send a message to the main process, optionally transferring ownership of zero or\n\t//  * more `MessagePort` objects.\n\t//  *\n\t//  * The transferred `MessagePort` objects will be available in the main process as\n\t//  * `MessagePortMain` objects by accessing the `ports` property of the emitted\n\t//  * event.\n\t//  *\n\t//  * For example:\n\t//  *\n\t//  * For more information on using `MessagePort` and `MessageChannel`, see the MDN\n\t//  * documentation.\n\t//  */\n\t// postMessage(channel: string, message: unknown, transfer?: MessagePort[]): void;\n\t/**\n\t * Removes the specified `listener` from the listener array for the specified\n\t * `channel`.\n\t */\n\tremoveListener(channel: string, listener: (event: IpcRendererEvent, ...args: unknown[]) => void): this;\n\t/**\n\t * Send an asynchronous message to the main process via `channel`, along with\n\t * arguments. Arguments will be serialized with the Structured Clone Algorithm,\n\t * just like `window.postMessage`, so prototype chains will not be included.\n\t * Sending Functions, Promises, Symbols, WeakMaps, or WeakSets will throw an\n\t * exception.\n\t *\n\t * > **NOTE:** Sending non-standard JavaScript types such as DOM objects or special\n\t * Electron objects will throw an exception.\n\t *\n\t * Since the main process does not have support for DOM objects such as\n\t * `ImageBitmap`, `File`, `DOMMatrix` and so on, such objects cannot be sent over\n\t * Electron's IPC to the main process, as the main process would have no way to\n\t * decode them. Attempting to send such objects over IPC will result in an error.\n\t *\n\t * The main process handles it by listening for `channel` with the `ipcMain`\n\t * module.\n\t *\n\t * If you need to transfer a `MessagePort` to the main process, use\n\t * `ipcRenderer.postMessage`.\n\t *\n\t * If you want to receive a single response from the main process, like the result\n\t * of a method call, consider using `ipcRenderer.invoke`.\n\t */\n\tsend(channel: string, ...args: unknown[]): void;\n}\n\nexport interface WebFrame {\n\t/**\n\t * Changes the zoom level to the specified level. The original size is 0 and each\n\t * increment above or below represents zooming 20% larger or smaller to default\n\t * limits of 300% and 50% of original size, respectively. The formula for this is\n\t * `scale := 1.2 ^ level`.\n\t *\n\t * > **NOTE**: The zoom policy at the Chromium level is same-origin, meaning that\n\t * the zoom level for a specific domain propagates across all instances of windows\n\t * with the same domain. Differentiating the window URLs will make zoom work\n\t * per-window.\n\t */\n\tsetZoomLevel(level: number): void;\n}\n\nexport interface ProcessMemoryInfo {\n\n\t// Docs: https://electronjs.org/docs/api/structures/process-memory-info\n\n\t/**\n\t * The amount of memory not shared by other processes, such as JS heap or HTML\n\t * content in Kilobytes.\n\t */\n\tprivate: number;\n\t/**\n\t * The amount of memory currently pinned to actual physical RAM in Kilobytes.\n\t *\n\t * @platform linux,win32\n\t */\n\tresidentSet: number;\n\t/**\n\t * The amount of memory shared between processes, typically memory consumed by the\n\t * Electron code itself in Kilobytes.\n\t */\n\tshared: number;\n}\n\n/**\n * Additional information around a `app.on('login')` event.\n */\nexport interface AuthInfo {\n\tisProxy: boolean;\n\tscheme: string;\n\thost: string;\n\tport: number;\n\trealm: string;\n}\n\nexport interface WebUtils {\n\n\t// Docs: https://electronjs.org/docs/api/web-utils\n\n\t/**\n\t * The file system path that this `File` object points to. In the case where the\n\t * object passed in is not a `File` object an exception is thrown. In the case\n\t * where the File object passed in was constructed in JS and is not backed by a\n\t * file on disk an empty string is returned.\n\t *\n\t * This method superceded the previous augmentation to the `File` object with the\n\t * `path` property.  An example is included below.\n\t */\n\tgetPathForFile(file: File): string;\n}\n"],
      version: 3
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "6c6a394173c609283271a96022d3e5daf91d262b"
  };
  var coverage = global[gcv] || (global[gcv] = {});
  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }
  var actualCoverage = coverage[path];
  {
    // @ts-ignore
    cov_18qiupa7fo = function () {
      return actualCoverage;
    };
  }
  return actualCoverage;
}
cov_18qiupa7fo();
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
export {};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvdXNlci9EZXNrdG9wL01pbnRNaW5kL3NyYy92cy9iYXNlL3BhcnRzL3NhbmRib3gvZWxlY3Ryb24tYnJvd3Nlci9lbGVjdHJvblR5cGVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyAjIyMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMjI1xuLy8gIyMjICAgICAgZWxlY3Ryb24uZC50cyB0eXBlcyB3ZSBleHBvc2UgZnJvbSBlbGVjdHJvbi1icm93c2VyICAgICAgICAjIyNcbi8vICMjIyAgICAgICAgICAgICAgICAgICAgKGNvcGllZCBmcm9tIEVsZWN0cm9uIDI5LngpICAgICAgICAgICAgICAgICAgIyMjXG4vLyAjIyMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMjI1xuLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudHlwZSBFdmVudDxQYXJhbXMgZXh0ZW5kcyBvYmplY3QgPSB7fT4gPSB7XG5cdHByZXZlbnREZWZhdWx0OiAoKSA9PiB2b2lkO1xuXHRyZWFkb25seSBkZWZhdWx0UHJldmVudGVkOiBib29sZWFuO1xufSAmIFBhcmFtcztcblxuZXhwb3J0IGludGVyZmFjZSBJcGNSZW5kZXJlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG5cdC8vIERvY3M6IGh0dHBzOi8vZWxlY3Ryb25qcy5vcmcvZG9jcy9hcGkvc3RydWN0dXJlcy9pcGMtcmVuZGVyZXItZXZlbnRcblxuXHQvLyBOb3RlOiBBUEkgd2l0aCBgVHJhbnNmZXJhYmxlYCBpbnRlbnRpb25hbGx5IGNvbW1lbnRlZCBvdXQgYmVjYXVzZSB5b3Vcblx0Ly8gY2Fubm90IHRyYW5zZmVyIHRoZXNlIHdoZW4gYGNvbnRleHRJc29sYXRpb246IHRydWVgLlxuXHQvLyAvKipcblx0Ly8gICogQSBsaXN0IG9mIE1lc3NhZ2VQb3J0cyB0aGF0IHdlcmUgdHJhbnNmZXJyZWQgd2l0aCB0aGlzIG1lc3NhZ2Vcblx0Ly8gICovXG5cdC8vIHBvcnRzOiBNZXNzYWdlUG9ydFtdO1xuXHQvKipcblx0ICogVGhlIGBJcGNSZW5kZXJlcmAgaW5zdGFuY2UgdGhhdCBlbWl0dGVkIHRoZSBldmVudCBvcmlnaW5hbGx5XG5cdCAqL1xuXHRzZW5kZXI6IElwY1JlbmRlcmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElwY1JlbmRlcmVyIHtcblxuXHQvLyBEb2NzOiBodHRwczovL2VsZWN0cm9uanMub3JnL2RvY3MvYXBpL2lwYy1yZW5kZXJlclxuXG5cdC8qKlxuXHQgKiBSZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBmcm9tIHRoZSBtYWluIHByb2Nlc3MuXG5cdCAqXG5cdCAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBtYWluIHByb2Nlc3MgdmlhIGBjaGFubmVsYCBhbmQgZXhwZWN0IGEgcmVzdWx0XG5cdCAqIGFzeW5jaHJvbm91c2x5LiBBcmd1bWVudHMgd2lsbCBiZSBzZXJpYWxpemVkIHdpdGggdGhlIFN0cnVjdHVyZWQgQ2xvbmVcblx0ICogQWxnb3JpdGhtLCBqdXN0IGxpa2UgYHdpbmRvdy5wb3N0TWVzc2FnZWAsIHNvIHByb3RvdHlwZSBjaGFpbnMgd2lsbCBub3QgYmVcblx0ICogaW5jbHVkZWQuIFNlbmRpbmcgRnVuY3Rpb25zLCBQcm9taXNlcywgU3ltYm9scywgV2Vha01hcHMsIG9yIFdlYWtTZXRzIHdpbGwgdGhyb3dcblx0ICogYW4gZXhjZXB0aW9uLlxuXHQgKlxuXHQgKiBUaGUgbWFpbiBwcm9jZXNzIHNob3VsZCBsaXN0ZW4gZm9yIGBjaGFubmVsYCB3aXRoIGBpcGNNYWluLmhhbmRsZSgpYC5cblx0ICpcblx0ICogRm9yIGV4YW1wbGU6XG5cdCAqXG5cdCAqIElmIHlvdSBuZWVkIHRvIHRyYW5zZmVyIGEgYE1lc3NhZ2VQb3J0YCB0byB0aGUgbWFpbiBwcm9jZXNzLCB1c2Vcblx0ICogYGlwY1JlbmRlcmVyLnBvc3RNZXNzYWdlYC5cblx0ICpcblx0ICogSWYgeW91IGRvIG5vdCBuZWVkIGEgcmVzcG9uc2UgdG8gdGhlIG1lc3NhZ2UsIGNvbnNpZGVyIHVzaW5nIGBpcGNSZW5kZXJlci5zZW5kYC5cblx0ICpcblx0ICogPiAqKk5vdGUqKiBTZW5kaW5nIG5vbi1zdGFuZGFyZCBKYXZhU2NyaXB0IHR5cGVzIHN1Y2ggYXMgRE9NIG9iamVjdHMgb3Igc3BlY2lhbFxuXHQgKiBFbGVjdHJvbiBvYmplY3RzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuXHQgKlxuXHQgKiBTaW5jZSB0aGUgbWFpbiBwcm9jZXNzIGRvZXMgbm90IGhhdmUgc3VwcG9ydCBmb3IgRE9NIG9iamVjdHMgc3VjaCBhc1xuXHQgKiBgSW1hZ2VCaXRtYXBgLCBgRmlsZWAsIGBET01NYXRyaXhgIGFuZCBzbyBvbiwgc3VjaCBvYmplY3RzIGNhbm5vdCBiZSBzZW50IG92ZXJcblx0ICogRWxlY3Ryb24ncyBJUEMgdG8gdGhlIG1haW4gcHJvY2VzcywgYXMgdGhlIG1haW4gcHJvY2VzcyB3b3VsZCBoYXZlIG5vIHdheSB0b1xuXHQgKiBkZWNvZGUgdGhlbS4gQXR0ZW1wdGluZyB0byBzZW5kIHN1Y2ggb2JqZWN0cyBvdmVyIElQQyB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvci5cblx0ICpcblx0ICogPiAqKk5vdGUqKiBJZiB0aGUgaGFuZGxlciBpbiB0aGUgbWFpbiBwcm9jZXNzIHRocm93cyBhbiBlcnJvciwgdGhlIHByb21pc2Vcblx0ICogcmV0dXJuZWQgYnkgYGludm9rZWAgd2lsbCByZWplY3QuIEhvd2V2ZXIsIHRoZSBgRXJyb3JgIG9iamVjdCBpbiB0aGUgcmVuZGVyZXJcblx0ICogcHJvY2VzcyB3aWxsIG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgb25lIHRocm93biBpbiB0aGUgbWFpbiBwcm9jZXNzLlxuXHQgKi9cblx0aW52b2tlKGNoYW5uZWw6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKTogUHJvbWlzZTx1bmtub3duPjtcblx0LyoqXG5cdCAqIExpc3RlbnMgdG8gYGNoYW5uZWxgLCB3aGVuIGEgbmV3IG1lc3NhZ2UgYXJyaXZlcyBgbGlzdGVuZXJgIHdvdWxkIGJlIGNhbGxlZCB3aXRoXG5cdCAqIGBsaXN0ZW5lcihldmVudCwgYXJncy4uLilgLlxuXHQgKi9cblx0b24oY2hhbm5lbDogc3RyaW5nLCBsaXN0ZW5lcjogKGV2ZW50OiBJcGNSZW5kZXJlckV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWQpOiB0aGlzO1xuXHQvKipcblx0ICogQWRkcyBhIG9uZSB0aW1lIGBsaXN0ZW5lcmAgZnVuY3Rpb24gZm9yIHRoZSBldmVudC4gVGhpcyBgbGlzdGVuZXJgIGlzIGludm9rZWRcblx0ICogb25seSB0aGUgbmV4dCB0aW1lIGEgbWVzc2FnZSBpcyBzZW50IHRvIGBjaGFubmVsYCwgYWZ0ZXIgd2hpY2ggaXQgaXMgcmVtb3ZlZC5cblx0ICovXG5cdG9uY2UoY2hhbm5lbDogc3RyaW5nLCBsaXN0ZW5lcjogKGV2ZW50OiBJcGNSZW5kZXJlckV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWQpOiB0aGlzO1xuXHQvLyBOb3RlOiBBUEkgd2l0aCBgVHJhbnNmZXJhYmxlYCBpbnRlbnRpb25hbGx5IGNvbW1lbnRlZCBvdXQgYmVjYXVzZSB5b3Vcblx0Ly8gY2Fubm90IHRyYW5zZmVyIHRoZXNlIHdoZW4gYGNvbnRleHRJc29sYXRpb246IHRydWVgLlxuXHQvLyAvKipcblx0Ly8gICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIG1haW4gcHJvY2Vzcywgb3B0aW9uYWxseSB0cmFuc2ZlcnJpbmcgb3duZXJzaGlwIG9mIHplcm8gb3Jcblx0Ly8gICogbW9yZSBgTWVzc2FnZVBvcnRgIG9iamVjdHMuXG5cdC8vICAqXG5cdC8vICAqIFRoZSB0cmFuc2ZlcnJlZCBgTWVzc2FnZVBvcnRgIG9iamVjdHMgd2lsbCBiZSBhdmFpbGFibGUgaW4gdGhlIG1haW4gcHJvY2VzcyBhc1xuXHQvLyAgKiBgTWVzc2FnZVBvcnRNYWluYCBvYmplY3RzIGJ5IGFjY2Vzc2luZyB0aGUgYHBvcnRzYCBwcm9wZXJ0eSBvZiB0aGUgZW1pdHRlZFxuXHQvLyAgKiBldmVudC5cblx0Ly8gICpcblx0Ly8gICogRm9yIGV4YW1wbGU6XG5cdC8vICAqXG5cdC8vICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHVzaW5nIGBNZXNzYWdlUG9ydGAgYW5kIGBNZXNzYWdlQ2hhbm5lbGAsIHNlZSB0aGUgTUROXG5cdC8vICAqIGRvY3VtZW50YXRpb24uXG5cdC8vICAqL1xuXHQvLyBwb3N0TWVzc2FnZShjaGFubmVsOiBzdHJpbmcsIG1lc3NhZ2U6IHVua25vd24sIHRyYW5zZmVyPzogTWVzc2FnZVBvcnRbXSk6IHZvaWQ7XG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgYGxpc3RlbmVyYCBmcm9tIHRoZSBsaXN0ZW5lciBhcnJheSBmb3IgdGhlIHNwZWNpZmllZFxuXHQgKiBgY2hhbm5lbGAuXG5cdCAqL1xuXHRyZW1vdmVMaXN0ZW5lcihjaGFubmVsOiBzdHJpbmcsIGxpc3RlbmVyOiAoZXZlbnQ6IElwY1JlbmRlcmVyRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZCk6IHRoaXM7XG5cdC8qKlxuXHQgKiBTZW5kIGFuIGFzeW5jaHJvbm91cyBtZXNzYWdlIHRvIHRoZSBtYWluIHByb2Nlc3MgdmlhIGBjaGFubmVsYCwgYWxvbmcgd2l0aFxuXHQgKiBhcmd1bWVudHMuIEFyZ3VtZW50cyB3aWxsIGJlIHNlcmlhbGl6ZWQgd2l0aCB0aGUgU3RydWN0dXJlZCBDbG9uZSBBbGdvcml0aG0sXG5cdCAqIGp1c3QgbGlrZSBgd2luZG93LnBvc3RNZXNzYWdlYCwgc28gcHJvdG90eXBlIGNoYWlucyB3aWxsIG5vdCBiZSBpbmNsdWRlZC5cblx0ICogU2VuZGluZyBGdW5jdGlvbnMsIFByb21pc2VzLCBTeW1ib2xzLCBXZWFrTWFwcywgb3IgV2Vha1NldHMgd2lsbCB0aHJvdyBhblxuXHQgKiBleGNlcHRpb24uXG5cdCAqXG5cdCAqID4gKipOT1RFOioqIFNlbmRpbmcgbm9uLXN0YW5kYXJkIEphdmFTY3JpcHQgdHlwZXMgc3VjaCBhcyBET00gb2JqZWN0cyBvciBzcGVjaWFsXG5cdCAqIEVsZWN0cm9uIG9iamVjdHMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG5cdCAqXG5cdCAqIFNpbmNlIHRoZSBtYWluIHByb2Nlc3MgZG9lcyBub3QgaGF2ZSBzdXBwb3J0IGZvciBET00gb2JqZWN0cyBzdWNoIGFzXG5cdCAqIGBJbWFnZUJpdG1hcGAsIGBGaWxlYCwgYERPTU1hdHJpeGAgYW5kIHNvIG9uLCBzdWNoIG9iamVjdHMgY2Fubm90IGJlIHNlbnQgb3ZlclxuXHQgKiBFbGVjdHJvbidzIElQQyB0byB0aGUgbWFpbiBwcm9jZXNzLCBhcyB0aGUgbWFpbiBwcm9jZXNzIHdvdWxkIGhhdmUgbm8gd2F5IHRvXG5cdCAqIGRlY29kZSB0aGVtLiBBdHRlbXB0aW5nIHRvIHNlbmQgc3VjaCBvYmplY3RzIG92ZXIgSVBDIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yLlxuXHQgKlxuXHQgKiBUaGUgbWFpbiBwcm9jZXNzIGhhbmRsZXMgaXQgYnkgbGlzdGVuaW5nIGZvciBgY2hhbm5lbGAgd2l0aCB0aGUgYGlwY01haW5gXG5cdCAqIG1vZHVsZS5cblx0ICpcblx0ICogSWYgeW91IG5lZWQgdG8gdHJhbnNmZXIgYSBgTWVzc2FnZVBvcnRgIHRvIHRoZSBtYWluIHByb2Nlc3MsIHVzZVxuXHQgKiBgaXBjUmVuZGVyZXIucG9zdE1lc3NhZ2VgLlxuXHQgKlxuXHQgKiBJZiB5b3Ugd2FudCB0byByZWNlaXZlIGEgc2luZ2xlIHJlc3BvbnNlIGZyb20gdGhlIG1haW4gcHJvY2VzcywgbGlrZSB0aGUgcmVzdWx0XG5cdCAqIG9mIGEgbWV0aG9kIGNhbGwsIGNvbnNpZGVyIHVzaW5nIGBpcGNSZW5kZXJlci5pbnZva2VgLlxuXHQgKi9cblx0c2VuZChjaGFubmVsOiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2ViRnJhbWUge1xuXHQvKipcblx0ICogQ2hhbmdlcyB0aGUgem9vbSBsZXZlbCB0byB0aGUgc3BlY2lmaWVkIGxldmVsLiBUaGUgb3JpZ2luYWwgc2l6ZSBpcyAwIGFuZCBlYWNoXG5cdCAqIGluY3JlbWVudCBhYm92ZSBvciBiZWxvdyByZXByZXNlbnRzIHpvb21pbmcgMjAlIGxhcmdlciBvciBzbWFsbGVyIHRvIGRlZmF1bHRcblx0ICogbGltaXRzIG9mIDMwMCUgYW5kIDUwJSBvZiBvcmlnaW5hbCBzaXplLCByZXNwZWN0aXZlbHkuIFRoZSBmb3JtdWxhIGZvciB0aGlzIGlzXG5cdCAqIGBzY2FsZSA6PSAxLjIgXiBsZXZlbGAuXG5cdCAqXG5cdCAqID4gKipOT1RFKio6IFRoZSB6b29tIHBvbGljeSBhdCB0aGUgQ2hyb21pdW0gbGV2ZWwgaXMgc2FtZS1vcmlnaW4sIG1lYW5pbmcgdGhhdFxuXHQgKiB0aGUgem9vbSBsZXZlbCBmb3IgYSBzcGVjaWZpYyBkb21haW4gcHJvcGFnYXRlcyBhY3Jvc3MgYWxsIGluc3RhbmNlcyBvZiB3aW5kb3dzXG5cdCAqIHdpdGggdGhlIHNhbWUgZG9tYWluLiBEaWZmZXJlbnRpYXRpbmcgdGhlIHdpbmRvdyBVUkxzIHdpbGwgbWFrZSB6b29tIHdvcmtcblx0ICogcGVyLXdpbmRvdy5cblx0ICovXG5cdHNldFpvb21MZXZlbChsZXZlbDogbnVtYmVyKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzTWVtb3J5SW5mbyB7XG5cblx0Ly8gRG9jczogaHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy9kb2NzL2FwaS9zdHJ1Y3R1cmVzL3Byb2Nlc3MtbWVtb3J5LWluZm9cblxuXHQvKipcblx0ICogVGhlIGFtb3VudCBvZiBtZW1vcnkgbm90IHNoYXJlZCBieSBvdGhlciBwcm9jZXNzZXMsIHN1Y2ggYXMgSlMgaGVhcCBvciBIVE1MXG5cdCAqIGNvbnRlbnQgaW4gS2lsb2J5dGVzLlxuXHQgKi9cblx0cHJpdmF0ZTogbnVtYmVyO1xuXHQvKipcblx0ICogVGhlIGFtb3VudCBvZiBtZW1vcnkgY3VycmVudGx5IHBpbm5lZCB0byBhY3R1YWwgcGh5c2ljYWwgUkFNIGluIEtpbG9ieXRlcy5cblx0ICpcblx0ICogQHBsYXRmb3JtIGxpbnV4LHdpbjMyXG5cdCAqL1xuXHRyZXNpZGVudFNldDogbnVtYmVyO1xuXHQvKipcblx0ICogVGhlIGFtb3VudCBvZiBtZW1vcnkgc2hhcmVkIGJldHdlZW4gcHJvY2Vzc2VzLCB0eXBpY2FsbHkgbWVtb3J5IGNvbnN1bWVkIGJ5IHRoZVxuXHQgKiBFbGVjdHJvbiBjb2RlIGl0c2VsZiBpbiBLaWxvYnl0ZXMuXG5cdCAqL1xuXHRzaGFyZWQ6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFyb3VuZCBhIGBhcHAub24oJ2xvZ2luJylgIGV2ZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhJbmZvIHtcblx0aXNQcm94eTogYm9vbGVhbjtcblx0c2NoZW1lOiBzdHJpbmc7XG5cdGhvc3Q6IHN0cmluZztcblx0cG9ydDogbnVtYmVyO1xuXHRyZWFsbTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYlV0aWxzIHtcblxuXHQvLyBEb2NzOiBodHRwczovL2VsZWN0cm9uanMub3JnL2RvY3MvYXBpL3dlYi11dGlsc1xuXG5cdC8qKlxuXHQgKiBUaGUgZmlsZSBzeXN0ZW0gcGF0aCB0aGF0IHRoaXMgYEZpbGVgIG9iamVjdCBwb2ludHMgdG8uIEluIHRoZSBjYXNlIHdoZXJlIHRoZVxuXHQgKiBvYmplY3QgcGFzc2VkIGluIGlzIG5vdCBhIGBGaWxlYCBvYmplY3QgYW4gZXhjZXB0aW9uIGlzIHRocm93bi4gSW4gdGhlIGNhc2Vcblx0ICogd2hlcmUgdGhlIEZpbGUgb2JqZWN0IHBhc3NlZCBpbiB3YXMgY29uc3RydWN0ZWQgaW4gSlMgYW5kIGlzIG5vdCBiYWNrZWQgYnkgYVxuXHQgKiBmaWxlIG9uIGRpc2sgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBzdXBlcmNlZGVkIHRoZSBwcmV2aW91cyBhdWdtZW50YXRpb24gdG8gdGhlIGBGaWxlYCBvYmplY3Qgd2l0aCB0aGVcblx0ICogYHBhdGhgIHByb3BlcnR5LiAgQW4gZXhhbXBsZSBpcyBpbmNsdWRlZCBiZWxvdy5cblx0ICovXG5cdGdldFBhdGhGb3JGaWxlKGZpbGU6IEZpbGUpOiBzdHJpbmc7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBIiwiaWdub3JlTGlzdCI6W119
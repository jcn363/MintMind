{"version":3,"names":["cov_n7t6bw3kl","actualCoverage","URI","nls","RawContextKey","createDecorator","VIEWLET_ID","s","VARIABLES_VIEW_ID","WATCH_VIEW_ID","CALLSTACK_VIEW_ID","LOADED_SCRIPTS_VIEW_ID","BREAKPOINTS_VIEW_ID","DISASSEMBLY_VIEW_ID","DEBUG_PANEL_ID","REPL_VIEW_ID","CONTEXT_DEBUG_TYPE","undefined","type","description","localize","CONTEXT_DEBUG_CONFIGURATION_TYPE","CONTEXT_DEBUG_STATE","CONTEXT_DEBUG_UX_KEY","CONTEXT_DEBUG_UX","CONTEXT_HAS_DEBUGGED","CONTEXT_IN_DEBUG_MODE","CONTEXT_IN_DEBUG_REPL","CONTEXT_BREAKPOINT_WIDGET_VISIBLE","CONTEXT_IN_BREAKPOINT_WIDGET","CONTEXT_BREAKPOINTS_FOCUSED","CONTEXT_WATCH_EXPRESSIONS_FOCUSED","CONTEXT_WATCH_EXPRESSIONS_EXIST","CONTEXT_VARIABLES_FOCUSED","CONTEXT_EXPRESSION_SELECTED","CONTEXT_BREAKPOINT_INPUT_FOCUSED","CONTEXT_CALLSTACK_ITEM_TYPE","CONTEXT_CALLSTACK_SESSION_IS_ATTACH","CONTEXT_CALLSTACK_ITEM_STOPPED","CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD","CONTEXT_CALLSTACK_FOCUSED","CONTEXT_WATCH_ITEM_TYPE","CONTEXT_CAN_VIEW_MEMORY","CONTEXT_BREAKPOINT_ITEM_TYPE","CONTEXT_BREAKPOINT_ITEM_IS_DATA_BYTES","CONTEXT_BREAKPOINT_HAS_MODES","CONTEXT_BREAKPOINT_SUPPORTS_CONDITION","CONTEXT_LOADED_SCRIPTS_SUPPORTED","CONTEXT_LOADED_SCRIPTS_ITEM_TYPE","CONTEXT_FOCUSED_SESSION_IS_ATTACH","CONTEXT_FOCUSED_SESSION_IS_NO_DEBUG","CONTEXT_STEP_BACK_SUPPORTED","CONTEXT_RESTART_FRAME_SUPPORTED","CONTEXT_STACK_FRAME_SUPPORTS_RESTART","CONTEXT_JUMP_TO_CURSOR_SUPPORTED","CONTEXT_STEP_INTO_TARGETS_SUPPORTED","CONTEXT_BREAKPOINTS_EXIST","CONTEXT_DEBUGGERS_AVAILABLE","CONTEXT_DEBUG_EXTENSION_AVAILABLE","CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT","CONTEXT_SET_VARIABLE_SUPPORTED","CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED","CONTEXT_SET_EXPRESSION_SUPPORTED","CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED","CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED","CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED","CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED","CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED","CONTEXT_TERMINATE_THREADS_SUPPORTED","CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT","CONTEXT_VARIABLE_IS_READONLY","CONTEXT_VARIABLE_VALUE","CONTEXT_VARIABLE_TYPE","CONTEXT_VARIABLE_INTERFACES","CONTEXT_VARIABLE_NAME","CONTEXT_VARIABLE_LANGUAGE","CONTEXT_VARIABLE_EXTENSIONID","CONTEXT_EXCEPTION_WIDGET_VISIBLE","CONTEXT_MULTI_SESSION_REPL","CONTEXT_MULTI_SESSION_DEBUG","CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED","CONTEXT_DISASSEMBLY_VIEW_FOCUS","CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST","CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE","debuggerDisabledMessage","debugType","f","EDITOR_CONTRIBUTION_ID","BREAKPOINT_EDITOR_CONTRIBUTION_ID","DEBUG_SCHEME","INTERNAL_CONSOLE_OPTIONS_SCHEMA","enum","default","getStateLabel","state","b","DEBUG_MEMORY_SCHEME","isFrameDeemphasized","frame","hint","presentationHint","source","DebugConfigurationProviderTriggerKind","DebuggerString","IDebugService","IDebugVisualizationTreeItem","deserialize","v","serialize","item","IDebugVisualization","id","name","iconPath","light","revive","dark","iconClass","visualization","visualizer"],"sources":["/home/user/Desktop/MintMind/src/vs/workbench/contrib/debug/common/debug.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IAction } from '../../../../base/common/actions.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { IJSONSchema, IJSONSchemaSnippet } from '../../../../base/common/jsonSchema.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport severity from '../../../../base/common/severity.js';\nimport { URI, UriComponents, URI as uri } from '../../../../base/common/uri.js';\nimport { IPosition, Position } from '../../../../editor/common/core/position.js';\nimport { IRange } from '../../../../editor/common/core/range.js';\nimport * as editorCommon from '../../../../editor/common/editorCommon.js';\nimport { ITextModel as EditorIModel } from '../../../../editor/common/model.js';\nimport * as nls from '../../../../nls.js';\nimport { ConfigurationTarget } from '../../../../platform/configuration/common/configuration.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITelemetryEndpoint } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { IEditorPane } from '../../../common/editor.js';\nimport { DebugCompoundRoot } from './debugCompoundRoot.js';\nimport { IDataBreakpointOptions, IFunctionBreakpointOptions, IInstructionBreakpointOptions } from './debugModel.js';\nimport { Source } from './debugSource.js';\nimport { ITaskIdentifier } from '../../tasks/common/tasks.js';\nimport { LiveTestResult } from '../../testing/common/testResult.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IView } from '../../../common/views.js';\n\nexport const VIEWLET_ID = 'workbench.view.debug';\n\nexport const VARIABLES_VIEW_ID = 'workbench.debug.variablesView';\nexport const WATCH_VIEW_ID = 'workbench.debug.watchExpressionsView';\nexport const CALLSTACK_VIEW_ID = 'workbench.debug.callStackView';\nexport const LOADED_SCRIPTS_VIEW_ID = 'workbench.debug.loadedScriptsView';\nexport const BREAKPOINTS_VIEW_ID = 'workbench.debug.breakPointsView';\nexport const DISASSEMBLY_VIEW_ID = 'workbench.debug.disassemblyView';\nexport const DEBUG_PANEL_ID = 'workbench.panel.repl';\nexport const REPL_VIEW_ID = 'workbench.panel.repl.view';\nexport const CONTEXT_DEBUG_TYPE = new RawContextKey<string>('debugType', undefined, { type: 'string', description: nls.localize('debugType', \"Debug type of the active debug session. For example 'python'.\") });\nexport const CONTEXT_DEBUG_CONFIGURATION_TYPE = new RawContextKey<string>('debugConfigurationType', undefined, { type: 'string', description: nls.localize('debugConfigurationType', \"Debug type of the selected launch configuration. For example 'python'.\") });\nexport const CONTEXT_DEBUG_STATE = new RawContextKey<string>('debugState', 'inactive', { type: 'string', description: nls.localize('debugState', \"State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'.\") });\nexport const CONTEXT_DEBUG_UX_KEY = 'debugUx';\nexport const CONTEXT_DEBUG_UX = new RawContextKey<string>(CONTEXT_DEBUG_UX_KEY, 'default', { type: 'string', description: nls.localize('debugUX', \"Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet.\") });\nexport const CONTEXT_HAS_DEBUGGED = new RawContextKey<boolean>('hasDebugged', false, { type: 'boolean', description: nls.localize('hasDebugged', \"True when a debug session has been started at least once, false otherwise.\") });\nexport const CONTEXT_IN_DEBUG_MODE = new RawContextKey<boolean>('inDebugMode', false, { type: 'boolean', description: nls.localize('inDebugMode', \"True when debugging, false otherwise.\") });\nexport const CONTEXT_IN_DEBUG_REPL = new RawContextKey<boolean>('inDebugRepl', false, { type: 'boolean', description: nls.localize('inDebugRepl', \"True when focus is in the debug console, false otherwise.\") });\nexport const CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new RawContextKey<boolean>('breakpointWidgetVisible', false, { type: 'boolean', description: nls.localize('breakpointWidgetVisibile', \"True when breakpoint editor zone widget is visible, false otherwise.\") });\nexport const CONTEXT_IN_BREAKPOINT_WIDGET = new RawContextKey<boolean>('inBreakpointWidget', false, { type: 'boolean', description: nls.localize('inBreakpointWidget', \"True when focus is in the breakpoint editor zone widget, false otherwise.\") });\nexport const CONTEXT_BREAKPOINTS_FOCUSED = new RawContextKey<boolean>('breakpointsFocused', true, { type: 'boolean', description: nls.localize('breakpointsFocused', \"True when the BREAKPOINTS view is focused, false otherwise.\") });\nexport const CONTEXT_WATCH_EXPRESSIONS_FOCUSED = new RawContextKey<boolean>('watchExpressionsFocused', true, { type: 'boolean', description: nls.localize('watchExpressionsFocused', \"True when the WATCH view is focused, false otherwise.\") });\nexport const CONTEXT_WATCH_EXPRESSIONS_EXIST = new RawContextKey<boolean>('watchExpressionsExist', false, { type: 'boolean', description: nls.localize('watchExpressionsExist', \"True when at least one watch expression exists, false otherwise.\") });\nexport const CONTEXT_VARIABLES_FOCUSED = new RawContextKey<boolean>('variablesFocused', true, { type: 'boolean', description: nls.localize('variablesFocused', \"True when the VARIABLES views is focused, false otherwise\") });\nexport const CONTEXT_EXPRESSION_SELECTED = new RawContextKey<boolean>('expressionSelected', false, { type: 'boolean', description: nls.localize('expressionSelected', \"True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise.\") });\nexport const CONTEXT_BREAKPOINT_INPUT_FOCUSED = new RawContextKey<boolean>('breakpointInputFocused', false, { type: 'boolean', description: nls.localize('breakpointInputFocused', \"True when the input box has focus in the BREAKPOINTS view.\") });\nexport const CONTEXT_CALLSTACK_ITEM_TYPE = new RawContextKey<string>('callStackItemType', undefined, { type: 'string', description: nls.localize('callStackItemType', \"Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'\") });\nexport const CONTEXT_CALLSTACK_SESSION_IS_ATTACH = new RawContextKey<boolean>('callStackSessionIsAttach', false, { type: 'boolean', description: nls.localize('callStackSessionIsAttach', \"True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_CALLSTACK_ITEM_STOPPED = new RawContextKey<boolean>('callStackItemStopped', false, { type: 'boolean', description: nls.localize('callStackItemStopped', \"True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD = new RawContextKey<boolean>('callStackSessionHasOneThread', false, { type: 'boolean', description: nls.localize('callStackSessionHasOneThread', \"True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_CALLSTACK_FOCUSED = new RawContextKey<boolean>('callStackFocused', true, { type: 'boolean', description: nls.localize('callStackFocused', \"True when the CALLSTACK view is focused, false otherwise.\") });\nexport const CONTEXT_WATCH_ITEM_TYPE = new RawContextKey<string>('watchItemType', undefined, { type: 'string', description: nls.localize('watchItemType', \"Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'\") });\nexport const CONTEXT_CAN_VIEW_MEMORY = new RawContextKey<boolean>('canViewMemory', undefined, { type: 'boolean', description: nls.localize('canViewMemory', \"Indicates whether the item in the view has an associated memory refrence.\") });\nexport const CONTEXT_BREAKPOINT_ITEM_TYPE = new RawContextKey<string>('breakpointItemType', undefined, { type: 'string', description: nls.localize('breakpointItemType', \"Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'\") });\nexport const CONTEXT_BREAKPOINT_ITEM_IS_DATA_BYTES = new RawContextKey<boolean>('breakpointItemBytes', undefined, { type: 'boolean', description: nls.localize('breakpointItemIsDataBytes', \"Whether the breakpoint item is a data breakpoint on a byte range.\") });\nexport const CONTEXT_BREAKPOINT_HAS_MODES = new RawContextKey<boolean>('breakpointHasModes', false, { type: 'boolean', description: nls.localize('breakpointHasModes', \"Whether the breakpoint has multiple modes it can switch to.\") });\nexport const CONTEXT_BREAKPOINT_SUPPORTS_CONDITION = new RawContextKey<boolean>('breakpointSupportsCondition', false, { type: 'boolean', description: nls.localize('breakpointSupportsCondition', \"True when the focused breakpoint supports conditions.\") });\nexport const CONTEXT_LOADED_SCRIPTS_SUPPORTED = new RawContextKey<boolean>('loadedScriptsSupported', false, { type: 'boolean', description: nls.localize('loadedScriptsSupported', \"True when the focused sessions supports the LOADED SCRIPTS view\") });\nexport const CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = new RawContextKey<string>('loadedScriptsItemType', undefined, { type: 'string', description: nls.localize('loadedScriptsItemType', \"Represents the item type of the focused element in the LOADED SCRIPTS view.\") });\nexport const CONTEXT_FOCUSED_SESSION_IS_ATTACH = new RawContextKey<boolean>('focusedSessionIsAttach', false, { type: 'boolean', description: nls.localize('focusedSessionIsAttach', \"True when the focused session is 'attach'.\") });\nexport const CONTEXT_FOCUSED_SESSION_IS_NO_DEBUG = new RawContextKey<boolean>('focusedSessionIsNoDebug', false, { type: 'boolean', description: nls.localize('focusedSessionIsNoDebug', \"True when the focused session is run without debugging.\") });\nexport const CONTEXT_STEP_BACK_SUPPORTED = new RawContextKey<boolean>('stepBackSupported', false, { type: 'boolean', description: nls.localize('stepBackSupported', \"True when the focused session supports 'stepBack' requests.\") });\nexport const CONTEXT_RESTART_FRAME_SUPPORTED = new RawContextKey<boolean>('restartFrameSupported', false, { type: 'boolean', description: nls.localize('restartFrameSupported', \"True when the focused session supports 'restartFrame' requests.\") });\nexport const CONTEXT_STACK_FRAME_SUPPORTS_RESTART = new RawContextKey<boolean>('stackFrameSupportsRestart', false, { type: 'boolean', description: nls.localize('stackFrameSupportsRestart', \"True when the focused stack frame supports 'restartFrame'.\") });\nexport const CONTEXT_JUMP_TO_CURSOR_SUPPORTED = new RawContextKey<boolean>('jumpToCursorSupported', false, { type: 'boolean', description: nls.localize('jumpToCursorSupported', \"True when the focused session supports 'jumpToCursor' request.\") });\nexport const CONTEXT_STEP_INTO_TARGETS_SUPPORTED = new RawContextKey<boolean>('stepIntoTargetsSupported', false, { type: 'boolean', description: nls.localize('stepIntoTargetsSupported', \"True when the focused session supports 'stepIntoTargets' request.\") });\nexport const CONTEXT_BREAKPOINTS_EXIST = new RawContextKey<boolean>('breakpointsExist', false, { type: 'boolean', description: nls.localize('breakpointsExist', \"True when at least one breakpoint exists.\") });\nexport const CONTEXT_DEBUGGERS_AVAILABLE = new RawContextKey<boolean>('debuggersAvailable', false, { type: 'boolean', description: nls.localize('debuggersAvailable', \"True when there is at least one debug extensions active.\") });\nexport const CONTEXT_DEBUG_EXTENSION_AVAILABLE = new RawContextKey<boolean>('debugExtensionAvailable', true, { type: 'boolean', description: nls.localize('debugExtensionsAvailable', \"True when there is at least one debug extension installed and enabled.\") });\nexport const CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT = new RawContextKey<string>('debugProtocolVariableMenuContext', undefined, { type: 'string', description: nls.localize('debugProtocolVariableMenuContext', \"Represents the context the debug adapter sets on the focused variable in the VARIABLES view.\") });\nexport const CONTEXT_SET_VARIABLE_SUPPORTED = new RawContextKey<boolean>('debugSetVariableSupported', false, { type: 'boolean', description: nls.localize('debugSetVariableSupported', \"True when the focused session supports 'setVariable' request.\") });\nexport const CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED = new RawContextKey<boolean>('debugSetDataBreakpointAddressSupported', false, { type: 'boolean', description: nls.localize('debugSetDataBreakpointAddressSupported', \"True when the focused session supports 'getBreakpointInfo' request on an address.\") });\nexport const CONTEXT_SET_EXPRESSION_SUPPORTED = new RawContextKey<boolean>('debugSetExpressionSupported', false, { type: 'boolean', description: nls.localize('debugSetExpressionSupported', \"True when the focused session supports 'setExpression' request.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED = new RawContextKey<boolean>('breakWhenValueChangesSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueChangesSupported', \"True when the focused session supports to break when value changes.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED = new RawContextKey<boolean>('breakWhenValueIsAccessedSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueIsAccessedSupported', \"True when the focused breakpoint supports to break when value is accessed.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED = new RawContextKey<boolean>('breakWhenValueIsReadSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueIsReadSupported', \"True when the focused breakpoint supports to break when value is read.\") });\nexport const CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED = new RawContextKey<boolean>('terminateDebuggeeSupported', false, { type: 'boolean', description: nls.localize('terminateDebuggeeSupported', \"True when the focused session supports the terminate debuggee capability.\") });\nexport const CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED = new RawContextKey<boolean>('suspendDebuggeeSupported', false, { type: 'boolean', description: nls.localize('suspendDebuggeeSupported', \"True when the focused session supports the suspend debuggee capability.\") });\nexport const CONTEXT_TERMINATE_THREADS_SUPPORTED = new RawContextKey<boolean>('terminateThreadsSupported', false, { type: 'boolean', description: nls.localize('terminateThreadsSupported', \"True when the focused session supports the terminate threads capability.\") });\nexport const CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT = new RawContextKey<boolean>('variableEvaluateNamePresent', false, { type: 'boolean', description: nls.localize('variableEvaluateNamePresent', \"True when the focused variable has an 'evalauteName' field set.\") });\nexport const CONTEXT_VARIABLE_IS_READONLY = new RawContextKey<boolean>('variableIsReadonly', false, { type: 'boolean', description: nls.localize('variableIsReadonly', \"True when the focused variable is read-only.\") });\nexport const CONTEXT_VARIABLE_VALUE = new RawContextKey<boolean>('variableValue', false, { type: 'string', description: nls.localize('variableValue', \"Value of the variable, present for debug visualization clauses.\") });\nexport const CONTEXT_VARIABLE_TYPE = new RawContextKey<boolean>('variableType', false, { type: 'string', description: nls.localize('variableType', \"Type of the variable, present for debug visualization clauses.\") });\nexport const CONTEXT_VARIABLE_INTERFACES = new RawContextKey<boolean>('variableInterfaces', false, { type: 'array', description: nls.localize('variableInterfaces', \"Any interfaces or contracts that the variable satisfies, present for debug visualization clauses.\") });\nexport const CONTEXT_VARIABLE_NAME = new RawContextKey<boolean>('variableName', false, { type: 'string', description: nls.localize('variableName', \"Name of the variable, present for debug visualization clauses.\") });\nexport const CONTEXT_VARIABLE_LANGUAGE = new RawContextKey<boolean>('variableLanguage', false, { type: 'string', description: nls.localize('variableLanguage', \"Language of the variable source, present for debug visualization clauses.\") });\nexport const CONTEXT_VARIABLE_EXTENSIONID = new RawContextKey<boolean>('variableExtensionId', false, { type: 'string', description: nls.localize('variableExtensionId', \"Extension ID of the variable source, present for debug visualization clauses.\") });\nexport const CONTEXT_EXCEPTION_WIDGET_VISIBLE = new RawContextKey<boolean>('exceptionWidgetVisible', false, { type: 'boolean', description: nls.localize('exceptionWidgetVisible', \"True when the exception widget is visible.\") });\nexport const CONTEXT_MULTI_SESSION_REPL = new RawContextKey<boolean>('multiSessionRepl', false, { type: 'boolean', description: nls.localize('multiSessionRepl', \"True when there is more than 1 debug console.\") });\nexport const CONTEXT_MULTI_SESSION_DEBUG = new RawContextKey<boolean>('multiSessionDebug', false, { type: 'boolean', description: nls.localize('multiSessionDebug', \"True when there is more than 1 active debug session.\") });\nexport const CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED = new RawContextKey<boolean>('disassembleRequestSupported', false, { type: 'boolean', description: nls.localize('disassembleRequestSupported', \"True when the focused sessions supports disassemble request.\") });\nexport const CONTEXT_DISASSEMBLY_VIEW_FOCUS = new RawContextKey<boolean>('disassemblyViewFocus', false, { type: 'boolean', description: nls.localize('disassemblyViewFocus', \"True when the Disassembly View is focused.\") });\nexport const CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST = new RawContextKey<boolean>('languageSupportsDisassembleRequest', false, { type: 'boolean', description: nls.localize('languageSupportsDisassembleRequest', \"True when the language in the current editor supports disassemble request.\") });\nexport const CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE = new RawContextKey<boolean>('focusedStackFrameHasInstructionReference', false, { type: 'boolean', description: nls.localize('focusedStackFrameHasInstructionReference', \"True when the focused stack frame has instruction pointer reference.\") });\n\nexport const debuggerDisabledMessage = (debugType: string) => nls.localize('debuggerDisabled', \"Configured debug type '{0}' is installed but not supported in this environment.\", debugType);\n\nexport const EDITOR_CONTRIBUTION_ID = 'editor.contrib.debug';\nexport const BREAKPOINT_EDITOR_CONTRIBUTION_ID = 'editor.contrib.breakpoint';\nexport const DEBUG_SCHEME = 'debug';\nexport const INTERNAL_CONSOLE_OPTIONS_SCHEMA = {\n\tenum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],\n\tdefault: 'openOnFirstSessionStart',\n\tdescription: nls.localize('internalConsoleOptions', \"Controls when the internal Debug Console should open.\")\n};\n\nexport interface IDebugViewWithVariables extends IView {\n\treadonly treeSelection: IExpression[];\n}\n\n// raw\n\nexport interface IRawModelUpdate {\n\tsessionId: string;\n\tthreads: DebugProtocol.Thread[];\n\tstoppedDetails?: IRawStoppedDetails;\n}\n\nexport interface IRawStoppedDetails {\n\treason?: string;\n\tdescription?: string;\n\tthreadId?: number;\n\ttext?: string;\n\ttotalFrames?: number;\n\tallThreadsStopped?: boolean;\n\tpreserveFocusHint?: boolean;\n\tframesErrorMessage?: string;\n\thitBreakpointIds?: number[];\n}\n\n// model\n\nexport interface ITreeElement {\n\tgetId(): string;\n}\n\nexport interface IReplElement extends ITreeElement {\n\ttoString(includeSource?: boolean): string;\n\treadonly sourceData?: IReplElementSource;\n}\n\nexport interface INestingReplElement extends IReplElement {\n\treadonly hasChildren: boolean;\n\tgetChildren(): Promise<IReplElement[]> | IReplElement[];\n}\n\nexport interface IReplElementSource {\n\treadonly source: Source;\n\treadonly lineNumber: number;\n\treadonly column: number;\n}\n\nexport interface IExpressionValue {\n\treadonly value: string;\n\treadonly type?: string;\n\tvalueChanged?: boolean;\n}\n\nexport interface IExpressionContainer extends ITreeElement, IExpressionValue {\n\treadonly hasChildren: boolean;\n\tgetSession(): IDebugSession | undefined;\n\tevaluateLazy(): Promise<void>;\n\tgetChildren(): Promise<IExpression[]>;\n\treadonly reference?: number;\n\treadonly memoryReference?: string;\n\treadonly presentationHint?: DebugProtocol.VariablePresentationHint | undefined;\n\treadonly valueLocationReference?: number;\n}\n\nexport interface IExpression extends IExpressionContainer {\n\tname: string;\n}\n\nexport interface IDebugger {\n\treadonly type: string;\n\tcreateDebugAdapter(session: IDebugSession): Promise<IDebugAdapter>;\n\trunInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n\tstartDebugging(args: IConfig, parentSessionId: string): Promise<boolean>;\n\tgetCustomTelemetryEndpoint(): ITelemetryEndpoint | undefined;\n\tgetInitialConfigurationContent(initialConfigs?: IConfig[]): Promise<string>;\n}\n\nexport interface IDebuggerMetadata {\n\tlabel: string;\n\ttype: string;\n\tstrings?: { [key in DebuggerString]: string };\n\tinterestedInLanguage(languageId: string): boolean;\n}\n\nexport const enum State {\n\tInactive,\n\tInitializing,\n\tStopped,\n\tRunning\n}\n\nexport function getStateLabel(state: State): string {\n\tswitch (state) {\n\t\tcase State.Initializing: return 'initializing';\n\t\tcase State.Stopped: return 'stopped';\n\t\tcase State.Running: return 'running';\n\t\tdefault: return 'inactive';\n\t}\n}\n\nexport interface AdapterEndEvent {\n\terror?: Error;\n\tsessionLengthInSeconds: number;\n\temittedStopped: boolean;\n}\n\nexport interface LoadedSourceEvent {\n\treason: 'new' | 'changed' | 'removed';\n\tsource: Source;\n}\n\nexport type IDebugSessionReplMode = 'separate' | 'mergeWithParent';\n\nexport interface IDebugTestRunReference {\n\trunId: string;\n\ttaskId: string;\n}\n\nexport interface IDebugSessionOptions {\n\tnoDebug?: boolean;\n\tparentSession?: IDebugSession;\n\tlifecycleManagedByParent?: boolean;\n\trepl?: IDebugSessionReplMode;\n\tcompoundRoot?: DebugCompoundRoot;\n\tcompact?: boolean;\n\tstartedByUser?: boolean;\n\tsaveBeforeRestart?: boolean;\n\tsuppressDebugToolbar?: boolean;\n\tsuppressDebugStatusbar?: boolean;\n\tsuppressDebugView?: boolean;\n\t/**\n\t * Set if the debug session is correlated with a test run. Stopping/restarting\n\t * the session will instead stop/restart the test run.\n\t */\n\ttestRun?: IDebugTestRunReference;\n}\n\nexport interface IDataBreakpointInfoResponse {\n\tdataId: string | null;\n\tdescription: string;\n\tcanPersist?: boolean;\n\taccessTypes?: DebugProtocol.DataBreakpointAccessType[];\n}\n\nexport interface IMemoryInvalidationEvent {\n\tfromOffset: number;\n\ttoOffset: number;\n}\n\nexport const enum MemoryRangeType {\n\tValid,\n\tUnreadable,\n\tError,\n}\n\nexport interface IMemoryRange {\n\ttype: MemoryRangeType;\n\toffset: number;\n\tlength: number;\n}\n\nexport interface IValidMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Valid;\n\toffset: number;\n\tlength: number;\n\tdata: VSBuffer;\n}\n\nexport interface IUnreadableMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Unreadable;\n}\n\nexport interface IErrorMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Error;\n\terror: string;\n}\n\n/**\n * Union type of memory that can be returned from read(). Since a read request\n * could encompass multiple previously-read ranges, multiple of these types\n * are possible to return.\n */\nexport type MemoryRange = IValidMemoryRange | IUnreadableMemoryRange | IErrorMemoryRange;\n\nexport const DEBUG_MEMORY_SCHEME = 'vscode-debug-memory';\n\n/**\n * An IMemoryRegion corresponds to a contiguous range of memory referred to\n * by a DAP `memoryReference`.\n */\nexport interface IMemoryRegion extends IDisposable {\n\t/**\n\t * Event that fires when memory changes. Can be a result of memory events or\n\t * `write` requests.\n\t */\n\treadonly onDidInvalidate: Event<IMemoryInvalidationEvent>;\n\n\t/**\n\t * Whether writes are supported on this memory region.\n\t */\n\treadonly writable: boolean;\n\n\t/**\n\t * Requests memory ranges from the debug adapter. It returns a list of memory\n\t * ranges that overlap (but may exceed!) the given offset. Use the `offset`\n\t * and `length` of each range for display.\n\t */\n\tread(fromOffset: number, toOffset: number): Promise<MemoryRange[]>;\n\n\t/**\n\t * Writes memory to the debug adapter at the given offset.\n\t */\n\twrite(offset: number, data: VSBuffer): Promise<number>;\n}\n\n/** Data that can be inserted in {@link IDebugSession.appendToRepl} */\nexport interface INewReplElementData {\n\t/**\n\t * Output string to display\n\t */\n\toutput: string;\n\n\t/**\n\t * Expression data to display. Will result in the item being expandable in\n\t * the REPL. Its value will be used if {@link output} is not provided.\n\t */\n\texpression?: IExpression;\n\n\t/**\n\t * Output severity.\n\t */\n\tsev: severity;\n\n\t/**\n\t * Originating location.\n\t */\n\tsource?: IReplElementSource;\n}\n\nexport interface IDebugEvaluatePosition {\n\tline: number;\n\tcolumn: number;\n\tsource: DebugProtocol.Source;\n}\n\nexport interface IDebugLocationReferenced {\n\tline: number;\n\tcolumn: number;\n\tendLine?: number;\n\tendColumn?: number;\n\tsource: Source;\n}\n\nexport interface IDebugSession extends ITreeElement, IDisposable {\n\n\treadonly configuration: IConfig;\n\treadonly unresolvedConfiguration: IConfig | undefined;\n\treadonly state: State;\n\treadonly root: IWorkspaceFolder | undefined;\n\treadonly parentSession: IDebugSession | undefined;\n\treadonly subId: string | undefined;\n\treadonly compact: boolean;\n\treadonly compoundRoot: DebugCompoundRoot | undefined;\n\treadonly saveBeforeRestart: boolean;\n\treadonly name: string;\n\treadonly autoExpandLazyVariables: boolean;\n\treadonly suppressDebugToolbar: boolean;\n\treadonly suppressDebugStatusbar: boolean;\n\treadonly suppressDebugView: boolean;\n\treadonly lifecycleManagedByParent: boolean;\n\t/** Test run this debug session was spawned by */\n\treadonly correlatedTestRun?: LiveTestResult;\n\n\tsetSubId(subId: string | undefined): void;\n\n\tgetMemory(memoryReference: string): IMemoryRegion;\n\n\tsetName(name: string): void;\n\treadonly onDidChangeName: Event<string>;\n\tgetLabel(): string;\n\n\tgetSourceForUri(modelUri: uri): Source | undefined;\n\tgetSource(raw?: DebugProtocol.Source): Source;\n\n\tsetConfiguration(configuration: { resolved: IConfig; unresolved: IConfig | undefined }): void;\n\trawUpdate(data: IRawModelUpdate): void;\n\n\tgetThread(threadId: number): IThread | undefined;\n\tgetAllThreads(): IThread[];\n\tclearThreads(removeThreads: boolean, reference?: number): void;\n\tgetStoppedDetails(): IRawStoppedDetails | undefined;\n\n\tgetReplElements(): IReplElement[];\n\thasSeparateRepl(): boolean;\n\tremoveReplExpressions(): void;\n\taddReplExpression(stackFrame: IStackFrame | undefined, name: string): Promise<void>;\n\tappendToRepl(data: INewReplElementData): void;\n\t/** Cancel any associated test run set through the DebugSessionOptions */\n\tcancelCorrelatedTestRun(): void;\n\n\t// session events\n\treadonly onDidEndAdapter: Event<AdapterEndEvent | undefined>;\n\treadonly onDidChangeState: Event<void>;\n\treadonly onDidChangeReplElements: Event<IReplElement | undefined>;\n\n\t/** DA capabilities. Set only when there is a running session available. */\n\treadonly capabilities: DebugProtocol.Capabilities;\n\t/** DA capabilities. These are retained on the session even after is implementation ends. */\n\treadonly rememberedCapabilities?: DebugProtocol.Capabilities;\n\n\t// DAP events\n\n\treadonly onDidLoadedSource: Event<LoadedSourceEvent>;\n\treadonly onDidCustomEvent: Event<DebugProtocol.Event>;\n\treadonly onDidProgressStart: Event<DebugProtocol.ProgressStartEvent>;\n\treadonly onDidProgressUpdate: Event<DebugProtocol.ProgressUpdateEvent>;\n\treadonly onDidProgressEnd: Event<DebugProtocol.ProgressEndEvent>;\n\treadonly onDidInvalidateMemory: Event<DebugProtocol.MemoryEvent>;\n\n\t// DAP request\n\n\tinitialize(dbgr: IDebugger): Promise<void>;\n\tlaunchOrAttach(config: IConfig): Promise<void>;\n\trestart(): Promise<void>;\n\tterminate(restart?: boolean /* false */): Promise<void>;\n\tdisconnect(restart?: boolean /* false */, suspend?: boolean): Promise<void>;\n\n\tsendBreakpoints(modelUri: uri, bpts: IBreakpoint[], sourceModified: boolean): Promise<void>;\n\tsendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void>;\n\tdataBreakpointInfo(name: string, variablesReference?: number, frameId?: number): Promise<IDataBreakpointInfoResponse | undefined>;\n\tdataBytesBreakpointInfo(address: string, bytes: number): Promise<IDataBreakpointInfoResponse | undefined>;\n\tsendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void>;\n\tsendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void>;\n\tsendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void>;\n\tbreakpointsLocations(uri: uri, lineNumber: number): Promise<IPosition[]>;\n\tgetDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined;\n\tresolveLocationReference(locationReference: number): Promise<IDebugLocationReferenced>;\n\n\tstackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse | undefined>;\n\texceptionInfo(threadId: number): Promise<IExceptionInfo | undefined>;\n\tscopes(frameId: number, threadId: number): Promise<DebugProtocol.ScopesResponse | undefined>;\n\tvariables(variablesReference: number, threadId: number | undefined, filter: 'indexed' | 'named' | undefined, start: number | undefined, count: number | undefined): Promise<DebugProtocol.VariablesResponse | undefined>;\n\tevaluate(expression: string, frameId?: number, context?: string, location?: IDebugEvaluatePosition): Promise<DebugProtocol.EvaluateResponse | undefined>;\n\tcustomRequest(request: string, args: unknown): Promise<DebugProtocol.Response | undefined>;\n\tcancel(progressId: string): Promise<DebugProtocol.CancelResponse | undefined>;\n\tdisassemble(memoryReference: string, offset: number, instructionOffset: number, instructionCount: number): Promise<DebugProtocol.DisassembledInstruction[] | undefined>;\n\treadMemory(memoryReference: string, offset: number, count: number): Promise<DebugProtocol.ReadMemoryResponse | undefined>;\n\twriteMemory(memoryReference: string, offset: number, data: string, allowPartial?: boolean): Promise<DebugProtocol.WriteMemoryResponse | undefined>;\n\n\trestartFrame(frameId: number, threadId: number): Promise<void>;\n\tnext(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepIn(threadId: number, targetId?: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepInTargets(frameId: number): Promise<DebugProtocol.StepInTarget[] | undefined>;\n\tstepOut(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepBack(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tcontinue(threadId: number): Promise<void>;\n\treverseContinue(threadId: number): Promise<void>;\n\tpause(threadId: number): Promise<void>;\n\tterminateThreads(threadIds: number[]): Promise<void>;\n\n\tcompletions(frameId: number | undefined, threadId: number, text: string, position: Position, token: CancellationToken): Promise<DebugProtocol.CompletionsResponse | undefined>;\n\tsetVariable(variablesReference: number | undefined, name: string, value: string): Promise<DebugProtocol.SetVariableResponse | undefined>;\n\tsetExpression(frameId: number, expression: string, value: string): Promise<DebugProtocol.SetExpressionResponse | undefined>;\n\tloadSource(resource: uri): Promise<DebugProtocol.SourceResponse | undefined>;\n\tgetLoadedSources(): Promise<Source[]>;\n\n\tgotoTargets(source: DebugProtocol.Source, line: number, column?: number): Promise<DebugProtocol.GotoTargetsResponse | undefined>;\n\tgoto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse | undefined>;\n}\n\nexport interface IThread extends ITreeElement {\n\n\t/**\n\t * Process the thread belongs to\n\t */\n\treadonly session: IDebugSession;\n\n\t/**\n\t * Id of the thread generated by the debug adapter backend.\n\t */\n\treadonly threadId: number;\n\n\t/**\n\t * Name of the thread.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Information about the current thread stop event. Undefined if thread is not stopped.\n\t */\n\treadonly stoppedDetails: IRawStoppedDetails | undefined;\n\n\t/**\n\t * Information about the exception if an 'exception' stopped event raised and DA supports the 'exceptionInfo' request, otherwise undefined.\n\t */\n\treadonly exceptionInfo: Promise<IExceptionInfo | undefined>;\n\n\treadonly stateLabel: string;\n\n\t/**\n\t * Gets the callstack if it has already been received from the debug\n\t * adapter.\n\t */\n\tgetCallStack(): ReadonlyArray<IStackFrame>;\n\n\n\t/**\n\t * Gets the top stack frame that is not hidden if the callstack has already been received from the debug adapter\n\t */\n\tgetTopStackFrame(): IStackFrame | undefined;\n\n\t/**\n\t * Invalidates the callstack cache\n\t */\n\tclearCallStack(): void;\n\n\t/**\n\t * Indicates whether this thread is stopped. The callstack for stopped\n\t * threads can be retrieved from the debug adapter.\n\t */\n\treadonly stopped: boolean;\n\n\tnext(granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepIn(granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepOut(granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepBack(granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tcontinue(): Promise<void>;\n\tpause(): Promise<void>;\n\tterminate(): Promise<void>;\n\treverseContinue(): Promise<void>;\n}\n\nexport interface IScope extends IExpressionContainer {\n\treadonly name: string;\n\treadonly expensive: boolean;\n\treadonly range?: IRange;\n\treadonly hasChildren: boolean;\n}\n\nexport interface IStackFrame extends ITreeElement {\n\treadonly thread: IThread;\n\treadonly name: string;\n\treadonly presentationHint: string | undefined;\n\treadonly frameId: number;\n\treadonly range: IRange;\n\treadonly source: Source;\n\treadonly canRestart: boolean;\n\treadonly instructionPointerReference?: string;\n\tgetScopes(): Promise<IScope[]>;\n\tgetMostSpecificScopes(range: IRange): Promise<ReadonlyArray<IScope>>;\n\tforgetScopes(): void;\n\trestart(): Promise<void>;\n\ttoString(): string;\n\topenInEditor(editorService: IEditorService, preserveFocus?: boolean, sideBySide?: boolean, pinned?: boolean): Promise<IEditorPane | undefined>;\n\tequals(other: IStackFrame): boolean;\n}\n\nexport function isFrameDeemphasized(frame: IStackFrame): boolean {\n\tconst hint = frame.presentationHint ?? frame.source.presentationHint;\n\treturn hint === 'deemphasize' || hint === 'subtle';\n}\n\nexport interface IEnablement extends ITreeElement {\n\treadonly enabled: boolean;\n}\n\nexport interface IBreakpointData {\n\treadonly id?: string;\n\treadonly lineNumber: number;\n\treadonly column?: number;\n\treadonly enabled?: boolean;\n\treadonly condition?: string;\n\treadonly logMessage?: string;\n\treadonly hitCondition?: string;\n\treadonly triggeredBy?: string;\n\treadonly mode?: string;\n\treadonly modeLabel?: string;\n}\n\nexport interface IBreakpointUpdateData {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly lineNumber?: number;\n\treadonly column?: number;\n\treadonly triggeredBy?: string;\n\treadonly mode?: string;\n\treadonly modeLabel?: string;\n}\n\nexport interface IBaseBreakpoint extends IEnablement {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly verified: boolean;\n\treadonly supported: boolean;\n\treadonly message?: string;\n\t/** The preferred mode of the breakpoint from {@link DebugProtocol.BreakpointMode} */\n\treadonly mode?: string;\n\t/** The preferred mode label of the breakpoint from {@link DebugProtocol.BreakpointMode} */\n\treadonly modeLabel?: string;\n\treadonly sessionsThatVerified: string[];\n\tgetIdFromAdapter(sessionId: string): number | undefined;\n}\n\nexport interface IBreakpoint extends IBaseBreakpoint {\n\t/** URI where the breakpoint was first set by the user. */\n\treadonly originalUri: uri;\n\t/** URI where the breakpoint is currently shown; may be moved by debugger */\n\treadonly uri: uri;\n\treadonly lineNumber: number;\n\treadonly endLineNumber?: number;\n\treadonly column?: number;\n\treadonly endColumn?: number;\n\treadonly adapterData: unknown;\n\treadonly sessionAgnosticData: { lineNumber: number; column: number | undefined };\n\t/** An ID of the breakpoint that triggers this breakpoint. */\n\treadonly triggeredBy?: string;\n\t/** Pending on the trigger breakpoint, which means this breakpoint is not yet sent to DA */\n\treadonly pending: boolean;\n\n\t/** Marks that a session did trigger the breakpoint. */\n\tsetSessionDidTrigger(sessionId: string, didTrigger?: boolean): void;\n\t/** Gets whether the `triggeredBy` condition has been met in the given sesison ID. */\n\tgetSessionDidTrigger(sessionId: string): boolean;\n\n\ttoDAP(): DebugProtocol.SourceBreakpoint;\n}\n\nexport interface IFunctionBreakpoint extends IBaseBreakpoint {\n\treadonly name: string;\n\ttoDAP(): DebugProtocol.FunctionBreakpoint;\n}\n\nexport interface IExceptionBreakpoint extends IBaseBreakpoint {\n\treadonly filter: string;\n\treadonly label: string;\n\treadonly description: string | undefined;\n}\n\nexport const enum DataBreakpointSetType {\n\tVariable,\n\tAddress,\n}\n\n/**\n * Source for a data breakpoint. A data breakpoint on a variable always has a\n * `dataId` because it cannot reference that variable globally, but addresses\n * can request info repeated and use session-specific data.\n */\nexport type DataBreakpointSource =\n\t| { type: DataBreakpointSetType.Variable; dataId: string }\n\t| { type: DataBreakpointSetType.Address; address: string; bytes: number };\n\nexport interface IDataBreakpoint extends IBaseBreakpoint {\n\treadonly description: string;\n\treadonly canPersist: boolean;\n\treadonly src: DataBreakpointSource;\n\treadonly accessType: DebugProtocol.DataBreakpointAccessType;\n\ttoDAP(session: IDebugSession): Promise<DebugProtocol.DataBreakpoint | undefined>;\n}\n\nexport interface IInstructionBreakpoint extends IBaseBreakpoint {\n\treadonly instructionReference: string;\n\treadonly offset?: number;\n\t/** Original instruction memory address; display purposes only */\n\treadonly address: bigint;\n\ttoDAP(): DebugProtocol.InstructionBreakpoint;\n}\n\nexport interface IExceptionInfo {\n\treadonly id?: string;\n\treadonly description?: string;\n\treadonly breakMode: string | null;\n\treadonly details?: DebugProtocol.ExceptionDetails;\n}\n\n// model interfaces\n\nexport interface IViewModel extends ITreeElement {\n\t/**\n\t * Returns the focused debug session or undefined if no session is stopped.\n\t */\n\treadonly focusedSession: IDebugSession | undefined;\n\n\t/**\n\t * Returns the focused thread or undefined if no thread is stopped.\n\t */\n\treadonly focusedThread: IThread | undefined;\n\n\t/**\n\t * Returns the focused stack frame or undefined if there are no stack frames.\n\t */\n\treadonly focusedStackFrame: IStackFrame | undefined;\n\n\tsetVisualizedExpression(original: IExpression, visualized: IExpression & { treeId: string } | undefined): void;\n\t/** Returns the visualized expression if loaded, or a tree it should be visualized with, or undefined */\n\tgetVisualizedExpression(expression: IExpression): IExpression | string | undefined;\n\tgetSelectedExpression(): { expression: IExpression; settingWatch: boolean } | undefined;\n\tsetSelectedExpression(expression: IExpression | undefined, settingWatch: boolean): void;\n\tupdateViews(): void;\n\n\tisMultiSessionView(): boolean;\n\n\treadonly onDidFocusSession: Event<IDebugSession | undefined>;\n\treadonly onDidFocusThread: Event<{ thread: IThread | undefined; explicit: boolean; session: IDebugSession | undefined }>;\n\treadonly onDidFocusStackFrame: Event<{ stackFrame: IStackFrame | undefined; explicit: boolean; session: IDebugSession | undefined }>;\n\treadonly onDidSelectExpression: Event<{ expression: IExpression; settingWatch: boolean } | undefined>;\n\treadonly onDidEvaluateLazyExpression: Event<IExpressionContainer>;\n\t/**\n\t * Fired when `setVisualizedExpression`, to migrate elements currently\n\t * rendered as `original` to the `replacement`.\n\t */\n\treadonly onDidChangeVisualization: Event<{ original: IExpression; replacement: IExpression }>;\n\treadonly onWillUpdateViews: Event<void>;\n\n\tevaluateLazyExpression(expression: IExpressionContainer): void;\n}\n\nexport interface IEvaluate {\n\tevaluate(session: IDebugSession, stackFrame: IStackFrame, context: string): Promise<void>;\n}\n\nexport interface IDebugModel extends ITreeElement {\n\tgetSession(sessionId: string | undefined, includeInactive?: boolean): IDebugSession | undefined;\n\tgetSessions(includeInactive?: boolean): IDebugSession[];\n\tgetBreakpoints(filter?: { uri?: uri; originalUri?: uri; lineNumber?: number; column?: number; enabledOnly?: boolean; triggeredOnly?: boolean }): ReadonlyArray<IBreakpoint>;\n\tareBreakpointsActivated(): boolean;\n\tgetFunctionBreakpoints(): ReadonlyArray<IFunctionBreakpoint>;\n\tgetDataBreakpoints(): ReadonlyArray<IDataBreakpoint>;\n\n\t/**\n\t * Returns list of all exception breakpoints.\n\t */\n\tgetExceptionBreakpoints(): ReadonlyArray<IExceptionBreakpoint>;\n\n\t/**\n\t * Returns list of exception breakpoints for the given session\n\t * @param sessionId Session id. If falsy, returns the breakpoints from the last set fallback session.\n\t */\n\tgetExceptionBreakpointsForSession(sessionId?: string): ReadonlyArray<IExceptionBreakpoint>;\n\n\tgetInstructionBreakpoints(): ReadonlyArray<IInstructionBreakpoint>;\n\tgetWatchExpressions(): ReadonlyArray<IExpression & IEvaluate>;\n\tregisterBreakpointModes(debugType: string, modes: DebugProtocol.BreakpointMode[]): void;\n\tgetBreakpointModes(forBreakpointType: 'source' | 'exception' | 'data' | 'instruction'): DebugProtocol.BreakpointMode[];\n\treadonly onDidChangeBreakpoints: Event<IBreakpointsChangeEvent | undefined>;\n\treadonly onDidChangeCallStack: Event<void>;\n\t/**\n\t * The expression has been added, removed, or repositioned.\n\t */\n\treadonly onDidChangeWatchExpressions: Event<IExpression | undefined>;\n\t/**\n\t * The expression's value has changed.\n\t */\n\treadonly onDidChangeWatchExpressionValue: Event<IExpression | undefined>;\n\n\tfetchCallstack(thread: IThread, levels?: number): Promise<void>;\n}\n\n/**\n * An event describing a change to the set of [breakpoints](#debug.Breakpoint).\n */\nexport interface IBreakpointsChangeEvent {\n\tadded?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;\n\tremoved?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;\n\tchanged?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;\n\tsessionOnly: boolean;\n}\n\n// Debug configuration interfaces\n\nexport interface IDebugConfiguration {\n\tallowBreakpointsEverywhere: boolean;\n\tgutterMiddleClickAction: 'logpoint' | 'conditionalBreakpoint' | 'triggeredBreakpoint' | 'none';\n\topenDebug: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart' | 'openOnDebugBreak';\n\topenExplorerOnEnd: boolean;\n\tinlineValues: boolean | 'auto' | 'on' | 'off'; // boolean for back-compat\n\ttoolBarLocation: 'floating' | 'docked' | 'commandCenter' | 'hidden';\n\tshowInStatusBar: 'never' | 'always' | 'onFirstSessionStart';\n\tinternalConsoleOptions: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';\n\textensionHostDebugAdapter: boolean;\n\tenableAllHovers: boolean;\n\tshowSubSessionsInToolBar: boolean;\n\tcloseReadonlyTabsOnEnd: boolean;\n\tconsole: {\n\t\tfontSize: number;\n\t\tfontFamily: string;\n\t\tlineHeight: number;\n\t\twordWrap: boolean;\n\t\tcloseOnEnd: boolean;\n\t\tcollapseIdenticalLines: boolean;\n\t\thistorySuggestions: boolean;\n\t\tacceptSuggestionOnEnter: 'off' | 'on';\n\t\tmaximumLines: number;\n\t};\n\tfocusWindowOnBreak: boolean;\n\tfocusEditorOnBreak: boolean;\n\tonTaskErrors: 'debugAnyway' | 'showErrors' | 'prompt' | 'abort';\n\tshowBreakpointsInOverviewRuler: boolean;\n\tshowInlineBreakpointCandidates: boolean;\n\tconfirmOnExit: 'always' | 'never';\n\tdisassemblyView: {\n\t\tshowSourceCode: boolean;\n\t};\n\tautoExpandLazyVariables: 'auto' | 'off' | 'on';\n\tenableStatusBarColor: boolean;\n\tshowVariableTypes: boolean;\n\thideSlowPreLaunchWarning: boolean;\n}\n\nexport interface IGlobalConfig {\n\tversion: string;\n\tcompounds: ICompound[];\n\tconfigurations: IConfig[];\n}\n\ninterface IEnvConfig {\n\tinternalConsoleOptions?: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';\n\tpreRestartTask?: string | ITaskIdentifier;\n\tpostRestartTask?: string | ITaskIdentifier;\n\tpreLaunchTask?: string | ITaskIdentifier;\n\tpostDebugTask?: string | ITaskIdentifier;\n\tdebugServer?: number;\n\tnoDebug?: boolean;\n\tsuppressMultipleSessionWarning?: boolean;\n}\n\nexport interface IConfigPresentation {\n\thidden?: boolean;\n\tgroup?: string;\n\torder?: number;\n}\n\nexport interface IConfig extends IEnvConfig {\n\n\t// fundamental attributes\n\ttype: string;\n\trequest: string;\n\tname: string;\n\tpresentation?: IConfigPresentation;\n\t// platform specifics\n\twindows?: IEnvConfig;\n\tosx?: IEnvConfig;\n\tlinux?: IEnvConfig;\n\n\t// internals\n\t__configurationTarget?: ConfigurationTarget;\n\t__sessionId?: string;\n\t__restart?: unknown;\n\t__autoAttach?: boolean;\n\tport?: number; // TODO\n}\n\nexport interface ICompound {\n\tname: string;\n\tstopAll?: boolean;\n\tpreLaunchTask?: string | ITaskIdentifier;\n\tconfigurations: (string | { name: string; folder: string })[];\n\tpresentation?: IConfigPresentation;\n}\n\nexport interface IDebugAdapter extends IDisposable {\n\treadonly onError: Event<Error>;\n\treadonly onExit: Event<number | null>;\n\tonRequest(callback: (request: DebugProtocol.Request) => void): void;\n\tonEvent(callback: (event: DebugProtocol.Event) => void): void;\n\tstartSession(): Promise<void>;\n\tsendMessage(message: DebugProtocol.ProtocolMessage): void;\n\tsendResponse(response: DebugProtocol.Response): void;\n\tsendRequest(command: string, args: unknown, clb: (result: DebugProtocol.Response) => void, timeout?: number): number;\n\tstopSession(): Promise<void>;\n}\n\nexport interface IDebugAdapterFactory extends ITerminalLauncher {\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter;\n\tsubstituteVariables(folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;\n}\n\nexport interface IDebugAdapterExecutableOptions {\n\tcwd?: string;\n\tenv?: { [key: string]: string };\n}\n\nexport interface IDebugAdapterExecutable {\n\treadonly type: 'executable';\n\treadonly command: string;\n\treadonly args: string[];\n\treadonly options?: IDebugAdapterExecutableOptions;\n}\n\nexport interface IDebugAdapterServer {\n\treadonly type: 'server';\n\treadonly port: number;\n\treadonly host?: string;\n}\n\nexport interface IDebugAdapterNamedPipeServer {\n\treadonly type: 'pipeServer';\n\treadonly path: string;\n}\n\nexport interface IDebugAdapterInlineImpl extends IDisposable {\n\treadonly onDidSendMessage: Event<DebugProtocol.Message>;\n\thandleMessage(message: DebugProtocol.Message): void;\n}\n\nexport interface IDebugAdapterImpl {\n\treadonly type: 'implementation';\n}\n\nexport type IAdapterDescriptor = IDebugAdapterExecutable | IDebugAdapterServer | IDebugAdapterNamedPipeServer | IDebugAdapterImpl;\n\nexport interface IPlatformSpecificAdapterContribution {\n\tprogram?: string;\n\targs?: string[];\n\truntime?: string;\n\truntimeArgs?: string[];\n}\n\nexport interface IDebuggerContribution extends IPlatformSpecificAdapterContribution {\n\ttype: string;\n\tlabel?: string;\n\twin?: IPlatformSpecificAdapterContribution;\n\twinx86?: IPlatformSpecificAdapterContribution;\n\twindows?: IPlatformSpecificAdapterContribution;\n\tosx?: IPlatformSpecificAdapterContribution;\n\tlinux?: IPlatformSpecificAdapterContribution;\n\n\t// internal\n\taiKey?: string;\n\n\t// supported languages\n\tlanguages?: string[];\n\n\t// debug configuration support\n\tconfigurationAttributes?: Record<string, IJSONSchema>;\n\tinitialConfigurations?: unknown[];\n\tconfigurationSnippets?: IJSONSchemaSnippet[];\n\tvariables?: { [key: string]: string };\n\twhen?: string;\n\thiddenWhen?: string;\n\tdeprecated?: string;\n\tstrings?: { [key in DebuggerString]: string };\n\t/** @deprecated */\n\tuiMessages?: { [key in DebuggerString]: string };\n}\n\nexport interface IBreakpointContribution {\n\tlanguage: string;\n\twhen?: string;\n}\n\nexport enum DebugConfigurationProviderTriggerKind {\n\t/**\n\t *\t`DebugConfigurationProvider.provideDebugConfigurations` is called to provide the initial debug configurations for a newly created launch.json.\n\t */\n\tInitial = 1,\n\t/**\n\t * `DebugConfigurationProvider.provideDebugConfigurations` is called to provide dynamically generated debug configurations when the user asks for them through the UI (e.g. via the \"Select and Start Debugging\" command).\n\t */\n\tDynamic = 2\n}\n\nexport interface IDebugConfigurationProvider {\n\treadonly type: string;\n\treadonly triggerKind: DebugConfigurationProviderTriggerKind;\n\tresolveDebugConfiguration?(folderUri: uri | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;\n\tresolveDebugConfigurationWithSubstitutedVariables?(folderUri: uri | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;\n\tprovideDebugConfigurations?(folderUri: uri | undefined, token: CancellationToken): Promise<IConfig[]>;\n}\n\nexport interface IDebugAdapterDescriptorFactory {\n\treadonly type: string;\n\tcreateDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor>;\n}\n\ninterface ITerminalLauncher {\n\trunInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n}\n\nexport interface IConfigurationManager {\n\n\t/**\n\t * Returns an object containing the selected launch configuration and the selected configuration name. Both these fields can be null (no folder workspace).\n\t */\n\treadonly selectedConfiguration: {\n\t\tlaunch: ILaunch | undefined;\n\t\t// Potentially activates extensions\n\t\tgetConfig: () => Promise<IConfig | undefined>;\n\t\tname: string | undefined;\n\t\t// Type is used when matching dynamic configurations to their corresponding provider\n\t\ttype: string | undefined;\n\t};\n\n\tselectConfiguration(launch: ILaunch | undefined, name?: string, config?: IConfig, dynamicConfigOptions?: { type?: string }): Promise<void>;\n\n\tgetLaunches(): ReadonlyArray<ILaunch>;\n\tgetLaunch(workspaceUri: uri | undefined): ILaunch | undefined;\n\tgetAllConfigurations(): { launch: ILaunch; name: string; presentation?: IConfigPresentation }[];\n\tremoveRecentDynamicConfigurations(name: string, type: string): void;\n\tgetRecentDynamicConfigurations(): { name: string; type: string }[];\n\n\t/**\n\t * Allows to register on change of selected debug configuration.\n\t */\n\treadonly onDidSelectConfiguration: Event<void>;\n\n\t/**\n\t * Allows to register on change of selected debug configuration.\n\t */\n\treadonly onDidChangeConfigurationProviders: Event<void>;\n\n\thasDebugConfigurationProvider(debugType: string, triggerKind?: DebugConfigurationProviderTriggerKind): boolean;\n\tgetDynamicProviders(): Promise<{ label: string; type: string; pick: () => Promise<{ launch: ILaunch; config: IConfig; label: string } | undefined> }[]>;\n\tgetDynamicConfigurationsByType(type: string, token?: CancellationToken): Promise<{ launch: ILaunch; config: IConfig; label: string }[]>;\n\n\tregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): IDisposable;\n\tunregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): void;\n\n\tresolveConfigurationByProviders(folderUri: uri | undefined, type: string | undefined, debugConfiguration: unknown, token: CancellationToken): Promise<IConfig | null | undefined>;\n}\n\nexport enum DebuggerString {\n\tUnverifiedBreakpoints = 'unverifiedBreakpoints'\n}\n\nexport interface IAdapterManager {\n\n\treadonly onDidRegisterDebugger: Event<void>;\n\n\thasEnabledDebuggers(): boolean;\n\tgetDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor | undefined>;\n\tgetDebuggerLabel(type: string): string | undefined;\n\tsomeDebuggerInterestedInLanguage(language: string): boolean;\n\tgetDebugger(type: string): IDebuggerMetadata | undefined;\n\n\tactivateDebuggers(activationEvent: string, debugType?: string): Promise<void>;\n\tregisterDebugAdapterFactory(debugTypes: string[], debugAdapterFactory: IDebugAdapterFactory): IDisposable;\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter | undefined;\n\tregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): IDisposable;\n\tunregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): void;\n\n\tsubstituteVariables(debugType: string, folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;\n\trunInTerminal(debugType: string, args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n\tgetEnabledDebugger(type: string): (IDebugger & IDebuggerMetadata) | undefined;\n\tguessDebugger(gettingConfigurations: boolean): Promise<IGuessedDebugger | undefined>;\n\n\tget onDidDebuggersExtPointRead(): Event<void>;\n}\n\nexport interface IGuessedDebugger {\n\tdebugger: IDebugger;\n\twithConfig?: {\n\t\tlabel: string;\n\t\tlaunch: ILaunch;\n\t\tconfig: IConfig;\n\t};\n}\n\nexport interface ILaunch {\n\n\t/**\n\t * Resource pointing to the launch.json this object is wrapping.\n\t */\n\treadonly uri: uri;\n\n\t/**\n\t * Name of the launch.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Workspace of the launch. Can be undefined.\n\t */\n\treadonly workspace: IWorkspaceFolder | undefined;\n\n\t/**\n\t * Should this launch be shown in the debug dropdown.\n\t */\n\treadonly hidden: boolean;\n\n\t/**\n\t * Returns a configuration with the specified name.\n\t * Returns undefined if there is no configuration with the specified name.\n\t */\n\tgetConfiguration(name: string): IConfig | undefined;\n\n\t/**\n\t * Returns a compound with the specified name.\n\t * Returns undefined if there is no compound with the specified name.\n\t */\n\tgetCompound(name: string): ICompound | undefined;\n\n\t/**\n\t * Returns the names of all configurations and compounds.\n\t * Ignores configurations which are invalid.\n\t */\n\tgetConfigurationNames(ignoreCompoundsAndPresentation?: boolean): string[];\n\n\t/**\n\t * Opens the launch.json file. Creates if it does not exist.\n\t */\n\topenConfigFile(options: { preserveFocus: boolean; type?: string; suppressInitialConfigs?: boolean }, token?: CancellationToken): Promise<{ editor: IEditorPane | null; created: boolean }>;\n}\n\n// Debug service interfaces\n\nexport const IDebugService = createDecorator<IDebugService>('debugService');\n\nexport interface IDebugService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Gets the current debug state.\n\t */\n\treadonly state: State;\n\n\treadonly initializingOptions?: IDebugSessionOptions | undefined;\n\n\t/**\n\t * Allows to register on debug state changes.\n\t */\n\treadonly onDidChangeState: Event<State>;\n\n\t/**\n\t * Allows to register on sessions about to be created (not yet fully initialised).\n\t * This is fired exactly one time for any given session.\n\t */\n\treadonly onWillNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Fired when a new debug session is started. This may fire multiple times\n\t * for a single session due to restarts.\n\t */\n\treadonly onDidNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Allows to register on end session events.\n\t *\n\t * Contains a boolean indicating whether the session will restart. If restart\n\t * is true, the session should not considered to be dead yet.\n\t */\n\treadonly onDidEndSession: Event<{ session: IDebugSession; restart: boolean }>;\n\n\t/**\n\t * Gets the configuration manager.\n\t */\n\tgetConfigurationManager(): IConfigurationManager;\n\n\t/**\n\t * Gets the adapter manager.\n\t */\n\tgetAdapterManager(): IAdapterManager;\n\n\t/**\n\t * Sets the focused stack frame and evaluates all expressions against the newly focused stack frame,\n\t */\n\tfocusStackFrame(focusedStackFrame: IStackFrame | undefined, thread?: IThread, session?: IDebugSession, options?: { explicit?: boolean; preserveFocus?: boolean; sideBySide?: boolean; pinned?: boolean }): Promise<void>;\n\n\t/**\n\t * Returns true if breakpoints can be set for a given editor model. Depends on mode.\n\t */\n\tcanSetBreakpointsIn(model: EditorIModel): boolean;\n\n\t/**\n\t * Adds new breakpoints to the model for the file specified with the uri. Notifies debug adapter of breakpoint changes.\n\t */\n\taddBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[], ariaAnnounce?: boolean): Promise<IBreakpoint[]>;\n\n\t/**\n\t * Updates the breakpoints.\n\t */\n\tupdateBreakpoints(originalUri: uri, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void>;\n\n\t/**\n\t * Enables or disables all breakpoints. If breakpoint is passed only enables or disables the passed breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tenableOrDisableBreakpoints(enable: boolean, breakpoint?: IEnablement): Promise<void>;\n\n\t/**\n\t * Sets the global activated property for all breakpoints.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tsetBreakpointsActivated(activated: boolean): Promise<void>;\n\n\t/**\n\t * Removes all breakpoints. If id is passed only removes the breakpoint associated with that id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new function breakpoint for the given name.\n\t */\n\taddFunctionBreakpoint(opts?: IFunctionBreakpointOptions, id?: string): void;\n\n\t/**\n\t * Updates an already existing function breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tupdateFunctionBreakpoint(id: string, update: { name?: string; hitCondition?: string; condition?: string }): Promise<void>;\n\n\t/**\n\t * Removes all function breakpoints. If id is passed only removes the function breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveFunctionBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new data breakpoint.\n\t */\n\taddDataBreakpoint(opts: IDataBreakpointOptions): Promise<void>;\n\n\t/**\n\t * Updates an already existing data breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tupdateDataBreakpoint(id: string, update: { hitCondition?: string; condition?: string }): Promise<void>;\n\n\t/**\n\t * Removes all data breakpoints. If id is passed only removes the data breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveDataBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new instruction breakpoint.\n\t */\n\taddInstructionBreakpoint(opts: IInstructionBreakpointOptions): Promise<void>;\n\n\t/**\n\t * Removes all instruction breakpoints. If address is passed only removes the instruction breakpoint with the passed address.\n\t * The address should be the address string supplied by the debugger from the \"Disassemble\" request.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveInstructionBreakpoints(instructionReference?: string, offset?: number): Promise<void>;\n\n\tsetExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string | undefined): Promise<void>;\n\n\t/**\n\t * Creates breakpoints based on the sesison filter options. This will create\n\t * disabled breakpoints (or enabled, if the filter indicates it's a default)\n\t * for each filter provided in the session.\n\t */\n\tsetExceptionBreakpointsForSession(session: IDebugSession, filters: DebugProtocol.ExceptionBreakpointsFilter[]): void;\n\n\t/**\n\t * Sends all breakpoints to the passed session.\n\t * If session is not passed, sends all breakpoints to each session.\n\t */\n\tsendAllBreakpoints(session?: IDebugSession): Promise<void>;\n\n\t/**\n\t * Sends breakpoints of the given source to the passed session.\n\t */\n\tsendBreakpoints(modelUri: uri, sourceModified?: boolean, session?: IDebugSession): Promise<void>;\n\n\t/**\n\t * Adds a new watch expression and evaluates it against the debug adapter.\n\t */\n\taddWatchExpression(name?: string): void;\n\n\t/**\n\t * Renames a watch expression and evaluates it against the debug adapter.\n\t */\n\trenameWatchExpression(id: string, newName: string): void;\n\n\t/**\n\t * Moves a watch expression to a new possition. Used for reordering watch expressions.\n\t */\n\tmoveWatchExpression(id: string, position: number): void;\n\n\t/**\n\t * Removes all watch expressions. If id is passed only removes the watch expression with the passed id.\n\t */\n\tremoveWatchExpressions(id?: string): void;\n\n\t/**\n\t * Starts debugging. If the configOrName is not passed uses the selected configuration in the debug dropdown.\n\t * Also saves all files, manages if compounds are present in the configuration\n\t * and resolveds configurations via DebugConfigurationProviders.\n\t *\n\t * Returns true if the start debugging was successful. For compound launches, all configurations have to start successfully for it to return success.\n\t * On errors the startDebugging will throw an error, however some error and cancelations are handled and in that case will simply return false.\n\t */\n\tstartDebugging(launch: ILaunch | undefined, configOrName?: IConfig | string, options?: IDebugSessionOptions, saveBeforeStart?: boolean): Promise<boolean>;\n\n\t/**\n\t * Restarts a session or creates a new one if there is no active session.\n\t */\n\trestartSession(session: IDebugSession, restartData?: unknown): Promise<void>;\n\n\t/**\n\t * Stops the session. If no session is specified then all sessions are stopped.\n\t */\n\tstopSession(session: IDebugSession | undefined, disconnect?: boolean, suspend?: boolean): Promise<void>;\n\n\t/**\n\t * Makes unavailable all sources with the passed uri. Source will appear as grayed out in callstack view.\n\t */\n\tsourceIsNotAvailable(uri: uri): void;\n\n\t/**\n\t * Gets the current debug model.\n\t */\n\tgetModel(): IDebugModel;\n\n\t/**\n\t * Gets the current view model.\n\t */\n\tgetViewModel(): IViewModel;\n\n\t/**\n\t * Resumes execution and pauses until the given position is reached.\n\t */\n\trunTo(uri: uri, lineNumber: number, column?: number): Promise<void>;\n}\n\n// Editor interfaces\nexport const enum BreakpointWidgetContext {\n\tCONDITION = 0,\n\tHIT_COUNT = 1,\n\tLOG_MESSAGE = 2,\n\tTRIGGER_POINT = 3\n}\n\nexport interface IDebugEditorContribution extends editorCommon.IEditorContribution {\n\tshowHover(range: Position, focus: boolean): Promise<void>;\n\taddLaunchConfiguration(): Promise<void>;\n\tcloseExceptionWidget(): void;\n}\n\nexport interface IBreakpointEditorContribution extends editorCommon.IEditorContribution {\n\tshowBreakpointWidget(lineNumber: number, column: number | undefined, context?: BreakpointWidgetContext): void;\n\tcloseBreakpointWidget(): void;\n\tgetContextMenuActionsAtPosition(lineNumber: number, model: EditorIModel): IAction[];\n}\n\nexport interface IReplConfiguration {\n\treadonly fontSize: number;\n\treadonly fontFamily: string;\n\treadonly lineHeight: number;\n\treadonly cssLineHeight: string;\n\treadonly backgroundColor: Color | undefined;\n\treadonly fontSizeForTwistie: number;\n}\n\nexport interface IReplOptions {\n\treadonly replConfiguration: IReplConfiguration;\n}\n\nexport interface IDebugVisualizationContext {\n\tvariable: DebugProtocol.Variable;\n\tcontainerId?: number;\n\tframeId?: number;\n\tthreadId: number;\n\tsessionId: string;\n}\n\nexport const enum DebugVisualizationType {\n\tCommand,\n\tTree,\n}\n\nexport type MainThreadDebugVisualization =\n\t| { type: DebugVisualizationType.Command }\n\t| { type: DebugVisualizationType.Tree; id: string };\n\n\nexport const enum DebugTreeItemCollapsibleState {\n\tNone = 0,\n\tCollapsed = 1,\n\tExpanded = 2\n}\n\nexport interface IDebugVisualizationTreeItem {\n\tid: number;\n\tlabel: string;\n\tdescription?: string;\n\tcollapsibleState: DebugTreeItemCollapsibleState;\n\tcontextValue?: string;\n\tcanEdit?: boolean;\n}\n\nexport namespace IDebugVisualizationTreeItem {\n\texport type Serialized = IDebugVisualizationTreeItem;\n\texport const deserialize = (v: Serialized): IDebugVisualizationTreeItem => v;\n\texport const serialize = (item: IDebugVisualizationTreeItem): Serialized => item;\n}\n\nexport interface IDebugVisualization {\n\tid: number;\n\tname: string;\n\ticonPath: { light?: URI; dark: URI } | undefined;\n\ticonClass: string | undefined;\n\tvisualization: MainThreadDebugVisualization | undefined;\n}\n\nexport namespace IDebugVisualization {\n\texport interface Serialized {\n\t\tid: number;\n\t\tname: string;\n\t\ticonPath?: { light?: UriComponents; dark: UriComponents };\n\t\ticonClass?: string;\n\t\tvisualization?: MainThreadDebugVisualization;\n\t}\n\n\texport const deserialize = (v: Serialized): IDebugVisualization => ({\n\t\tid: v.id,\n\t\tname: v.name,\n\t\ticonPath: v.iconPath && { light: URI.revive(v.iconPath.light), dark: URI.revive(v.iconPath.dark) },\n\t\ticonClass: v.iconClass,\n\t\tvisualization: v.visualization,\n\t});\n\n\texport const serialize = (visualizer: IDebugVisualization): Serialized => visualizer;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","ignoreList":[]}